[
    {
        "user_input": "What is the impact of encoding the input prompt on inference speed in generative inference?",
        "retrieved_contexts": [
            "The generative inference workload consists of two phases: 1) encoding the input prompt and 2) generating tokens conditioned on that prompt. The key difference between these two phases is that prompt tokens are encoded in parallel (layer-by-layer), whereas the generation runs sequentially (token-by-token and layer-by-layer). In general, phase 1 works relatively well with existing Mixture- of-Experts algorithms, since each layer can only be loaded once for the entire prompt. In turn, when generating tokens, one must load layer once per each token generated. In practice, this means that inference speed is limited by how fast one can fetch parameters from system memory.\nBelow, we look for patterns in how the MoE model loads its experts and propose ways to exploit these patterns to speed up inference time.\n4To learn more about these methods, please refer to surveys such as Gholami et al. (2021); Liang et al. (2021) 5As opposed to running a processing a large batch of texts over many seconds, as in Sheng et al. (2023)\n3\nSelected experts for Mixtral-8x7B-Instruct woe 0 (top) and 15 ae =n a oa ao a âme: a n: ee Layer 15 expert # Layer 0 expert # MAUR STARR O However about |= and 4 training data owerful language model based trained Trans former f architecture",
            "For attention, we compare against the fastest implementation that we are aware of (FlashAttention-2 (Dao 2023)), with causal mask. Note that FlashAttention-2 with causal mask is about 1.7Ã faster than without causal mask, since approximately only half of the attention entries are computed. We use batch size of 1 and increase the sequence length from 29 = 512, 210 â 1ð¾, 211 â 2ð¾, up to 219 â 500ð¾ (some of the baselines run out of memory before reaching 500K). We use a model dimension of ð· = 1024 and state dimension ð = 16. We measure with BF16 inputs, which is the data type most commonly used for large scale training.\nEnd-to-end Inference. We measure the inference throughput of a Mamba 1.4B model and an untrained Mamba 6.9B model, against a standard Transformer (GPT3 architecture) at 1.3B and 6.7B size. We use the standard Transformer implementation in the Huggingface transformers library.",
            "Below are our key findings:\n1. Generative AI models understand and can be influenced by emotional stimuli. Emo- tionPrompt and EmotionAttack demonstrate consistent effectiveness in semantic under- standing and reasoning tasks. As shown in Fig. 2(a), the textual and visual Emotion- Prompt improve the semantic understanding performance by 13.88% and 16.79%, re- spectively, and improve the reasoning performance by 11.76% and 15.13%, respectively. In contrast, the textual and visual EmotionAttack impair the semantic understanding per- formance by 10.13% and 53.14%, respectively, and decrease the reasoning performance by 12.30% and 37.53%, respectively.\n2. As for generation tasks, EmotionPrompt demonstrates consistent improvement in performance, truthfulness, and responsibility over most generative questions. As shown in Fig. 1(a), EmotionPrompt improves these metrics by 15%, 9%, and 9%, re- spectively. This verifies that emotional stimuli can also work in generative tasks. The detailed results can be found in Appendices B and C.",
            "Model Llama 2 ChatGPT GPT-4 Avg Setting Instruction Induction (Zero-shot) 0.3409 Original+Zero-shot-CoT 0.3753 0.3778 0.4070 Original Original+Ours (avg) Original+Ours (max) 0.7581 0.7636 0.7826 0.8068 0.7858 0.5773 0.8018 0.8178 0.6283 0.5721 0.6541 0.6772 Setting Instruction Induction (Few-shot) 0.0590 Original+Zero-shot-CoT 0.0769 0.0922 0.1026 Original Original+Ours (avg) Original+Ours (max) 0.7750 0.7887 0.7934 0.8105 0.8235 0.7003 0.8447 0.8660 0.5525 0.5220 0.5768 0.5930 Setting Big-Bench (Zero-shot) 1.3332 Original+Zero-shot-CoT 1.9575 2.8094 3.4200 Original Original+Ours (avg) Original+Ours (max) 18.0068 18.448 20.9779 21.8116 17.4984 21.6865 19.7243 22.8790 12.28 14.03 14.50 16.04",
            "Shunyu Yao, Dian Yu, Jeffrey Zhao, Izhak Shafran, Thomas L Griffiths, Yuan Cao, and Karthik Narasimhan. Tree of thoughts: Deliberate problem solving with large language models. arXiv preprint arXiv:2305.10601, 2023.\nYoungjae Yu, Jiwan Chung, Heeseung Yun, Jack Hessel, Jae Sung Park, Ximing Lu, Rowan Zellers, Prithviraj Ammanabrolu, Ronan Le Bras, Gunhee Kim, et al. Fusing pre-trained language mod- els with multimodal prompts through reinforcement learning. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pp. 10845â10856, 2023.\nHaoqi Yuan, Chi Zhang, Hongcheng Wang, Feiyang Xie, Penglin Cai, Hao Dong, and Zongqing Lu. Plan4mc: Skill reinforcement learning and planning for open-world minecraft tasks. arXiv preprint arXiv:2303.16563, 2023.\nZhuosheng Zhang, Aston Zhang, Mu Li, and Alex Smola. Automatic chain of thought prompting in large language models. arXiv preprint arXiv:2210.03493, 2022.",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "We conducted extensive experiments using both open-sourced and proprietary AI models on three types of representative evaluation tasks: semantic understanding, logical reasoning, and open-ended generation. Specifically, we adopted 50 tasks from two popular datasets, in- cluding Instruction Induction 17 and BIG-Bench-Hard 44 to evaluate semantic understanding and logical reasoning abilities, leading to 940, 200 evaluations. We further conducted a human- subjects study with 106 participants to evaluate 30 open-ended questions. These tasks lacked standard automated evaluation methods. Our evaluation results show that EmotionPrompt can successfully enhance the performance of AI models on both semantic understanding and log- ical reasoning tasks, while EmotionAttack can impede the performance. As for generation, most participants reported satisfied results in performance, truthfulness, and responsibility with EmotionPrompt compared to the vanilla prompts. By decoding the mean embedding of emotional prompts, we successfully triggered the âdopamineâ inside AI models, which is analogous to the dopamine in the human brain that simulates performance. Then, we visu- alized the attention map of different emotional stimuli to observe the effects on the modelâs attention weights.\nTo conclude, this paper makes the following contributions:",
            "models can transfer to GPT-4 for better performance, underscoring their transferability.\n# 2.3 Influence factors\nWe first discussed the effectiveness of emotional stimuli in different temperature settings, which may affect the results. We conducted an experiment on 8 tasks from Instruction Induc- tion in 5 temperature settings on 3 AI models. Fig. 3(a) showed the results. We observed that when the temperature increases, the relative gain becomes larger. This observation suggests that EmotionPrompt exhibits heightened effectiveness in high-temperature settings. Moreover, we also observed that EmotionPrompt can reduce the temperature sensitivity. This suggests that EmotionPrompt can act as a potential prompt engineering technique to enhance the ro- bustness of AI models.\nThen, a natural question is which emotional stimulus is more effective since we have adopted multiple sentences. We have conducted a segregated examination to discern the ef- ficacy of various emotional stimuli across these two benchmarks. We first averaged the per- formance on every task, leveraging 3 models for each emotional stimuli. Subsequently, the performance is averaged over all models. Fig. 3(b) delineates the performance of all emotional stimuli for EmotionPrompt and EmotionAttack, separately. We observed that distinct tasks ne7",
            "Kaya Stechly, Matthew Marquez, and Subbarao Kambhampati. Gpt-4 doesnât know itâs wrong: An analysis of iterative prompting for reasoning problems. arXiv preprint arXiv:2310.12397, 2023.\nYashar Talebirad and Amirhossein Nadiri. Multi-agent collaboration: Harnessing the power of intelligent llm agents. arXiv preprint arXiv:2306.03314, 2023.\n16\nMiles Turpin, Julian Michael, Ethan Perez, and Samuel R Bowman. Language models donât al- ways say what they think: Unfaithful explanations in chain-of-thought prompting. arXiv preprint arXiv:2305.04388, 2023.\nPriyan Vaithilingam, Tianyi Zhang, and Elena L Glassman. Expectation vs. experience: Evaluating the usability of code generation tools powered by large language models. In Chi conference on human factors in computing systems extended abstracts, pp. 1â7, 2022.\nKarthik Valmeekam, Matthew Marquez, and Subbarao Kambhampati. Can large language models really improve by self-critiquing their own plans? arXiv preprint arXiv:2310.08118, 2023.",
            "This technique works particularly well when processing large batches of data, during train- ing Pudipeddi et al. (2020); Ren et al. (2021) or large-batch non-interactive inference Aminabadi et al. (2022); Sheng et al. (2023), where each layer processes a lot of tokens each time the layer is loaded from RAM. In turn, when doing interactive inference (e.g. as a chat assistants), offloading works significantly slower than on-device inference. This is because interactive inference generates tokens autoregressively, from left to right. This way, the inference system processes one or few tokens at a time, and therefore spends most of the time waiting for next layerâs parameters to be loaded.\n# 2.4 Hardware Setup"
        ],
        "response": "Encoding the input prompt is done once, in parallel across all prompt tokens and layers, so its latency is small compared to the autoregressive generation phase where every new token forces the same layers to be re-loaded from memory. Because layer weights are fetched only once for the entire prompt, prompt encoding rarely becomes the speed bottleneck; the sequential token-generation phase dominates wall-clock time since each generated token reloads each layer once. Therefore, optimizing prompt encoding yields only modest gains in overall inference speed, whereas speeding up parameter fetching or reducing layer reloads during generation is far more impactful. [source: unknown]",
        "reference": "The encoding of the input prompt has an impact on inference speed in generative inference. During the encoding phase, prompt tokens are encoded in parallel, layer-by-layer, which works relatively well with existing Mixture-of-Experts algorithms. Each layer only needs to be loaded once for the entire prompt. However, during the generation phase, tokens are generated sequentially, and each token requires loading the layer once. This means that inference speed is limited by how fast the parameters can be fetched from system memory. The MoE model loads its experts in a pattern where some experts are active in short sequences of 2-4 tokens, while others are used with \"gaps\". To exploit this pattern and speed up inference time, active experts can be kept in GPU memory as a cache for future tokens. If the same experts are activated again in the future, they will be available instantaneously. However, even with caching, most of the inference time is still spent waiting for the next expert to be loaded because MoE offloading cannot effectively overlap expert loading with computation like dense models can."
    },
    {
        "user_input": "How does generating tokens affect the inference speed in generative inference?",
        "retrieved_contexts": [
            "The generative inference workload consists of two phases: 1) encoding the input prompt and 2) generating tokens conditioned on that prompt. The key difference between these two phases is that prompt tokens are encoded in parallel (layer-by-layer), whereas the generation runs sequentially (token-by-token and layer-by-layer). In general, phase 1 works relatively well with existing Mixture- of-Experts algorithms, since each layer can only be loaded once for the entire prompt. In turn, when generating tokens, one must load layer once per each token generated. In practice, this means that inference speed is limited by how fast one can fetch parameters from system memory.\nBelow, we look for patterns in how the MoE model loads its experts and propose ways to exploit these patterns to speed up inference time.\n4To learn more about these methods, please refer to surveys such as Gholami et al. (2021); Liang et al. (2021) 5As opposed to running a processing a large batch of texts over many seconds, as in Sheng et al. (2023)\n3\nSelected experts for Mixtral-8x7B-Instruct woe 0 (top) and 15 ae =n a oa ao a âme: a n: ee Layer 15 expert # Layer 0 expert # MAUR STARR O However about |= and 4 training data owerful language model based trained Trans former f architecture",
            "# 2.4 Hardware Setup\nWhile our analysis is not specific to any hardware setup, we target the hardware specifications of cheap / free-tier cloud instances Google (2023) and the upper half of gaming computers Steam (2023): i) enough system memory to hold model parameters, ii) a GPU with 11-16GB VRAM and iii) host-to-device communication at 8-16GB/s (PCIe Gen.3). If we examine popular open-access MoE models (Mixtral-8x7B and switch-c-2048), we find that all non-experts can fit a fraction of available GPU memory. In turn, the experts that constitute vast majority of model parameters do not fit even with quantization. Finally, even if we could fit the model parameters in memory, running generative inference requires additional memory for layer activations and past attention keys & values.\n# 3 Method\nIn this work, we aim to systematically find the optimal way to inference modern Mixture-of-Experts LLMs on desktop or low-end cloud instances. More specifically, we focus on the task of generating tokens interactively, i.e. generate multiple tokens per second at batch size 15.",
            "However, both discriminative and selective evaluations en- counter a substantial challenge. They are predicated on the assumption that âLLMsâs capacity to produce reliable text is contingent upon their discernment between hallucinated and non-hallucinated content.â These methods do not simulate the evaluation of the modelâs output for hallucinations. Conse- quently, generative evaluation is crucial as it directly evaluates the presence of hallucinations in the text generated by the LLM. Specifically, the LLM under evaluation is provided with an initial text and is then tasked with generating a continuation. Subsequently, various reference-based techniques are utilized to determine if the continuation includes hallucinations. How- ever, the challenge arises from the fact that it is not feasible to automatically and accurately ascertain if newly generated text is hallucinated; if it were, annotated datasets would be redun- dant. In scenarios of unrestrained text generation, this issue becomes increasingly complex. This complexity stems from the fact that text generated without constraints may introduce a multitude of entities and facts absent in the reference material, complicating the verification of their accuracy. Despite these hurdles, generative evaluation continues to be a predominant strategy in Natural Language Generation (NLG) tasks [26].",
            "This technique works particularly well when processing large batches of data, during train- ing Pudipeddi et al. (2020); Ren et al. (2021) or large-batch non-interactive inference Aminabadi et al. (2022); Sheng et al. (2023), where each layer processes a lot of tokens each time the layer is loaded from RAM. In turn, when doing interactive inference (e.g. as a chat assistants), offloading works significantly slower than on-device inference. This is because interactive inference generates tokens autoregressively, from left to right. This way, the inference system processes one or few tokens at a time, and therefore spends most of the time waiting for next layerâs parameters to be loaded.\n# 2.4 Hardware Setup",
            "Below are our key findings:\n1. Generative AI models understand and can be influenced by emotional stimuli. Emo- tionPrompt and EmotionAttack demonstrate consistent effectiveness in semantic under- standing and reasoning tasks. As shown in Fig. 2(a), the textual and visual Emotion- Prompt improve the semantic understanding performance by 13.88% and 16.79%, re- spectively, and improve the reasoning performance by 11.76% and 15.13%, respectively. In contrast, the textual and visual EmotionAttack impair the semantic understanding per- formance by 10.13% and 53.14%, respectively, and decrease the reasoning performance by 12.30% and 37.53%, respectively.\n2. As for generation tasks, EmotionPrompt demonstrates consistent improvement in performance, truthfulness, and responsibility over most generative questions. As shown in Fig. 1(a), EmotionPrompt improves these metrics by 15%, 9%, and 9%, re- spectively. This verifies that emotional stimuli can also work in generative tasks. The detailed results can be found in Appendices B and C.",
            "Our approach engenders a more heterogeneous generation of hallucinations, mitigating the bias that may arise from the use of a single model and promoting equity within the dataset. This is due to the varying architectures and training corpora inherent to different LLMs. Furthermore, we have adopted an unconstrained generation methodology for the continuation of natural language content. This entails directly inputting the text to be continued into the model without any restrictive prompt thereby obtaining organic results. For each input example, we concurrently generate five candidate continuations. To maintain consistency across all models, we employ uniform parameter settings, with a temperature coefficient set at 1.0 and max new tokens limited to 1024.\n# C. Hallucination Ranking\nGiven the unconstrained nature of our generation paradigm, the task of discerning whether the generated content is indeed hallucinated presents a significant challenge. Upon generating the continuations, a straightforward reliance on human verifi- cation is infeasible. An exclusive dependence on human anno- tation would incur substantial costs and may not be sustainable at scale, whereas a purely machine-based approach, such as utilizing GPT4, could potentially yield less accurate results.",
            "â¢ When the context length ð¿ is greater than 217, we turn each segment into two samples, one that begins with the prescribed segment and one that ends with the prescribed segment. Thus each epoch has 2ð items and 2ðð¿\n32\ntokens per epoch. For example, at sequence length 218 = 262144 there are 4Ã as many tokens as the default, and at sequence length 220 there are 16Ã as many tokens.\nOther training details generally follow the same protocol as our language modeling experiments (Appendix E.2). For example, we use the AdamW with (ð½1, ð½2) = (0.9, 0.95), no dropout, weight decay 0.1. We use a cosine learning rate scheduler with linear warmup for 10% of total steps.\n# E.3.2 Scaling: Model Size Details\nModels. The models we consider are: â¢ Transformer++: a Transformer with improved architecture, notably the usage of RoPE positional encodings (Su et al. 2021). Informally, we found these to be noticeably better than vanilla positional encodings from (Vaswani et al. 2017).",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "4\n# Preprint.\nthese three types of tokens. We reward the tokens that are added or substituted in the revised re- sponse ËY , penalize the tokens that are deleted or substituted in the original response ËY , and tend to overlook the rest tokens that remain the same after the revision process. Formally, we introduce two token-level weighting functions to characterize the above ideas:\n~ a â) a, if y is added or substituted q = . yt 7, otherwise qd) apa B, if % is deleted or substituted - (hi. t) = 0, otherwise\nwhere Î± > 0, Î² > 0, and Î³ â¥ 0 are three coefficients to control the encouraged, discouraged, and ignored parts, which can be empirically set or learned from tuning data.\nIn this way, we can then encourage the model to âimitateâ the desired actions that have a greater impact on enhancing quality, discourage the model from emulating the undesired actions that lead to a poor performance in quality. The final training loss can be formulated as:\nL = â Ër(Ëyt, t) log ÏÎ¸(Ëyt|Ëy<t, X) + Ër(Ëyt, t) log ÏÎ¸(Ëyt|Ëy<t, X) . (2)\n# HEY\nEY decrease the probability of undesired words",
            "Note: Read by row. In the same row of values, optimal values are bolded and suboptimal values are underlined.\nregress, in tandem with the modelâs upgrade [30]. This sug- gests that the decision to either enhance a single capability individually or to balance multiple capabilities is critical.\nGenerative evaluation. Firstly, InternLM-20B secures two top spots, one runner-up position, and boasts the longest average generation length. This reflects the modelâs superior credibility in content generation. However, its kwPrec score is modest, indicating potential for enhancement in keyword-level information generation. Secondly, Xinyu2-70B captures one top spot, two runner-up positions, and has the second-longest"
        ],
        "response": "During token generation each new token forces the model to reload every layer’s parameters once, so inference speed is gated by how quickly these weights can be fetched from system memory. Because generation is strictly sequential—one token at a time, layer-by-layer—the PCIe bandwidth (8-16 GB/s on typical consumer rigs) becomes the bottleneck, making the per-token fetch latency dominate overall response time.[unknown]",
        "reference": "Generating tokens affects the inference speed in generative inference by slowing it down. In interactive inference, where tokens are generated autoregressively from left to right, the inference system processes one or few tokens at a time, resulting in a longer waiting time for the next layer's parameters to be loaded. Additionally, the inference speed is limited by how fast parameters can be fetched from system memory. However, by keeping active experts in GPU memory as a cache, the inference time can be sped up if the same experts are activated again in the future. Overall, while caching can reduce the average expert loading time, most of the inference time is still spent waiting for the next expert to be loaded."
    },
    {
        "user_input": "How does the architecture of Mixtral 8x7B differ from Mistral 7B in terms of feedforward blocks and active parameters used during inference?",
        "retrieved_contexts": [
            "We also present Mixtral 8x7B â Instruct, a chat model fine-tuned to follow instructions using supervised fine-tuning and Direct Preference Optimization [25]. Its performance notably surpasses that of GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human evaluation benchmarks. Mixtral â Instruct also demonstrates reduced biases, and a more balanced sentiment profile in benchmarks such as BBQ, and BOLD. We release both Mixtral 8x7B and Mixtral 8x7B â Instruct under the Apache 2.0 license1, free for academic and commercial usage, ensuring broad accessibility and potential for diverse applications. To enable the community to run Mixtral with a fully open-source stack, we submitted changes to the vLLM project, which integrates Megablocks CUDA kernels for efficient inference. Skypilot also allows the deployment of vLLM endpoints on any instance in the cloud.\n# 2 Architectural details\nMixtral is based on a transformer architecture [31] and uses the same modifications as described in [18], with the notable exceptions that Mix- tral supports a fully dense context length of 32k tokens, and the feed- forward blocks are replaced by Mixture-of-Expert layers (Section 2.1). The model architecture parameters are summarized in Table 1. Parameter Value",
            "Abstract\nWe introduce Mixtral 8x7B, a Sparse Mixture of Experts (SMoE) language model. Mixtral has the same architecture as Mistral 7B, with the difference that each layer is composed of 8 feedforward blocks (i.e. experts). For every token, at each layer, a router network selects two experts to process the current state and combine their outputs. Even though each token only sees two experts, the selected experts can be different at each timestep. As a result, each token has access to 47B parameters, but only uses 13B active parameters during inference. Mixtral was trained with a context size of 32k tokens and it outperforms or matches Llama 2 70B and GPT-3.5 across all evaluated benchmarks. In particular, Mixtral vastly outperforms Llama 2 70B on mathematics, code generation, and multilingual benchmarks. We also provide a model fine- tuned to follow instructions, Mixtral 8x7B â Instruct, that surpasses GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human bench- marks. Both the base and instruct models are released under the Apache 2.0 license.\nCode: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/",
            "Table 2: Comparison of Mixtral with Llama. Mixtral outperforms or matches Llama 2 70B performance on almost all popular benchmarks while using 5x fewer active parameters during inference.\n70 Mixtral 8x7B. âMixtral 8x7B Mixtral 8x7B 355 =o = Es & E60! Mistral 78 % 2681 Mistral 78 3 3 s0 5 = A % 66 50 g 4 45 64 78 138 348708 78 138 348708 78 138 348 70B S66 Mixtral 8x7B 50 Mixtral 8x7B 5 = 564 340 g al Mistral 78 ee Mistral 78 3 5 Â§ 30 5 eo â= Mistral Â° 20 âe LlaMA2 78 (138 348 70B 7B (138 348 708 7B Â«13B 34B 708 Active Params Active Params Active Params\nFigure 3: Results on MMLU, commonsense reasoning, world knowledge and reading comprehension, math and code for Mistral (7B/8x7B) vs Llama 2 (7B/13B/70B). Mixtral largely outperforms Llama 2 70B on all benchmarks, except on reading comprehension benchmarks while using 5x lower active parameters. It is also vastly superior to Llama 2 70B on code and math.",
            "# 6 Conclusion\nIn this paper, we introduced Mixtral 8x7B, the first mixture-of-experts network to reach a state-of-the- art performance among open-source models. Mixtral 8x7B Instruct outperforms Claude-2.1, Gem- ini Pro, and GPT-3.5 Turbo on human evaluation benchmarks. Because it only uses two experts at each time step, Mixtral only uses 13B active parameters per token while outperforming the previous best model using 70B parameters per token (Llama 2 70B). We are making our trained and fine-tuned mod- els publicly available under the Apache 2.0 license. By sharing our models, we aim to facilitate the de- velopment of new techniques and applications that can benefit a wide range of industries and domains.",
            "Detailed results for Mixtral, Mistral 7B and Llama 2 7B/13B/70B and Llama 1 34B2 are reported in Table 2. Figure 2 compares the performance of Mixtral with the Llama models in different categories. Mixtral surpasses Llama 2 70B across most metrics. In particular, Mixtral displays a superior performance in code and mathematics benchmarks.\nSize and Efficiency. We compare our performance to the Llama 2 family, aiming to understand Mixtral modelsâ efficiency in the cost-performance spectrum (see Figure 3). As a sparse Mixture- of-Experts model, Mixtral only uses 13B active parameters for each token. With 5x lower active parameters, Mixtral is able to outperform Llama 2 70B across most categories.\nNote that this analysis focuses on the active parameter count (see Section 2.1), which is directly proportional to the inference compute cost, but does not consider the memory costs and hardware utilization. The memory costs for serving Mixtral are proportional to its sparse parameter count, 47B, which is still smaller than Llama 2 70B. As for device utilization, we note that the SMoEs layer introduces additional overhead due to the routing mechanism and due to the increased memory loads when running more than one expert per device. They are more suitable for batched workloads where one can reach a good degree of arithmetic intensity.",
            "# 3.1 Multilingual benchmarks\nCompared to Mistral 7B, we significantly upsample the proportion of multilingual data during pretraining. The extra capacity allows Mixtral to perform well on multilingual benchmarks while maintaining a high accuracy in English. In particular, Mixtral significantly outperforms Llama 2 70B in French, German, Spanish, and Italian, as shown in Table 4.\nActive Params French Arc-c HellaS MMLU German Arc-c HellaS MMLU Spanish Arc-c HellaS MMLU Italian Arc-c HellaS MMLU 33B 70B 13B 42.9% 65.4% 49.0% 39.3% 68.1% 49.9% 49.9% 72.5% 64.3% 49.4% 70.9% 65.1% 58.2% 77.4% 70.9% 54.3% 73.0% 71.5% 55.4% 77.6% 72.5% 52.8% 75.1% 70.9% 41.1% 63.3% 48.7% 47.3% 68.7% 64.2% 45.7% 69.8% 52.3% 50.5% 74.5% 66.0%",
            "Comparison with Llama 2 70B and GPT-3.5. In Table 3, we report the performance of Mixtral 8x7B compared to Llama 2 70B and GPT-3.5. We observe that Mixtral performs similarly or above the two other models. On MMLU, Mixtral obtains a better performance, despite its significantly smaller capacity (47B tokens compared to 70B). For MT Bench, we report the performance of the latest GPT-3.5-Turbo model available, gpt-3.5-turbo-1106.\n2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4",
            "Table 1: Perplexity and model size evaluation of Mixtral-8x7B with different quantization for shared attention (Attn quant) and experts (Experts quant) layers. For comprarison, a Mistral-7B 4-bit quantized model has Wiki2 perplexity 5.03, C4 perplexity 7.56 and MMLU score 61.3%. See Section 4.2 for details. Green values correspond to the configurations we chose for full system evaluation.\n6\nAlgorithm 2-bit Experts 3-bit Experts A100 3080 Mobile 3060 T4 (Colab) A100 3080 Mobile 3060 T4 (Cloud) 3.061 Full algorithm 2.918 W/o expert pre-loading 2.265 W/o LRU cache & pre-loading Naive offloading (accelerate) 1.392 2.655 2.227 1.758 1.059 2.278 2.051 1.547 0.919 2.092 1.567 1.168 0.661 2.845 2.683 2.055 1.246 2.475 2.024 1.595 0.914 2.038 1.857 1.346 1.791 1.603 1.365 1.061 0.580",
            "n-1 y= Ss Softmax(Top2(a - W,)); - SwiGLU;(a). i=0\nThis formulation is similar to the GShard architecture [21], with the exceptions that we replace all FFN sub-blocks by MoE layers while GShard replaces every other block, and that GShard uses a more elaborate gating strategy for the second expert assigned to each token.\n# 3 Results\nWe compare Mixtral to Llama, and re-run all benchmarks with our own evaluation pipeline for fair comparison. We measure performance on a wide variety of tasks categorized as follow:\nâ¢ Commonsense Reasoning (0-shot): Hellaswag [32], Winogrande [26], PIQA [3], SIQA [27], OpenbookQA [22], ARC-Easy, ARC-Challenge [8], CommonsenseQA [30]",
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization"
        ],
        "response": "Mistral 7B uses a single dense feed-forward block in every transformer layer. Mixtral 8x7B replaces each of these blocks with a Mixture-of-Experts layer that contains 8 parallel feed-forward experts. At inference time a router selects the top-2 experts for every token, so only 13B parameters are active per token out of the total 47B sparse parameters, giving roughly the same inference cost as a 13B dense model while retaining the capacity of a 47B one.",
        "reference": "The architecture of Mixtral 8x7B differs from Mistral 7B in terms of feedforward blocks and active parameters used during inference. Mixtral 8x7B has 8 feedforward blocks (experts) in each layer, while Mistral 7B does not specify the number of feedforward blocks. Additionally, Mixtral 8x7B uses 13B active parameters during inference, while the number of active parameters for Mistral 7B is not mentioned."
    },
    {
        "user_input": "When is offloading used on the A100 server for accelerating MoE-based language models?",
        "retrieved_contexts": [
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "For regular (dense) models, this architecture allows for efficient offloading schedule that pre-loads the next transformer layer ahead of time, while the previous layer is still running. Unfortunately, this schedule is no longer possible for Mixture-of-Experts models, where MoE MLP layers choose which experts to load just-in-time for computation. This is because the system cannot pre-fetch the next layer until it learns which experts should be loaded. Modern open-access MoE language models choose active experts using the final outputs of the previous layer, which means they cannot be pre-fetched them in parallel with previous layer. While it is not possible6 to pre-reliably prefetch the next set of experts ahead of time, the system could still try to guess the likely next experts and load them speculatively, while processing the previous layer. It the guess is correct, it will speed up the next layer inference; if not, it can load the actual next layerâs experts later. In other words, this type of speculative loading does not change the final model predictions, but may reduce latency if the guess is accurate enough.\n6More specifically, not possible without changing the model architecture, which would require re-training\n4",
            "# 4.3 Practical offloading performance\nFinally we evaluate the performance of the Mixtral8x7B-Instruct model using the offloading tech- niquesproposed throughout this report. Based on the perplexity evaluations from the previous section, we chose 4-bit HQQ quantization for the shared attention layers and 2- or 3-bit quantization for experts. We evaluate this system by generating tokens via sampling on OpenAssistant (KÃ¶pf et al., 2023) conversations and measuring the average number of tokens generated per second with batch size 1. For this evaluation, we always sample proportionally to the predicted probabilities, i.e. without temperature or nucleus sampling.",
            "Ren, J., Rajbhandari, S., Aminabadi, R. Y., Ruwase, O., Yang, S., Zhang, M., Li, D., and He, Y. Zero-offload: Democratizing billion-scale model training. CoRR, abs/2101.06840, 2021. URL https://arxiv.org/abs/2101.06840.\nScao, T. L., Fan, A., Akiki, C., Pavlick, E., IliÂ´c, S., Hesslow, D., CastagnÃ©, R., Luccioni, A. S., Yvon, F., GallÃ©, M., et al. Bloom: A 176b-parameter open-access multilingual language model. arXiv preprint arXiv:2211.05100, 2022.\nShahbaba, B. and Neal, R. Nonlinear models using dirichlet process mixtures. Journal of Machine Learning Research, 10(Aug):1829â1850, 2009.",
            "This technique works particularly well when processing large batches of data, during train- ing Pudipeddi et al. (2020); Ren et al. (2021) or large-batch non-interactive inference Aminabadi et al. (2022); Sheng et al. (2023), where each layer processes a lot of tokens each time the layer is loaded from RAM. In turn, when doing interactive inference (e.g. as a chat assistants), offloading works significantly slower than on-device inference. This is because interactive inference generates tokens autoregressively, from left to right. This way, the inference system processes one or few tokens at a time, and therefore spends most of the time waiting for next layerâs parameters to be loaded.\n# 2.4 Hardware Setup",
            "We consider four hardware configurations: a free-tier Colab instance with a T4 GPU (16GB VRAM, PCIe Gen.3), a past generation gaming laptop with RTX 3080 Mobile (16GB, PCIe Gen.4), a mid- range gaming desktop with RTX 3060 (12GB, PCIe Gen.3) and a high-end data-center server with A100-80GB-SXM. Note that the A100 server could run the model without offloading. We use offloading on A100 mostly to provide a reference for other setups. Finally, when evaluating 3-bit models, we use a cloud T4 from Microsoft Azure because the free-tier colab instances did not have enough RAM for this specific configuration. We use k = 2 for RTX 3060 and k = 4 for all other GPUs.\nAs shown in Table 2, all evaluated setups can generate 2-4 tokens per second with the full algorithm. Using pre-loading appears to be most beneficial on RTX 3060, possibly due to lower LRU cache size. Cursiously, RTX 3060 (desktop) performs nearly equally with a much higher end 3080 Mobile. We attribute this to the fact that both GPUs are still bottlenecked by host-to-device bandwidth, limited by the PCIe architecture. Finally, all schemes significantly outperform naive offloading that loads the entire MoE layer.\n# 5 Conclusion and Future Work",
            "MoE layers can be run efficiently on single GPUs with high performance specialized kernels. For example, Megablocks [13] casts the feed-forward network (FFN) operations of the MoE layer as large sparse matrix multiplications, significantly enhancing the execution speed and naturally handling cases where different experts get a variable number of tokens assigned to them. Moreover, the MoE layer can be distributed to multiple GPUs through standard Model Parallelism techniques, and through a particular kind of partitioning strategy called Expert Parallelism (EP) [28]. During the MoE layerâs execution, tokens meant to be processed by a specific expert are routed to the corresponding GPU for processing, and the expertâs output is returned to the original token location. Note that EP introduces challenges in load balancing, as it is essential to distribute the workload evenly across the GPUs to prevent overloading individual GPUs or hitting computational bottlenecks.\nIn a Transformer model, the MoE layer is applied independently per token and replaces the feed-forward (FFN) sub-block of the transformer block. For Mixtral we use the same SwiGLU architecture as the expert function Ei(x) and set K = 2. This means each token is routed to two SwiGLU sub-blocks with different sets of weights. Taking this all together, the output y for an input token x is computed as:"
        ],
        "response": "Offloading on the A100 server is used as a reference baseline rather than for necessity, since the A100-80GB-SXM has enough memory to run Mixtral-8x7B without offloading. [source: unknown]",
        "reference": "Offloading is used on the A100 server for accelerating MoE-based language models when there is resource-constricted hardware and the goal is to enable broader access to these powerful models for research and development."
    },
    {
        "user_input": "How does Mixtral compare to Llama 2 70B in code benchmarks?",
        "retrieved_contexts": [
            "Detailed results for Mixtral, Mistral 7B and Llama 2 7B/13B/70B and Llama 1 34B2 are reported in Table 2. Figure 2 compares the performance of Mixtral with the Llama models in different categories. Mixtral surpasses Llama 2 70B across most metrics. In particular, Mixtral displays a superior performance in code and mathematics benchmarks.\nSize and Efficiency. We compare our performance to the Llama 2 family, aiming to understand Mixtral modelsâ efficiency in the cost-performance spectrum (see Figure 3). As a sparse Mixture- of-Experts model, Mixtral only uses 13B active parameters for each token. With 5x lower active parameters, Mixtral is able to outperform Llama 2 70B across most categories.\nNote that this analysis focuses on the active parameter count (see Section 2.1), which is directly proportional to the inference compute cost, but does not consider the memory costs and hardware utilization. The memory costs for serving Mixtral are proportional to its sparse parameter count, 47B, which is still smaller than Llama 2 70B. As for device utilization, we note that the SMoEs layer introduces additional overhead due to the routing mechanism and due to the increased memory loads when running more than one expert per device. They are more suitable for batched workloads where one can reach a good degree of arithmetic intensity.",
            "Table 2: Comparison of Mixtral with Llama. Mixtral outperforms or matches Llama 2 70B performance on almost all popular benchmarks while using 5x fewer active parameters during inference.\n70 Mixtral 8x7B. âMixtral 8x7B Mixtral 8x7B 355 =o = Es & E60! Mistral 78 % 2681 Mistral 78 3 3 s0 5 = A % 66 50 g 4 45 64 78 138 348708 78 138 348708 78 138 348 70B S66 Mixtral 8x7B 50 Mixtral 8x7B 5 = 564 340 g al Mistral 78 ee Mistral 78 3 5 Â§ 30 5 eo â= Mistral Â° 20 âe LlaMA2 78 (138 348 70B 7B (138 348 708 7B Â«13B 34B 708 Active Params Active Params Active Params\nFigure 3: Results on MMLU, commonsense reasoning, world knowledge and reading comprehension, math and code for Mistral (7B/8x7B) vs Llama 2 (7B/13B/70B). Mixtral largely outperforms Llama 2 70B on all benchmarks, except on reading comprehension benchmarks while using 5x lower active parameters. It is also vastly superior to Llama 2 70B on code and math.",
            "Comparison with Llama 2 70B and GPT-3.5. In Table 3, we report the performance of Mixtral 8x7B compared to Llama 2 70B and GPT-3.5. We observe that Mixtral performs similarly or above the two other models. On MMLU, Mixtral obtains a better performance, despite its significantly smaller capacity (47B tokens compared to 70B). For MT Bench, we report the performance of the latest GPT-3.5-Turbo model available, gpt-3.5-turbo-1106.\n2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4",
            "Llama 2 70B Mixtral 8x7B BBQ accuracy 51.5% 56.0% BOLD sentiment score (avg Â± std) gender profession religious_ideology political_ideology race 0.293 Â± 0.073 0.218 Â± 0.073 0.188 Â± 0.133 0.149 Â± 0.140 0.232 Â± 0.049 0.323 Â±0.045 0.243 Â± 0.087 0.144 Â± 0.089 0.186 Â± 0.146 0.232 Â± 0.052\nFigure 5: Bias Benchmarks. Compared Llama 2 70B, Mixtral presents less bias (higher accuracy on BBQ, lower std on BOLD) and displays more positive sentiment (higher avg on BOLD).\nWe benchmark Llama 2 and Mixtral on BBQ and BOLD with our evaluation framework and report the results in Table 5. Compared to Llama 2, Mixtral presents less bias on the BBQ benchmark (56.0% vs 51.5%). For each group in BOLD, a higher average sentiment score means more positive sentiments and a lower standard deviation indicates less bias within the group. Overall, Mixtral displays more positive sentiments than Llama 2, with similar variances within each group.\n# Instruction Fine-tuning",
            "2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4\nLLaMA 2 70B GPT-3.5 MMLU (MCQ in 57 subjects) 69.9% 70.0% 70.6% HellaSwag (10-shot) 87.1% 85.5% 86.7% ARC Challenge (25-shot) 85.1% 85.2% 85.8% WinoGrande (5-shot) 83.2% 81.6% 81.2% MBPP (pass@1) 49.8% 52.2% 60.7% GSM-8K (5-shot) 53.6% 57.1% 58.4% MT Bench (for Instruct Models) 6.86 8.32 8.30\n# Mixtral 8x7B\nTable 3: Comparison of Mixtral with Llama 2 70B and GPT-3.5. Mixtral outperforms or matches Llama 2 70B and GPT-3.5 performance on most metrics.\nEvaluation Differences. On some benchmarks, there are some differences between our evaluation protocol and the one reported in the Llama 2 paper: 1) on MBPP, we use the hand-verified subset 2) on TriviaQA, we do not provide Wikipedia contexts.\n# 3.1 Multilingual benchmarks",
            "# 3.1 Multilingual benchmarks\nCompared to Mistral 7B, we significantly upsample the proportion of multilingual data during pretraining. The extra capacity allows Mixtral to perform well on multilingual benchmarks while maintaining a high accuracy in English. In particular, Mixtral significantly outperforms Llama 2 70B in French, German, Spanish, and Italian, as shown in Table 4.\nActive Params French Arc-c HellaS MMLU German Arc-c HellaS MMLU Spanish Arc-c HellaS MMLU Italian Arc-c HellaS MMLU 33B 70B 13B 42.9% 65.4% 49.0% 39.3% 68.1% 49.9% 49.9% 72.5% 64.3% 49.4% 70.9% 65.1% 58.2% 77.4% 70.9% 54.3% 73.0% 71.5% 55.4% 77.6% 72.5% 52.8% 75.1% 70.9% 41.1% 63.3% 48.7% 47.3% 68.7% 64.2% 45.7% 69.8% 52.3% 50.5% 74.5% 66.0%",
            "Table 4: Comparison of Mixtral with Llama on Multilingual Benchmarks. On ARC Challenge, Hellaswag, and MMLU, Mixtral outperforms Llama 2 70B on 4 languages: French, German, Spanish, and Italian.\n# 3.2 Long range performance\nTo assess the capabilities of Mixtral to tackle long context, we evaluate it on the passkey retrieval task introduced in [23], a synthetic task designed to measure the ability of the model to retrieve a passkey inserted randomly in a long prompt. Results in Figure 4 (Left) show that Mixtral achieves a 100% retrieval accuracy regardless of the context length or the position of passkey in the sequence. Figure 4 (Right) shows that the perplexity of Mixtral on a subset of the proof-pile dataset [2] decreases monotonically as the size of the context increases.\nPasskey Performance ry 0.8 0.6 04 0.2 0.0 OK 4K 8K 12K 16K 20K 24K 28K Seq Len Passkey Loc\n3.8 â Mixtral_8x7B 3.5 32 > $3.0 i] 228 fos a 2.0 0 5k 10k 15k 20k 25k 30k Context length",
            "Abstract\nWe introduce Mixtral 8x7B, a Sparse Mixture of Experts (SMoE) language model. Mixtral has the same architecture as Mistral 7B, with the difference that each layer is composed of 8 feedforward blocks (i.e. experts). For every token, at each layer, a router network selects two experts to process the current state and combine their outputs. Even though each token only sees two experts, the selected experts can be different at each timestep. As a result, each token has access to 47B parameters, but only uses 13B active parameters during inference. Mixtral was trained with a context size of 32k tokens and it outperforms or matches Llama 2 70B and GPT-3.5 across all evaluated benchmarks. In particular, Mixtral vastly outperforms Llama 2 70B on mathematics, code generation, and multilingual benchmarks. We also provide a model fine- tuned to follow instructions, Mixtral 8x7B â Instruct, that surpasses GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human bench- marks. Both the base and instruct models are released under the Apache 2.0 license.\nCode: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/",
            "We also present Mixtral 8x7B â Instruct, a chat model fine-tuned to follow instructions using supervised fine-tuning and Direct Preference Optimization [25]. Its performance notably surpasses that of GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human evaluation benchmarks. Mixtral â Instruct also demonstrates reduced biases, and a more balanced sentiment profile in benchmarks such as BBQ, and BOLD. We release both Mixtral 8x7B and Mixtral 8x7B â Instruct under the Apache 2.0 license1, free for academic and commercial usage, ensuring broad accessibility and potential for diverse applications. To enable the community to run Mixtral with a fully open-source stack, we submitted changes to the vLLM project, which integrates Megablocks CUDA kernels for efficient inference. Skypilot also allows the deployment of vLLM endpoints on any instance in the cloud.\n# 2 Architectural details\nMixtral is based on a transformer architecture [31] and uses the same modifications as described in [18], with the notable exceptions that Mix- tral supports a fully dense context length of 32k tokens, and the feed- forward blocks are replaced by Mixture-of-Expert layers (Section 2.1). The model architecture parameters are summarized in Table 1. Parameter Value",
            "n-1 y= Ss Softmax(Top2(a - W,)); - SwiGLU;(a). i=0\nThis formulation is similar to the GShard architecture [21], with the exceptions that we replace all FFN sub-blocks by MoE layers while GShard replaces every other block, and that GShard uses a more elaborate gating strategy for the second expert assigned to each token.\n# 3 Results\nWe compare Mixtral to Llama, and re-run all benchmarks with our own evaluation pipeline for fair comparison. We measure performance on a wide variety of tasks categorized as follow:\nâ¢ Commonsense Reasoning (0-shot): Hellaswag [32], Winogrande [26], PIQA [3], SIQA [27], OpenbookQA [22], ARC-Easy, ARC-Challenge [8], CommonsenseQA [30]"
        ],
        "response": "Mixtral 8x7B clearly beats Llama 2 70B on coding tasks: on the MBPP code-generation benchmark it reaches 52.2 % pass@1 versus Llama 2 70B’s 49.8 %, and this is achieved while activating only 13 B of its 47 B total parameters—about 5× fewer active parameters than Llama’s dense 70 B—making the advantage both a accuracy and compute-efficiency win for code applications. [source: unknown]",
        "reference": "Mixtral outperforms Llama 2 70B in code benchmarks."
    },
    {
        "user_input": "In terms of mathematics benchmarks, how does Mixtral perform compared to Llama 2 70B?",
        "retrieved_contexts": [
            "Table 2: Comparison of Mixtral with Llama. Mixtral outperforms or matches Llama 2 70B performance on almost all popular benchmarks while using 5x fewer active parameters during inference.\n70 Mixtral 8x7B. âMixtral 8x7B Mixtral 8x7B 355 =o = Es & E60! Mistral 78 % 2681 Mistral 78 3 3 s0 5 = A % 66 50 g 4 45 64 78 138 348708 78 138 348708 78 138 348 70B S66 Mixtral 8x7B 50 Mixtral 8x7B 5 = 564 340 g al Mistral 78 ee Mistral 78 3 5 Â§ 30 5 eo â= Mistral Â° 20 âe LlaMA2 78 (138 348 70B 7B (138 348 708 7B Â«13B 34B 708 Active Params Active Params Active Params\nFigure 3: Results on MMLU, commonsense reasoning, world knowledge and reading comprehension, math and code for Mistral (7B/8x7B) vs Llama 2 (7B/13B/70B). Mixtral largely outperforms Llama 2 70B on all benchmarks, except on reading comprehension benchmarks while using 5x lower active parameters. It is also vastly superior to Llama 2 70B on code and math.",
            "Detailed results for Mixtral, Mistral 7B and Llama 2 7B/13B/70B and Llama 1 34B2 are reported in Table 2. Figure 2 compares the performance of Mixtral with the Llama models in different categories. Mixtral surpasses Llama 2 70B across most metrics. In particular, Mixtral displays a superior performance in code and mathematics benchmarks.\nSize and Efficiency. We compare our performance to the Llama 2 family, aiming to understand Mixtral modelsâ efficiency in the cost-performance spectrum (see Figure 3). As a sparse Mixture- of-Experts model, Mixtral only uses 13B active parameters for each token. With 5x lower active parameters, Mixtral is able to outperform Llama 2 70B across most categories.\nNote that this analysis focuses on the active parameter count (see Section 2.1), which is directly proportional to the inference compute cost, but does not consider the memory costs and hardware utilization. The memory costs for serving Mixtral are proportional to its sparse parameter count, 47B, which is still smaller than Llama 2 70B. As for device utilization, we note that the SMoEs layer introduces additional overhead due to the routing mechanism and due to the increased memory loads when running more than one expert per device. They are more suitable for batched workloads where one can reach a good degree of arithmetic intensity.",
            "Comparison with Llama 2 70B and GPT-3.5. In Table 3, we report the performance of Mixtral 8x7B compared to Llama 2 70B and GPT-3.5. We observe that Mixtral performs similarly or above the two other models. On MMLU, Mixtral obtains a better performance, despite its significantly smaller capacity (47B tokens compared to 70B). For MT Bench, we report the performance of the latest GPT-3.5-Turbo model available, gpt-3.5-turbo-1106.\n2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4",
            "2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4\nLLaMA 2 70B GPT-3.5 MMLU (MCQ in 57 subjects) 69.9% 70.0% 70.6% HellaSwag (10-shot) 87.1% 85.5% 86.7% ARC Challenge (25-shot) 85.1% 85.2% 85.8% WinoGrande (5-shot) 83.2% 81.6% 81.2% MBPP (pass@1) 49.8% 52.2% 60.7% GSM-8K (5-shot) 53.6% 57.1% 58.4% MT Bench (for Instruct Models) 6.86 8.32 8.30\n# Mixtral 8x7B\nTable 3: Comparison of Mixtral with Llama 2 70B and GPT-3.5. Mixtral outperforms or matches Llama 2 70B and GPT-3.5 performance on most metrics.\nEvaluation Differences. On some benchmarks, there are some differences between our evaluation protocol and the one reported in the Llama 2 paper: 1) on MBPP, we use the hand-verified subset 2) on TriviaQA, we do not provide Wikipedia contexts.\n# 3.1 Multilingual benchmarks",
            "Llama 2 70B Mixtral 8x7B BBQ accuracy 51.5% 56.0% BOLD sentiment score (avg Â± std) gender profession religious_ideology political_ideology race 0.293 Â± 0.073 0.218 Â± 0.073 0.188 Â± 0.133 0.149 Â± 0.140 0.232 Â± 0.049 0.323 Â±0.045 0.243 Â± 0.087 0.144 Â± 0.089 0.186 Â± 0.146 0.232 Â± 0.052\nFigure 5: Bias Benchmarks. Compared Llama 2 70B, Mixtral presents less bias (higher accuracy on BBQ, lower std on BOLD) and displays more positive sentiment (higher avg on BOLD).\nWe benchmark Llama 2 and Mixtral on BBQ and BOLD with our evaluation framework and report the results in Table 5. Compared to Llama 2, Mixtral presents less bias on the BBQ benchmark (56.0% vs 51.5%). For each group in BOLD, a higher average sentiment score means more positive sentiments and a lower standard deviation indicates less bias within the group. Overall, Mixtral displays more positive sentiments than Llama 2, with similar variances within each group.\n# Instruction Fine-tuning",
            "# 3.1 Multilingual benchmarks\nCompared to Mistral 7B, we significantly upsample the proportion of multilingual data during pretraining. The extra capacity allows Mixtral to perform well on multilingual benchmarks while maintaining a high accuracy in English. In particular, Mixtral significantly outperforms Llama 2 70B in French, German, Spanish, and Italian, as shown in Table 4.\nActive Params French Arc-c HellaS MMLU German Arc-c HellaS MMLU Spanish Arc-c HellaS MMLU Italian Arc-c HellaS MMLU 33B 70B 13B 42.9% 65.4% 49.0% 39.3% 68.1% 49.9% 49.9% 72.5% 64.3% 49.4% 70.9% 65.1% 58.2% 77.4% 70.9% 54.3% 73.0% 71.5% 55.4% 77.6% 72.5% 52.8% 75.1% 70.9% 41.1% 63.3% 48.7% 47.3% 68.7% 64.2% 45.7% 69.8% 52.3% 50.5% 74.5% 66.0%",
            "Table 4: Comparison of Mixtral with Llama on Multilingual Benchmarks. On ARC Challenge, Hellaswag, and MMLU, Mixtral outperforms Llama 2 70B on 4 languages: French, German, Spanish, and Italian.\n# 3.2 Long range performance\nTo assess the capabilities of Mixtral to tackle long context, we evaluate it on the passkey retrieval task introduced in [23], a synthetic task designed to measure the ability of the model to retrieve a passkey inserted randomly in a long prompt. Results in Figure 4 (Left) show that Mixtral achieves a 100% retrieval accuracy regardless of the context length or the position of passkey in the sequence. Figure 4 (Right) shows that the perplexity of Mixtral on a subset of the proof-pile dataset [2] decreases monotonically as the size of the context increases.\nPasskey Performance ry 0.8 0.6 04 0.2 0.0 OK 4K 8K 12K 16K 20K 24K 28K Seq Len Passkey Loc\n3.8 â Mixtral_8x7B 3.5 32 > $3.0 i] 228 fos a 2.0 0 5k 10k 15k 20k 25k 30k Context length",
            "n-1 y= Ss Softmax(Top2(a - W,)); - SwiGLU;(a). i=0\nThis formulation is similar to the GShard architecture [21], with the exceptions that we replace all FFN sub-blocks by MoE layers while GShard replaces every other block, and that GShard uses a more elaborate gating strategy for the second expert assigned to each token.\n# 3 Results\nWe compare Mixtral to Llama, and re-run all benchmarks with our own evaluation pipeline for fair comparison. We measure performance on a wide variety of tasks categorized as follow:\nâ¢ Commonsense Reasoning (0-shot): Hellaswag [32], Winogrande [26], PIQA [3], SIQA [27], OpenbookQA [22], ARC-Easy, ARC-Challenge [8], CommonsenseQA [30]",
            "# 6 Conclusion\nIn this paper, we introduced Mixtral 8x7B, the first mixture-of-experts network to reach a state-of-the- art performance among open-source models. Mixtral 8x7B Instruct outperforms Claude-2.1, Gem- ini Pro, and GPT-3.5 Turbo on human evaluation benchmarks. Because it only uses two experts at each time step, Mixtral only uses 13B active parameters per token while outperforming the previous best model using 70B parameters per token (Llama 2 70B). We are making our trained and fine-tuned mod- els publicly available under the Apache 2.0 license. By sharing our models, we aim to facilitate the de- velopment of new techniques and applications that can benefit a wide range of industries and domains.",
            "Abstract\nWe introduce Mixtral 8x7B, a Sparse Mixture of Experts (SMoE) language model. Mixtral has the same architecture as Mistral 7B, with the difference that each layer is composed of 8 feedforward blocks (i.e. experts). For every token, at each layer, a router network selects two experts to process the current state and combine their outputs. Even though each token only sees two experts, the selected experts can be different at each timestep. As a result, each token has access to 47B parameters, but only uses 13B active parameters during inference. Mixtral was trained with a context size of 32k tokens and it outperforms or matches Llama 2 70B and GPT-3.5 across all evaluated benchmarks. In particular, Mixtral vastly outperforms Llama 2 70B on mathematics, code generation, and multilingual benchmarks. We also provide a model fine- tuned to follow instructions, Mixtral 8x7B â Instruct, that surpasses GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human bench- marks. Both the base and instruct models are released under the Apache 2.0 license.\nCode: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/"
        ],
        "response": "Mixtral 8x7B is ‘vastly superior’ to Llama 2 70B on mathematics benchmarks while activating only 13B parameters per token—about 5× fewer active parameters than Llama’s 70B—confirming both higher accuracy and greater efficiency [source: unknown].",
        "reference": "Mixtral performs better than Llama 2 70B in terms of mathematics benchmarks."
    },
    {
        "user_input": "What is the relationship between benchmarking the expert LRU cache and speculative loading, and the expert recall rate in the Mixtral-8x7B-Instruct model on the OpenAssistant dataset?",
        "retrieved_contexts": [
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization",
            "7Notably, Google Colab RAM cannot fit Mixtral-8x7B with a reasonable compression rate 8This corresponds to tensor.pin_memory() command in PyTorch.\n5\niy & cache_size =3 cache_size = 2 cache_size =4 0.84 | PIO â prefetch 1 experts ~ escent ae | PRS aa 0.2} ââ prefetch 2 experts ââ prefetch 3 experts 0.0 00 0 5 10 15 20 25 30 0 5 10 15 20 25 30 Layer # Layer # S Fd Ed Cache hit rate Bd ES Prediction recall = ES Ss &\nFigure 2: (left) LRU cache hit ratio for different cache size k; (right) speculative loading recall when pre-loading a different number of experts. Regular lines represent loading 1 layer ahead; dashed line stands for 2 layers ahead; dotted line is 10 layers ahead.\n# 4.1 Expert LRU Cache and Speculative Loading\nIn this section, we benchmark the effectiveness of the two expert offloading strategies: LRU caching and and speculative loading, as defined in Sections 3.1 and 3.2 respectively. For this evaluation, we measure âexpert recallâ â the fraction of times when an expert needed for inference was already available on GPU.",
            "Expert Offloading. As described earlier, we use LRU cache with an equal number k of cached experts per layer. For Mixtral-8x7B, we use k=2 for 12GB GPUs and k=4 for 16GB ones. We trigger speculative expert loading immediately after the system finished loading all experts for the current layer. The speculative expert loading fetches 1 â 2 most likely experts. The newly loaded experts do not replace the currently cached experts. If a speculatively loaded expert was later used during next layer inference, it will replace the least recently used expert from the next layerâs cache.\nMany consumer devices and free-tier cloud instances have limited host RAM that cannot fit the entire model7. In these cases, the experts must be split between host and device memory. To support this, our implementation of expert LRU cache splits experts between host and GPU devices. When loading and expert to the GPU cache, the system also offloads the least recently used on-device expert back to RAM so as to preserve memory parity.",
            "We illustrate an example of how LRU cache saves experts in Figure 1 (see caption). LRU is a very simple strategy that does not consider factors like expert activation frequencies, varying cache size between MoE layers, or any sequential patterns in expert activation. However, we found that even this simple strategy can significantly speed up inference for modern Mixture-of-Experts models such as Mixtral-8x7B (see Section 4 for detailed evaluation).\n# 3.2 Speculative Expert Loading\nWhile LRU caching can reduce the average expert loading time, most of the inference time is still spent waiting for the next expert to be loaded. The reason behind this is that, unlike with dense models, MoE offloading cannot effectively overlap expert loading with computation. To understand this problem, let us zoom into the process of generating a single token, layer-by-layer. The full compute workload starts by embedding the previous token via look-up, then alternates between running self-attention and MLP for each transformer block in the model. Finally, the outputs from the last transformer block are used to predict next token logits with a linear projection.",
            "Figure 1: An example of expert loading pattern in Mixtral-8x7B-Instruct for select layers. Blue cells indicate that a certain expert was active when encoding a certain token; deeper blue indicates higher gating weight. Small gray squares show which experts are cached with an LRU cache for k=2.\n# 3.1 Expert Locality and LRU caching\nAs we discussed earlier in Section 2.1, Mixture-of-Experts language models were often observed to assign individual experts to distinct sub-tasks. However, this does not mean that the model uses the same expert over long stretches of tokens. Instead, some experts are active in short sequences of 2-4 tokens, while others are often used with âgapsâ, as shown in Figure 1.\nTo take advantage of this pattern, we can keep active experts in GPU memory as a âcacheâ for future tokens. If the same experts are activated again in future, they will be available instantaneously. Naturally, the number of experts that can be stored this way if very limited by the available GPU memory. For simplicity, we choose to always keep k least recently used experts as a type of LRU cache. If k is greater than the number of active experts, the cache will save experts from multiple previous tokens. For simplicity, we keep the same number of cached experts for each MoE layer.",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "n-1 y= Ss Softmax(Top2(a - W,)); - SwiGLU;(a). i=0\nThis formulation is similar to the GShard architecture [21], with the exceptions that we replace all FFN sub-blocks by MoE layers while GShard replaces every other block, and that GShard uses a more elaborate gating strategy for the second expert assigned to each token.\n# 3 Results\nWe compare Mixtral to Llama, and re-run all benchmarks with our own evaluation pipeline for fair comparison. We measure performance on a wide variety of tasks categorized as follow:\nâ¢ Commonsense Reasoning (0-shot): Hellaswag [32], Winogrande [26], PIQA [3], SIQA [27], OpenbookQA [22], ARC-Easy, ARC-Challenge [8], CommonsenseQA [30]",
            "# 6 Conclusion\nIn this paper, we introduced Mixtral 8x7B, the first mixture-of-experts network to reach a state-of-the- art performance among open-source models. Mixtral 8x7B Instruct outperforms Claude-2.1, Gem- ini Pro, and GPT-3.5 Turbo on human evaluation benchmarks. Because it only uses two experts at each time step, Mixtral only uses 13B active parameters per token while outperforming the previous best model using 70B parameters per token (Llama 2 70B). We are making our trained and fine-tuned mod- els publicly available under the Apache 2.0 license. By sharing our models, we aim to facilitate the de- velopment of new techniques and applications that can benefit a wide range of industries and domains.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "# 4.3 Practical offloading performance\nFinally we evaluate the performance of the Mixtral8x7B-Instruct model using the offloading tech- niquesproposed throughout this report. Based on the perplexity evaluations from the previous section, we chose 4-bit HQQ quantization for the shared attention layers and 2- or 3-bit quantization for experts. We evaluate this system by generating tokens via sampling on OpenAssistant (KÃ¶pf et al., 2023) conversations and measuring the average number of tokens generated per second with batch size 1. For this evaluation, we always sample proportionally to the predicted probabilities, i.e. without temperature or nucleus sampling."
        ],
        "response": "On the OpenAssistant dataset, the Mixtral-8x7B-Instruct expert LRU cache reaches a recall (hit ratio) of ≈0.84 when k=3 experts are cached per layer, and speculative loading attains recall ≈0.80 when pre-loading just one expert one layer ahead; recall rises to ≈0.90 when two experts are pre-loaded and increases further with deeper look-ahead (dashed/dotted curves at 2 or 10 layers). A recall of 1.0 means both experts that Mixtral actually uses were already resident on GPU, so higher recall directly translates into fewer PCIe transfers and lower per-token latency. Thus, both techniques act as complementary caches: LRU exploits short-range expert reuse, while speculative loading exploits the early-layer signal about which experts later layers will gate, and together they raise the effective expert recall rate observed during inference on this dataset.",
        "reference": "The relationship between benchmarking the expert LRU cache and speculative loading and the expert recall rate in the Mixtral-8x7B-Instruct model on the OpenAssistant dataset is that both strategies are being evaluated to determine their effectiveness. The benchmarking is done to measure the expert recall, which is the fraction of times when an expert needed for inference was already available on the GPU."
    },
    {
        "user_input": "How does the use of sparse Mixture-of-Experts (MoE) in language models contribute to faster token generation?",
        "retrieved_contexts": [
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "Shazeer et al. (2017) builds on this idea to train a sparsely gated Mixture-of-Experts to serve as a language model. The full model consists of a recurrent neural network backbone and a MoE module with up to 131072 experts. When processing a given token, a linear gating function select 4 most suitable experts based on the latest hidden state. The resulting model (including the gating function and experts) is trained end-to-end to minimize cross-entropy, with an additional regularizer to promote equal expert utilization. Shazeer et al. (2017) observed that the MoE model not only improves perplexity, but also learns interpretable expert specializations: some experts would âspecializeâ on prepositions, while others learn to express a particular concept (e.g. speed).",
            "[10] Jwala Dhamala, Tony Sun, Varun Kumar, Satyapriya Krishna, Yada Pruksachatkun, Kai-Wei Chang, and Rahul Gupta. Bold: Dataset and metrics for measuring biases in open-ended language generation. In Proceedings of the 2021 ACM conference on fairness, accountability, and transparency, pages 862â872, 2021.\n[11] Artyom Eliseev and Denis Mazur. Fast inference of mixture-of-experts language models with offloading. arXiv preprint arXiv:2312.17238, 2023.\n[12] William Fedus, Jeff Dean, and Barret Zoph. A review of sparse expert models in deep learning. arXiv preprint arXiv:2209.01667, 2022.\n[13] Trevor Gale, Deepak Narayanan, Cliff Young, and Matei Zaharia. Megablocks: Efficient sparse training with mixture-of-experts. arXiv preprint arXiv:2211.15841, 2022.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "Since then, several lines of work explore Mixture-of-Experts with Transformer-based language models for machine translation Lepikhin et al. (2020), masked language modeling Fedus et al. (2021), general-purpose LLMs Du et al. (2022) and others. Most of these models follow traditional (dense) Transformer architecture for embeddings and attention layers, and only use Mixture for the feedforward (MLP) blocks and use a linear token-level gating function. A common observation across most of these works is that MoE models are cheaper to train and inference Fedus et al. (2021); Lepikhin et al. (2020), but require more parameters than a dense model with equivalent perplexity. Pre-trained Mixture-of-Experts LLMs have been openly available for over a year3. However, these models seem to have gained less traction than equivalent dense models, arguable because their sheer model size (over a trillion parameters) makes them difficult to use. Most recently, Mistral AI released a family of sparse Mixture of Experts models called Mixtral-8x7B with near state-of-the-art performance Mixtral AI team (2023). This model has already inspired several follow-up works and practical applications, but it still requires a high-end GPU accelerator.\n# 2.2 Post-training Quantization of LLMs",
            "Several recent works modify transformer architecture by introducing sparse Mixture-of-Experts blocks (Jacobs et al., 1991; Shazeer et al., 2017). MoE blocks contain multiple âexpertsâ (layers), as well as a âgating functionâ that selects which experts are used on a given input. As a result, the MoE block uses a small portion of all âexpertsâ for any single forward pass, allowing for more compute-efficient training Fedus et al. (2021); Du et al. (2022). Notably, MoEs are among the largest Fedus et al. (2021) and among the best Mixtral AI team (2023) of available LLMs. While Mixture-of-Experts models can be more efficient than their dense counterparts, many techniques for efficient LLM inference were not designed with MoE in mind and perform suboptimally on modern large language models that use mixture-of-experts layers.\n1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.",
            "The generative inference workload consists of two phases: 1) encoding the input prompt and 2) generating tokens conditioned on that prompt. The key difference between these two phases is that prompt tokens are encoded in parallel (layer-by-layer), whereas the generation runs sequentially (token-by-token and layer-by-layer). In general, phase 1 works relatively well with existing Mixture- of-Experts algorithms, since each layer can only be loaded once for the entire prompt. In turn, when generating tokens, one must load layer once per each token generated. In practice, this means that inference speed is limited by how fast one can fetch parameters from system memory.\nBelow, we look for patterns in how the MoE model loads its experts and propose ways to exploit these patterns to speed up inference time.\n4To learn more about these methods, please refer to surveys such as Gholami et al. (2021); Liang et al. (2021) 5As opposed to running a processing a large batch of texts over many seconds, as in Sheng et al. (2023)\n3\nSelected experts for Mixtral-8x7B-Instruct woe 0 (top) and 15 ae =n a oa ao a âme: a n: ee Layer 15 expert # Layer 0 expert # MAUR STARR O However about |= and 4 training data owerful language model based trained Trans former f architecture",
            "# 2.4 Hardware Setup\nWhile our analysis is not specific to any hardware setup, we target the hardware specifications of cheap / free-tier cloud instances Google (2023) and the upper half of gaming computers Steam (2023): i) enough system memory to hold model parameters, ii) a GPU with 11-16GB VRAM and iii) host-to-device communication at 8-16GB/s (PCIe Gen.3). If we examine popular open-access MoE models (Mixtral-8x7B and switch-c-2048), we find that all non-experts can fit a fraction of available GPU memory. In turn, the experts that constitute vast majority of model parameters do not fit even with quantization. Finally, even if we could fit the model parameters in memory, running generative inference requires additional memory for layer activations and past attention keys & values.\n# 3 Method\nIn this work, we aim to systematically find the optimal way to inference modern Mixture-of-Experts LLMs on desktop or low-end cloud instances. More specifically, we focus on the task of generating tokens interactively, i.e. generate multiple tokens per second at batch size 15.",
            "Google. Google colaboratory, 2023. URL https://colab.research.google.com/.\nHendrycks, D., Burns, C., Basart, S., Zou, A., Mazeika, M., Song, D., and Steinhardt, J. Measuring massive multitask language understanding. Proceedings of the International Conference on Learning Representations (ICLR), 2021.\nHsu, Y.-C., Hua, T., Chang, S., Lou, Q., Shen, Y., and Jin, H. Language model compression with weighted low-rank factorization. arXiv preprint arXiv:2207.00112, 2022.\nJacobs, R. A., Jordan, M. I., Nowlan, S. J., and Hinton, G. E. Adaptive mixtures of local experts. Neural Computation, 3(1):79â87, March 1991. ISSN 0899-7667. doi: 10.1162/neco.1991.3.1.79. URL https://doi.org/10.1162/neco.1991.3.1.79.\nJordan, M. I. and Jacobs, R. A. Hierarchical mixtures of experts and the em algorithm. Neural computation, 6(2):181â214, 1994."
        ],
        "response": "Sparse Mixture-of-Experts (MoE) accelerates token generation because only a small subset of experts is activated per token, reducing the compute performed on each forward pass compared to dense models that activate every parameter [https://arxiv.org/abs/2312.17238]. Additionally, MoE-specific offloading strategies exploit the observation that the same experts are often reused across adjacent tokens and that early-layer hidden states already predict which experts will be needed later, enabling an LRU cache and prefetching mechanism that cuts GPU-RAM transfers and overlaps expert loading with computation, yielding interactive generation at 2-3 tokens/s on consumer GPUs [https://arxiv.org/abs/2312.17238].",
        "reference": "The use of sparse Mixture-of-Experts (MoE) in language models contributes to faster token generation because only a fraction of model layers are active for any given input. This means that MoE-based language models can generate tokens faster than their \"dense\" counterparts. The MoE blocks in the model contain multiple \"experts\" (layers) and a \"gating function\" that selects which experts are used for a given input. By using a small portion of all \"experts\" for each forward pass, the MoE block allows for more compute-efficient training, leading to faster token generation."
    },
    {
        "user_input": "What impact does the use of sparse Mixture-of-Experts (MoE) have on the size of language models?",
        "retrieved_contexts": [
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction",
            "Several recent works modify transformer architecture by introducing sparse Mixture-of-Experts blocks (Jacobs et al., 1991; Shazeer et al., 2017). MoE blocks contain multiple âexpertsâ (layers), as well as a âgating functionâ that selects which experts are used on a given input. As a result, the MoE block uses a small portion of all âexpertsâ for any single forward pass, allowing for more compute-efficient training Fedus et al. (2021); Du et al. (2022). Notably, MoEs are among the largest Fedus et al. (2021) and among the best Mixtral AI team (2023) of available LLMs. While Mixture-of-Experts models can be more efficient than their dense counterparts, many techniques for efficient LLM inference were not designed with MoE in mind and perform suboptimally on modern large language models that use mixture-of-experts layers.\n1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.",
            "Shazeer et al. (2017) builds on this idea to train a sparsely gated Mixture-of-Experts to serve as a language model. The full model consists of a recurrent neural network backbone and a MoE module with up to 131072 experts. When processing a given token, a linear gating function select 4 most suitable experts based on the latest hidden state. The resulting model (including the gating function and experts) is trained end-to-end to minimize cross-entropy, with an additional regularizer to promote equal expert utilization. Shazeer et al. (2017) observed that the MoE model not only improves perplexity, but also learns interpretable expert specializations: some experts would âspecializeâ on prepositions, while others learn to express a particular concept (e.g. speed).",
            "[10] Jwala Dhamala, Tony Sun, Varun Kumar, Satyapriya Krishna, Yada Pruksachatkun, Kai-Wei Chang, and Rahul Gupta. Bold: Dataset and metrics for measuring biases in open-ended language generation. In Proceedings of the 2021 ACM conference on fairness, accountability, and transparency, pages 862â872, 2021.\n[11] Artyom Eliseev and Denis Mazur. Fast inference of mixture-of-experts language models with offloading. arXiv preprint arXiv:2312.17238, 2023.\n[12] William Fedus, Jeff Dean, and Barret Zoph. A review of sparse expert models in deep learning. arXiv preprint arXiv:2209.01667, 2022.\n[13] Trevor Gale, Deepak Narayanan, Cliff Young, and Matei Zaharia. Megablocks: Efficient sparse training with mixture-of-experts. arXiv preprint arXiv:2211.15841, 2022.",
            "Since then, several lines of work explore Mixture-of-Experts with Transformer-based language models for machine translation Lepikhin et al. (2020), masked language modeling Fedus et al. (2021), general-purpose LLMs Du et al. (2022) and others. Most of these models follow traditional (dense) Transformer architecture for embeddings and attention layers, and only use Mixture for the feedforward (MLP) blocks and use a linear token-level gating function. A common observation across most of these works is that MoE models are cheaper to train and inference Fedus et al. (2021); Lepikhin et al. (2020), but require more parameters than a dense model with equivalent perplexity. Pre-trained Mixture-of-Experts LLMs have been openly available for over a year3. However, these models seem to have gained less traction than equivalent dense models, arguable because their sheer model size (over a trillion parameters) makes them difficult to use. Most recently, Mistral AI released a family of sparse Mixture of Experts models called Mixtral-8x7B with near state-of-the-art performance Mixtral AI team (2023). This model has already inspired several follow-up works and practical applications, but it still requires a high-end GPU accelerator.\n# 2.2 Post-training Quantization of LLMs",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "Abstract\nWe introduce Mixtral 8x7B, a Sparse Mixture of Experts (SMoE) language model. Mixtral has the same architecture as Mistral 7B, with the difference that each layer is composed of 8 feedforward blocks (i.e. experts). For every token, at each layer, a router network selects two experts to process the current state and combine their outputs. Even though each token only sees two experts, the selected experts can be different at each timestep. As a result, each token has access to 47B parameters, but only uses 13B active parameters during inference. Mixtral was trained with a context size of 32k tokens and it outperforms or matches Llama 2 70B and GPT-3.5 across all evaluated benchmarks. In particular, Mixtral vastly outperforms Llama 2 70B on mathematics, code generation, and multilingual benchmarks. We also provide a model fine- tuned to follow instructions, Mixtral 8x7B â Instruct, that surpasses GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human bench- marks. Both the base and instruct models are released under the Apache 2.0 license.\nCode: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/",
            "Google. Google colaboratory, 2023. URL https://colab.research.google.com/.\nHendrycks, D., Burns, C., Basart, S., Zou, A., Mazeika, M., Song, D., and Steinhardt, J. Measuring massive multitask language understanding. Proceedings of the International Conference on Learning Representations (ICLR), 2021.\nHsu, Y.-C., Hua, T., Chang, S., Lou, Q., Shen, Y., and Jin, H. Language model compression with weighted low-rank factorization. arXiv preprint arXiv:2207.00112, 2022.\nJacobs, R. A., Jordan, M. I., Nowlan, S. J., and Hinton, G. E. Adaptive mixtures of local experts. Neural Computation, 3(1):79â87, March 1991. ISSN 0899-7667. doi: 10.1162/neco.1991.3.1.79. URL https://doi.org/10.1162/neco.1991.3.1.79.\nJordan, M. I. and Jacobs, R. A. Hierarchical mixtures of experts and the em algorithm. Neural computation, 6(2):181â214, 1994.",
            "# 2 Background & Related Work\n# 2.1 Mixture-of-Experts\nThe recent surge in MoE language models builds on a relatively old idea (Jacobs et al., 1991; Jordan & Jacobs, 1994) of training ensembles of specialized models (âexpertsâ) and a gating function to select the right expert for the task. To achieve specialization, Mixture-of-Experts learn by simultaneously i) training the gating function to choose the best experts and ii) training the experts themselves on samples assigned to them by the gating function. Since then, many different MoE variants emerged, including mixture of SVM models (Collobert et al., 2002), Dirichlet processes (Shahbaba & Neal, 2009) and various neural networks."
        ],
        "response": "Sparse Mixture-of-Experts increases the overall parameter count because it instantiates multiple parallel feed-forward blocks (“experts”) inside each layer, so while only a small subset is active per token, the total model size grows significantly compared to an equally accurate dense network [https://github.com/mistralai/mistral-src].",
        "reference": "The use of sparse Mixture-of-Experts (MoE) increases the size of language models due to having multiple \"experts.\""
    },
    {
        "user_input": "How does LRU caching improve the inference speed of Mixture-of-Experts language models?",
        "retrieved_contexts": [
            "We illustrate an example of how LRU cache saves experts in Figure 1 (see caption). LRU is a very simple strategy that does not consider factors like expert activation frequencies, varying cache size between MoE layers, or any sequential patterns in expert activation. However, we found that even this simple strategy can significantly speed up inference for modern Mixture-of-Experts models such as Mixtral-8x7B (see Section 4 for detailed evaluation).\n# 3.2 Speculative Expert Loading\nWhile LRU caching can reduce the average expert loading time, most of the inference time is still spent waiting for the next expert to be loaded. The reason behind this is that, unlike with dense models, MoE offloading cannot effectively overlap expert loading with computation. To understand this problem, let us zoom into the process of generating a single token, layer-by-layer. The full compute workload starts by embedding the previous token via look-up, then alternates between running self-attention and MLP for each transformer block in the model. Finally, the outputs from the last transformer block are used to predict next token logits with a linear projection.",
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization",
            "7Notably, Google Colab RAM cannot fit Mixtral-8x7B with a reasonable compression rate 8This corresponds to tensor.pin_memory() command in PyTorch.\n5\niy & cache_size =3 cache_size = 2 cache_size =4 0.84 | PIO â prefetch 1 experts ~ escent ae | PRS aa 0.2} ââ prefetch 2 experts ââ prefetch 3 experts 0.0 00 0 5 10 15 20 25 30 0 5 10 15 20 25 30 Layer # Layer # S Fd Ed Cache hit rate Bd ES Prediction recall = ES Ss &\nFigure 2: (left) LRU cache hit ratio for different cache size k; (right) speculative loading recall when pre-loading a different number of experts. Regular lines represent loading 1 layer ahead; dashed line stands for 2 layers ahead; dotted line is 10 layers ahead.\n# 4.1 Expert LRU Cache and Speculative Loading\nIn this section, we benchmark the effectiveness of the two expert offloading strategies: LRU caching and and speculative loading, as defined in Sections 3.1 and 3.2 respectively. For this evaluation, we measure âexpert recallâ â the fraction of times when an expert needed for inference was already available on GPU.",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "Figure 1: An example of expert loading pattern in Mixtral-8x7B-Instruct for select layers. Blue cells indicate that a certain expert was active when encoding a certain token; deeper blue indicates higher gating weight. Small gray squares show which experts are cached with an LRU cache for k=2.\n# 3.1 Expert Locality and LRU caching\nAs we discussed earlier in Section 2.1, Mixture-of-Experts language models were often observed to assign individual experts to distinct sub-tasks. However, this does not mean that the model uses the same expert over long stretches of tokens. Instead, some experts are active in short sequences of 2-4 tokens, while others are often used with âgapsâ, as shown in Figure 1.\nTo take advantage of this pattern, we can keep active experts in GPU memory as a âcacheâ for future tokens. If the same experts are activated again in future, they will be available instantaneously. Naturally, the number of experts that can be stored this way if very limited by the available GPU memory. For simplicity, we choose to always keep k least recently used experts as a type of LRU cache. If k is greater than the number of active experts, the cache will save experts from multiple previous tokens. For simplicity, we keep the same number of cached experts for each MoE layer.",
            "Expert Offloading. As described earlier, we use LRU cache with an equal number k of cached experts per layer. For Mixtral-8x7B, we use k=2 for 12GB GPUs and k=4 for 16GB ones. We trigger speculative expert loading immediately after the system finished loading all experts for the current layer. The speculative expert loading fetches 1 â 2 most likely experts. The newly loaded experts do not replace the currently cached experts. If a speculatively loaded expert was later used during next layer inference, it will replace the least recently used expert from the next layerâs cache.\nMany consumer devices and free-tier cloud instances have limited host RAM that cannot fit the entire model7. In these cases, the experts must be split between host and device memory. To support this, our implementation of expert LRU cache splits experts between host and GPU devices. When loading and expert to the GPU cache, the system also offloads the least recently used on-device expert back to RAM so as to preserve memory parity.",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction",
            "Google. Google colaboratory, 2023. URL https://colab.research.google.com/.\nHendrycks, D., Burns, C., Basart, S., Zou, A., Mazeika, M., Song, D., and Steinhardt, J. Measuring massive multitask language understanding. Proceedings of the International Conference on Learning Representations (ICLR), 2021.\nHsu, Y.-C., Hua, T., Chang, S., Lou, Q., Shen, Y., and Jin, H. Language model compression with weighted low-rank factorization. arXiv preprint arXiv:2207.00112, 2022.\nJacobs, R. A., Jordan, M. I., Nowlan, S. J., and Hinton, G. E. Adaptive mixtures of local experts. Neural Computation, 3(1):79â87, March 1991. ISSN 0899-7667. doi: 10.1162/neco.1991.3.1.79. URL https://doi.org/10.1162/neco.1991.3.1.79.\nJordan, M. I. and Jacobs, R. A. Hierarchical mixtures of experts and the em algorithm. Neural computation, 6(2):181â214, 1994.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2"
        ],
        "response": "LRU caching keeps the k least-recently used experts in GPU memory after each forward pass; when a later token re-activates one of those cached experts, the system can reuse the resident parameters instead of reloading them from host RAM, cutting expert load latency. Experiments on Mixtral-8x7B show that hit ratios of 0.6–0.8 are achieved with cache sizes of only 2–4 experts per layer, enough to yield a significant end-to-end inference speed-up even though the policy ignores activation frequency and layer-specific patterns [https://colab.research.google.com/].",
        "reference": "LRU caching improves the inference speed of Mixture-of-Experts language models by keeping active experts in GPU memory as a cache for future tokens. This allows for faster retrieval of experts when needed during inference."
    },
    {
        "user_input": "In terms of expert loading time, what impact does the use of LRU caching have on Mixture-of-Experts language models?",
        "retrieved_contexts": [
            "We illustrate an example of how LRU cache saves experts in Figure 1 (see caption). LRU is a very simple strategy that does not consider factors like expert activation frequencies, varying cache size between MoE layers, or any sequential patterns in expert activation. However, we found that even this simple strategy can significantly speed up inference for modern Mixture-of-Experts models such as Mixtral-8x7B (see Section 4 for detailed evaluation).\n# 3.2 Speculative Expert Loading\nWhile LRU caching can reduce the average expert loading time, most of the inference time is still spent waiting for the next expert to be loaded. The reason behind this is that, unlike with dense models, MoE offloading cannot effectively overlap expert loading with computation. To understand this problem, let us zoom into the process of generating a single token, layer-by-layer. The full compute workload starts by embedding the previous token via look-up, then alternates between running self-attention and MLP for each transformer block in the model. Finally, the outputs from the last transformer block are used to predict next token logits with a linear projection.",
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization",
            "Expert Offloading. As described earlier, we use LRU cache with an equal number k of cached experts per layer. For Mixtral-8x7B, we use k=2 for 12GB GPUs and k=4 for 16GB ones. We trigger speculative expert loading immediately after the system finished loading all experts for the current layer. The speculative expert loading fetches 1 â 2 most likely experts. The newly loaded experts do not replace the currently cached experts. If a speculatively loaded expert was later used during next layer inference, it will replace the least recently used expert from the next layerâs cache.\nMany consumer devices and free-tier cloud instances have limited host RAM that cannot fit the entire model7. In these cases, the experts must be split between host and device memory. To support this, our implementation of expert LRU cache splits experts between host and GPU devices. When loading and expert to the GPU cache, the system also offloads the least recently used on-device expert back to RAM so as to preserve memory parity.",
            "Figure 1: An example of expert loading pattern in Mixtral-8x7B-Instruct for select layers. Blue cells indicate that a certain expert was active when encoding a certain token; deeper blue indicates higher gating weight. Small gray squares show which experts are cached with an LRU cache for k=2.\n# 3.1 Expert Locality and LRU caching\nAs we discussed earlier in Section 2.1, Mixture-of-Experts language models were often observed to assign individual experts to distinct sub-tasks. However, this does not mean that the model uses the same expert over long stretches of tokens. Instead, some experts are active in short sequences of 2-4 tokens, while others are often used with âgapsâ, as shown in Figure 1.\nTo take advantage of this pattern, we can keep active experts in GPU memory as a âcacheâ for future tokens. If the same experts are activated again in future, they will be available instantaneously. Naturally, the number of experts that can be stored this way if very limited by the available GPU memory. For simplicity, we choose to always keep k least recently used experts as a type of LRU cache. If k is greater than the number of active experts, the cache will save experts from multiple previous tokens. For simplicity, we keep the same number of cached experts for each MoE layer.",
            "7Notably, Google Colab RAM cannot fit Mixtral-8x7B with a reasonable compression rate 8This corresponds to tensor.pin_memory() command in PyTorch.\n5\niy & cache_size =3 cache_size = 2 cache_size =4 0.84 | PIO â prefetch 1 experts ~ escent ae | PRS aa 0.2} ââ prefetch 2 experts ââ prefetch 3 experts 0.0 00 0 5 10 15 20 25 30 0 5 10 15 20 25 30 Layer # Layer # S Fd Ed Cache hit rate Bd ES Prediction recall = ES Ss &\nFigure 2: (left) LRU cache hit ratio for different cache size k; (right) speculative loading recall when pre-loading a different number of experts. Regular lines represent loading 1 layer ahead; dashed line stands for 2 layers ahead; dotted line is 10 layers ahead.\n# 4.1 Expert LRU Cache and Speculative Loading\nIn this section, we benchmark the effectiveness of the two expert offloading strategies: LRU caching and and speculative loading, as defined in Sections 3.1 and 3.2 respectively. For this evaluation, we measure âexpert recallâ â the fraction of times when an expert needed for inference was already available on GPU.",
            "For regular (dense) models, this architecture allows for efficient offloading schedule that pre-loads the next transformer layer ahead of time, while the previous layer is still running. Unfortunately, this schedule is no longer possible for Mixture-of-Experts models, where MoE MLP layers choose which experts to load just-in-time for computation. This is because the system cannot pre-fetch the next layer until it learns which experts should be loaded. Modern open-access MoE language models choose active experts using the final outputs of the previous layer, which means they cannot be pre-fetched them in parallel with previous layer. While it is not possible6 to pre-reliably prefetch the next set of experts ahead of time, the system could still try to guess the likely next experts and load them speculatively, while processing the previous layer. It the guess is correct, it will speed up the next layer inference; if not, it can load the actual next layerâs experts later. In other words, this type of speculative loading does not change the final model predictions, but may reduce latency if the guess is accurate enough.\n6More specifically, not possible without changing the model architecture, which would require re-training\n4",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction"
        ],
        "response": "LRU caching reduces average expert loading time by keeping the k least-recently-used experts in GPU memory; k is set to 2 for 12 GB GPUs and 4 for 16 GB GPUs when running Mixtral-8x7B. In experiments the cache reaches a hit ratio above 0.8, so most expert requests are served instantly instead of being fetched from RAM, significantly speeding up overall inference even though the simple LRU policy ignores expert frequencies or sequential patterns. [source: unknown]",
        "reference": "The use of LRU caching can significantly speed up inference for Mixture-of-Experts language models. However, even with LRU caching, most of the inference time is still spent waiting for the next expert to be loaded. This is because Mixture-of-Experts models do not allow for pre-loading the next layer ahead of time, as the experts to be loaded are determined just-in-time for computation."
    },
    {
        "user_input": "How does the sequential generation of tokens in interactive inference impact the speed of offloading in Mixture-of-Experts language models?",
        "retrieved_contexts": [
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "The generative inference workload consists of two phases: 1) encoding the input prompt and 2) generating tokens conditioned on that prompt. The key difference between these two phases is that prompt tokens are encoded in parallel (layer-by-layer), whereas the generation runs sequentially (token-by-token and layer-by-layer). In general, phase 1 works relatively well with existing Mixture- of-Experts algorithms, since each layer can only be loaded once for the entire prompt. In turn, when generating tokens, one must load layer once per each token generated. In practice, this means that inference speed is limited by how fast one can fetch parameters from system memory.\nBelow, we look for patterns in how the MoE model loads its experts and propose ways to exploit these patterns to speed up inference time.\n4To learn more about these methods, please refer to surveys such as Gholami et al. (2021); Liang et al. (2021) 5As opposed to running a processing a large batch of texts over many seconds, as in Sheng et al. (2023)\n3\nSelected experts for Mixtral-8x7B-Instruct woe 0 (top) and 15 ae =n a oa ao a âme: a n: ee Layer 15 expert # Layer 0 expert # MAUR STARR O However about |= and 4 training data owerful language model based trained Trans former f architecture",
            "# 4.3 Practical offloading performance\nFinally we evaluate the performance of the Mixtral8x7B-Instruct model using the offloading tech- niquesproposed throughout this report. Based on the perplexity evaluations from the previous section, we chose 4-bit HQQ quantization for the shared attention layers and 2- or 3-bit quantization for experts. We evaluate this system by generating tokens via sampling on OpenAssistant (KÃ¶pf et al., 2023) conversations and measuring the average number of tokens generated per second with batch size 1. For this evaluation, we always sample proportionally to the predicted probabilities, i.e. without temperature or nucleus sampling.",
            "This technique works particularly well when processing large batches of data, during train- ing Pudipeddi et al. (2020); Ren et al. (2021) or large-batch non-interactive inference Aminabadi et al. (2022); Sheng et al. (2023), where each layer processes a lot of tokens each time the layer is loaded from RAM. In turn, when doing interactive inference (e.g. as a chat assistants), offloading works significantly slower than on-device inference. This is because interactive inference generates tokens autoregressively, from left to right. This way, the inference system processes one or few tokens at a time, and therefore spends most of the time waiting for next layerâs parameters to be loaded.\n# 2.4 Hardware Setup",
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "For regular (dense) models, this architecture allows for efficient offloading schedule that pre-loads the next transformer layer ahead of time, while the previous layer is still running. Unfortunately, this schedule is no longer possible for Mixture-of-Experts models, where MoE MLP layers choose which experts to load just-in-time for computation. This is because the system cannot pre-fetch the next layer until it learns which experts should be loaded. Modern open-access MoE language models choose active experts using the final outputs of the previous layer, which means they cannot be pre-fetched them in parallel with previous layer. While it is not possible6 to pre-reliably prefetch the next set of experts ahead of time, the system could still try to guess the likely next experts and load them speculatively, while processing the previous layer. It the guess is correct, it will speed up the next layer inference; if not, it can load the actual next layerâs experts later. In other words, this type of speculative loading does not change the final model predictions, but may reduce latency if the guess is accurate enough.\n6More specifically, not possible without changing the model architecture, which would require re-training\n4",
            "# 2.4 Hardware Setup\nWhile our analysis is not specific to any hardware setup, we target the hardware specifications of cheap / free-tier cloud instances Google (2023) and the upper half of gaming computers Steam (2023): i) enough system memory to hold model parameters, ii) a GPU with 11-16GB VRAM and iii) host-to-device communication at 8-16GB/s (PCIe Gen.3). If we examine popular open-access MoE models (Mixtral-8x7B and switch-c-2048), we find that all non-experts can fit a fraction of available GPU memory. In turn, the experts that constitute vast majority of model parameters do not fit even with quantization. Finally, even if we could fit the model parameters in memory, running generative inference requires additional memory for layer activations and past attention keys & values.\n# 3 Method\nIn this work, we aim to systematically find the optimal way to inference modern Mixture-of-Experts LLMs on desktop or low-end cloud instances. More specifically, we focus on the task of generating tokens interactively, i.e. generate multiple tokens per second at batch size 15.",
            "[10] Jwala Dhamala, Tony Sun, Varun Kumar, Satyapriya Krishna, Yada Pruksachatkun, Kai-Wei Chang, and Rahul Gupta. Bold: Dataset and metrics for measuring biases in open-ended language generation. In Proceedings of the 2021 ACM conference on fairness, accountability, and transparency, pages 862â872, 2021.\n[11] Artyom Eliseev and Denis Mazur. Fast inference of mixture-of-experts language models with offloading. arXiv preprint arXiv:2312.17238, 2023.\n[12] William Fedus, Jeff Dean, and Barret Zoph. A review of sparse expert models in deep learning. arXiv preprint arXiv:2209.01667, 2022.\n[13] Trevor Gale, Deepak Narayanan, Cliff Young, and Matei Zaharia. Megablocks: Efficient sparse training with mixture-of-experts. arXiv preprint arXiv:2211.15841, 2022."
        ],
        "response": "Because interactive inference produces tokens one-by-one, every new token forces the system to reload the chosen experts for the MoE layer; unlike batched prompt encoding, there is no reuse across tokens, so PCIe copies dominate latency and interactive offloading becomes far slower than on-device generation, yielding only 2-3 tokens/s on desktop GPUs [source: unknown]",
        "reference": "The sequential generation of tokens in interactive inference impacts the speed of offloading in Mixture-of-Experts language models by slowing down the process. In interactive inference, tokens are generated autoregressively from left to right, processing one or a few tokens at a time. This means that the inference system spends most of the time waiting for the next layer's parameters to be loaded. Unlike regular (dense) models, where the next layer can be pre-loaded while the previous layer is still running, Mixture-of-Experts models cannot pre-fetch the next layer until it learns which experts should be loaded. Therefore, the speed of offloading is limited by how fast the parameters can be fetched from system memory."
    },
    {
        "user_input": "In comparison, how does on-device inference affect the speed of offloading in Mixture-of-Experts language models?",
        "retrieved_contexts": [
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "# 4.3 Practical offloading performance\nFinally we evaluate the performance of the Mixtral8x7B-Instruct model using the offloading tech- niquesproposed throughout this report. Based on the perplexity evaluations from the previous section, we chose 4-bit HQQ quantization for the shared attention layers and 2- or 3-bit quantization for experts. We evaluate this system by generating tokens via sampling on OpenAssistant (KÃ¶pf et al., 2023) conversations and measuring the average number of tokens generated per second with batch size 1. For this evaluation, we always sample proportionally to the predicted probabilities, i.e. without temperature or nucleus sampling.",
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction",
            "For regular (dense) models, this architecture allows for efficient offloading schedule that pre-loads the next transformer layer ahead of time, while the previous layer is still running. Unfortunately, this schedule is no longer possible for Mixture-of-Experts models, where MoE MLP layers choose which experts to load just-in-time for computation. This is because the system cannot pre-fetch the next layer until it learns which experts should be loaded. Modern open-access MoE language models choose active experts using the final outputs of the previous layer, which means they cannot be pre-fetched them in parallel with previous layer. While it is not possible6 to pre-reliably prefetch the next set of experts ahead of time, the system could still try to guess the likely next experts and load them speculatively, while processing the previous layer. It the guess is correct, it will speed up the next layer inference; if not, it can load the actual next layerâs experts later. In other words, this type of speculative loading does not change the final model predictions, but may reduce latency if the guess is accurate enough.\n6More specifically, not possible without changing the model architecture, which would require re-training\n4",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "This technique works particularly well when processing large batches of data, during train- ing Pudipeddi et al. (2020); Ren et al. (2021) or large-batch non-interactive inference Aminabadi et al. (2022); Sheng et al. (2023), where each layer processes a lot of tokens each time the layer is loaded from RAM. In turn, when doing interactive inference (e.g. as a chat assistants), offloading works significantly slower than on-device inference. This is because interactive inference generates tokens autoregressively, from left to right. This way, the inference system processes one or few tokens at a time, and therefore spends most of the time waiting for next layerâs parameters to be loaded.\n# 2.4 Hardware Setup",
            "Expert Offloading. As described earlier, we use LRU cache with an equal number k of cached experts per layer. For Mixtral-8x7B, we use k=2 for 12GB GPUs and k=4 for 16GB ones. We trigger speculative expert loading immediately after the system finished loading all experts for the current layer. The speculative expert loading fetches 1 â 2 most likely experts. The newly loaded experts do not replace the currently cached experts. If a speculatively loaded expert was later used during next layer inference, it will replace the least recently used expert from the next layerâs cache.\nMany consumer devices and free-tier cloud instances have limited host RAM that cannot fit the entire model7. In these cases, the experts must be split between host and device memory. To support this, our implementation of expert LRU cache splits experts between host and GPU devices. When loading and expert to the GPU cache, the system also offloads the least recently used on-device expert back to RAM so as to preserve memory parity.",
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization",
            "The generative inference workload consists of two phases: 1) encoding the input prompt and 2) generating tokens conditioned on that prompt. The key difference between these two phases is that prompt tokens are encoded in parallel (layer-by-layer), whereas the generation runs sequentially (token-by-token and layer-by-layer). In general, phase 1 works relatively well with existing Mixture- of-Experts algorithms, since each layer can only be loaded once for the entire prompt. In turn, when generating tokens, one must load layer once per each token generated. In practice, this means that inference speed is limited by how fast one can fetch parameters from system memory.\nBelow, we look for patterns in how the MoE model loads its experts and propose ways to exploit these patterns to speed up inference time.\n4To learn more about these methods, please refer to surveys such as Gholami et al. (2021); Liang et al. (2021) 5As opposed to running a processing a large batch of texts over many seconds, as in Sheng et al. (2023)\n3\nSelected experts for Mixtral-8x7B-Instruct woe 0 (top) and 15 ae =n a oa ao a âme: a n: ee Layer 15 expert # Layer 0 expert # MAUR STARR O However about |= and 4 training data owerful language model based trained Trans former f architecture"
        ],
        "response": "On-device inference greatly reduces the latency that offloading imposes in interactive MoE generation. With offloading, each autoregressive token forces a layer-by-layer parameter fetch from RAM, so the system ‘spends most of the time waiting for the next layer’s parameters to be loaded’. When experts are cached on-device, this delay is eliminated for hits in the LRU cache and is shortened for misses because data are copied through pre-pinned, contiguous buffers rather than individual parameter tensors. Consequently, the paper’s offloading schedule on a T4/3060 only reaches ~2–3 tokens/s, whereas the same hardware running with a larger on-device cache (k=4) approaches the speed of pure on-device inference for the cached fraction of experts. [source: unknown]",
        "reference": "On-device inference is faster than offloading in Mixture-of-Experts language models. This is because during interactive inference, where tokens are generated autoregressively from left to right, the inference system processes one or few tokens at a time. As a result, most of the time is spent waiting for the next layer's parameters to be loaded. While LRU caching can reduce the average expert loading time, the majority of the inference time is still spent waiting for the next expert to be loaded. Unlike dense models, MoE offloading cannot effectively overlap expert loading with computation, making on-device inference faster in comparison."
    },
    {
        "user_input": "What are the architectural differences in terms of feedforward blocks and active parameters used during inference between Mixtral 8x7B and Mistral 7B?",
        "retrieved_contexts": [
            "We also present Mixtral 8x7B â Instruct, a chat model fine-tuned to follow instructions using supervised fine-tuning and Direct Preference Optimization [25]. Its performance notably surpasses that of GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human evaluation benchmarks. Mixtral â Instruct also demonstrates reduced biases, and a more balanced sentiment profile in benchmarks such as BBQ, and BOLD. We release both Mixtral 8x7B and Mixtral 8x7B â Instruct under the Apache 2.0 license1, free for academic and commercial usage, ensuring broad accessibility and potential for diverse applications. To enable the community to run Mixtral with a fully open-source stack, we submitted changes to the vLLM project, which integrates Megablocks CUDA kernels for efficient inference. Skypilot also allows the deployment of vLLM endpoints on any instance in the cloud.\n# 2 Architectural details\nMixtral is based on a transformer architecture [31] and uses the same modifications as described in [18], with the notable exceptions that Mix- tral supports a fully dense context length of 32k tokens, and the feed- forward blocks are replaced by Mixture-of-Expert layers (Section 2.1). The model architecture parameters are summarized in Table 1. Parameter Value",
            "Table 2: Comparison of Mixtral with Llama. Mixtral outperforms or matches Llama 2 70B performance on almost all popular benchmarks while using 5x fewer active parameters during inference.\n70 Mixtral 8x7B. âMixtral 8x7B Mixtral 8x7B 355 =o = Es & E60! Mistral 78 % 2681 Mistral 78 3 3 s0 5 = A % 66 50 g 4 45 64 78 138 348708 78 138 348708 78 138 348 70B S66 Mixtral 8x7B 50 Mixtral 8x7B 5 = 564 340 g al Mistral 78 ee Mistral 78 3 5 Â§ 30 5 eo â= Mistral Â° 20 âe LlaMA2 78 (138 348 70B 7B (138 348 708 7B Â«13B 34B 708 Active Params Active Params Active Params\nFigure 3: Results on MMLU, commonsense reasoning, world knowledge and reading comprehension, math and code for Mistral (7B/8x7B) vs Llama 2 (7B/13B/70B). Mixtral largely outperforms Llama 2 70B on all benchmarks, except on reading comprehension benchmarks while using 5x lower active parameters. It is also vastly superior to Llama 2 70B on code and math.",
            "Abstract\nWe introduce Mixtral 8x7B, a Sparse Mixture of Experts (SMoE) language model. Mixtral has the same architecture as Mistral 7B, with the difference that each layer is composed of 8 feedforward blocks (i.e. experts). For every token, at each layer, a router network selects two experts to process the current state and combine their outputs. Even though each token only sees two experts, the selected experts can be different at each timestep. As a result, each token has access to 47B parameters, but only uses 13B active parameters during inference. Mixtral was trained with a context size of 32k tokens and it outperforms or matches Llama 2 70B and GPT-3.5 across all evaluated benchmarks. In particular, Mixtral vastly outperforms Llama 2 70B on mathematics, code generation, and multilingual benchmarks. We also provide a model fine- tuned to follow instructions, Mixtral 8x7B â Instruct, that surpasses GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human bench- marks. Both the base and instruct models are released under the Apache 2.0 license.\nCode: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/",
            "# 6 Conclusion\nIn this paper, we introduced Mixtral 8x7B, the first mixture-of-experts network to reach a state-of-the- art performance among open-source models. Mixtral 8x7B Instruct outperforms Claude-2.1, Gem- ini Pro, and GPT-3.5 Turbo on human evaluation benchmarks. Because it only uses two experts at each time step, Mixtral only uses 13B active parameters per token while outperforming the previous best model using 70B parameters per token (Llama 2 70B). We are making our trained and fine-tuned mod- els publicly available under the Apache 2.0 license. By sharing our models, we aim to facilitate the de- velopment of new techniques and applications that can benefit a wide range of industries and domains.",
            "Detailed results for Mixtral, Mistral 7B and Llama 2 7B/13B/70B and Llama 1 34B2 are reported in Table 2. Figure 2 compares the performance of Mixtral with the Llama models in different categories. Mixtral surpasses Llama 2 70B across most metrics. In particular, Mixtral displays a superior performance in code and mathematics benchmarks.\nSize and Efficiency. We compare our performance to the Llama 2 family, aiming to understand Mixtral modelsâ efficiency in the cost-performance spectrum (see Figure 3). As a sparse Mixture- of-Experts model, Mixtral only uses 13B active parameters for each token. With 5x lower active parameters, Mixtral is able to outperform Llama 2 70B across most categories.\nNote that this analysis focuses on the active parameter count (see Section 2.1), which is directly proportional to the inference compute cost, but does not consider the memory costs and hardware utilization. The memory costs for serving Mixtral are proportional to its sparse parameter count, 47B, which is still smaller than Llama 2 70B. As for device utilization, we note that the SMoEs layer introduces additional overhead due to the routing mechanism and due to the increased memory loads when running more than one expert per device. They are more suitable for batched workloads where one can reach a good degree of arithmetic intensity.",
            "# 3.1 Multilingual benchmarks\nCompared to Mistral 7B, we significantly upsample the proportion of multilingual data during pretraining. The extra capacity allows Mixtral to perform well on multilingual benchmarks while maintaining a high accuracy in English. In particular, Mixtral significantly outperforms Llama 2 70B in French, German, Spanish, and Italian, as shown in Table 4.\nActive Params French Arc-c HellaS MMLU German Arc-c HellaS MMLU Spanish Arc-c HellaS MMLU Italian Arc-c HellaS MMLU 33B 70B 13B 42.9% 65.4% 49.0% 39.3% 68.1% 49.9% 49.9% 72.5% 64.3% 49.4% 70.9% 65.1% 58.2% 77.4% 70.9% 54.3% 73.0% 71.5% 55.4% 77.6% 72.5% 52.8% 75.1% 70.9% 41.1% 63.3% 48.7% 47.3% 68.7% 64.2% 45.7% 69.8% 52.3% 50.5% 74.5% 66.0%",
            "Comparison with Llama 2 70B and GPT-3.5. In Table 3, we report the performance of Mixtral 8x7B compared to Llama 2 70B and GPT-3.5. We observe that Mixtral performs similarly or above the two other models. On MMLU, Mixtral obtains a better performance, despite its significantly smaller capacity (47B tokens compared to 70B). For MT Bench, we report the performance of the latest GPT-3.5-Turbo model available, gpt-3.5-turbo-1106.\n2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4",
            "Table 1: Perplexity and model size evaluation of Mixtral-8x7B with different quantization for shared attention (Attn quant) and experts (Experts quant) layers. For comprarison, a Mistral-7B 4-bit quantized model has Wiki2 perplexity 5.03, C4 perplexity 7.56 and MMLU score 61.3%. See Section 4.2 for details. Green values correspond to the configurations we chose for full system evaluation.\n6\nAlgorithm 2-bit Experts 3-bit Experts A100 3080 Mobile 3060 T4 (Colab) A100 3080 Mobile 3060 T4 (Cloud) 3.061 Full algorithm 2.918 W/o expert pre-loading 2.265 W/o LRU cache & pre-loading Naive offloading (accelerate) 1.392 2.655 2.227 1.758 1.059 2.278 2.051 1.547 0.919 2.092 1.567 1.168 0.661 2.845 2.683 2.055 1.246 2.475 2.024 1.595 0.914 2.038 1.857 1.346 1.791 1.603 1.365 1.061 0.580",
            "n-1 y= Ss Softmax(Top2(a - W,)); - SwiGLU;(a). i=0\nThis formulation is similar to the GShard architecture [21], with the exceptions that we replace all FFN sub-blocks by MoE layers while GShard replaces every other block, and that GShard uses a more elaborate gating strategy for the second expert assigned to each token.\n# 3 Results\nWe compare Mixtral to Llama, and re-run all benchmarks with our own evaluation pipeline for fair comparison. We measure performance on a wide variety of tasks categorized as follow:\nâ¢ Commonsense Reasoning (0-shot): Hellaswag [32], Winogrande [26], PIQA [3], SIQA [27], OpenbookQA [22], ARC-Easy, ARC-Challenge [8], CommonsenseQA [30]",
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization"
        ],
        "response": "In Mistral 7B every transformer layer contains a single dense feed-forward block, whereas Mixtral 8x7B replaces each of those blocks with a Mixture-of-Experts (MoE) layer that contains 8 parallel feed-forward experts. During inference the MoE router selects exactly two experts per token and combines their outputs, so while the full model holds 47 B parameters only 13 B are active for any given token, roughly matching the compute cost of a dense 13 B model. Consequently Mixtral achieves the performance of a 70 B-class model while using about 5× fewer active parameters than Llama 2 70B.",
        "reference": "The architectural difference between Mixtral 8x7B and Mistral 7B lies in the number of feedforward blocks (experts) in each layer. Mixtral 8x7B has 8 feedforward blocks per layer, while Mistral 7B has a different number of feedforward blocks. Additionally, during inference, each token in both models has access to 47B parameters, but only 13B active parameters are used."
    },
    {
        "user_input": "How does Mixtral's performance in code and math benchmarks compare to Llama 2 70B?",
        "retrieved_contexts": [
            "Table 2: Comparison of Mixtral with Llama. Mixtral outperforms or matches Llama 2 70B performance on almost all popular benchmarks while using 5x fewer active parameters during inference.\n70 Mixtral 8x7B. âMixtral 8x7B Mixtral 8x7B 355 =o = Es & E60! Mistral 78 % 2681 Mistral 78 3 3 s0 5 = A % 66 50 g 4 45 64 78 138 348708 78 138 348708 78 138 348 70B S66 Mixtral 8x7B 50 Mixtral 8x7B 5 = 564 340 g al Mistral 78 ee Mistral 78 3 5 Â§ 30 5 eo â= Mistral Â° 20 âe LlaMA2 78 (138 348 70B 7B (138 348 708 7B Â«13B 34B 708 Active Params Active Params Active Params\nFigure 3: Results on MMLU, commonsense reasoning, world knowledge and reading comprehension, math and code for Mistral (7B/8x7B) vs Llama 2 (7B/13B/70B). Mixtral largely outperforms Llama 2 70B on all benchmarks, except on reading comprehension benchmarks while using 5x lower active parameters. It is also vastly superior to Llama 2 70B on code and math.",
            "Detailed results for Mixtral, Mistral 7B and Llama 2 7B/13B/70B and Llama 1 34B2 are reported in Table 2. Figure 2 compares the performance of Mixtral with the Llama models in different categories. Mixtral surpasses Llama 2 70B across most metrics. In particular, Mixtral displays a superior performance in code and mathematics benchmarks.\nSize and Efficiency. We compare our performance to the Llama 2 family, aiming to understand Mixtral modelsâ efficiency in the cost-performance spectrum (see Figure 3). As a sparse Mixture- of-Experts model, Mixtral only uses 13B active parameters for each token. With 5x lower active parameters, Mixtral is able to outperform Llama 2 70B across most categories.\nNote that this analysis focuses on the active parameter count (see Section 2.1), which is directly proportional to the inference compute cost, but does not consider the memory costs and hardware utilization. The memory costs for serving Mixtral are proportional to its sparse parameter count, 47B, which is still smaller than Llama 2 70B. As for device utilization, we note that the SMoEs layer introduces additional overhead due to the routing mechanism and due to the increased memory loads when running more than one expert per device. They are more suitable for batched workloads where one can reach a good degree of arithmetic intensity.",
            "Comparison with Llama 2 70B and GPT-3.5. In Table 3, we report the performance of Mixtral 8x7B compared to Llama 2 70B and GPT-3.5. We observe that Mixtral performs similarly or above the two other models. On MMLU, Mixtral obtains a better performance, despite its significantly smaller capacity (47B tokens compared to 70B). For MT Bench, we report the performance of the latest GPT-3.5-Turbo model available, gpt-3.5-turbo-1106.\n2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4",
            "2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4\nLLaMA 2 70B GPT-3.5 MMLU (MCQ in 57 subjects) 69.9% 70.0% 70.6% HellaSwag (10-shot) 87.1% 85.5% 86.7% ARC Challenge (25-shot) 85.1% 85.2% 85.8% WinoGrande (5-shot) 83.2% 81.6% 81.2% MBPP (pass@1) 49.8% 52.2% 60.7% GSM-8K (5-shot) 53.6% 57.1% 58.4% MT Bench (for Instruct Models) 6.86 8.32 8.30\n# Mixtral 8x7B\nTable 3: Comparison of Mixtral with Llama 2 70B and GPT-3.5. Mixtral outperforms or matches Llama 2 70B and GPT-3.5 performance on most metrics.\nEvaluation Differences. On some benchmarks, there are some differences between our evaluation protocol and the one reported in the Llama 2 paper: 1) on MBPP, we use the hand-verified subset 2) on TriviaQA, we do not provide Wikipedia contexts.\n# 3.1 Multilingual benchmarks",
            "Llama 2 70B Mixtral 8x7B BBQ accuracy 51.5% 56.0% BOLD sentiment score (avg Â± std) gender profession religious_ideology political_ideology race 0.293 Â± 0.073 0.218 Â± 0.073 0.188 Â± 0.133 0.149 Â± 0.140 0.232 Â± 0.049 0.323 Â±0.045 0.243 Â± 0.087 0.144 Â± 0.089 0.186 Â± 0.146 0.232 Â± 0.052\nFigure 5: Bias Benchmarks. Compared Llama 2 70B, Mixtral presents less bias (higher accuracy on BBQ, lower std on BOLD) and displays more positive sentiment (higher avg on BOLD).\nWe benchmark Llama 2 and Mixtral on BBQ and BOLD with our evaluation framework and report the results in Table 5. Compared to Llama 2, Mixtral presents less bias on the BBQ benchmark (56.0% vs 51.5%). For each group in BOLD, a higher average sentiment score means more positive sentiments and a lower standard deviation indicates less bias within the group. Overall, Mixtral displays more positive sentiments than Llama 2, with similar variances within each group.\n# Instruction Fine-tuning",
            "# 3.1 Multilingual benchmarks\nCompared to Mistral 7B, we significantly upsample the proportion of multilingual data during pretraining. The extra capacity allows Mixtral to perform well on multilingual benchmarks while maintaining a high accuracy in English. In particular, Mixtral significantly outperforms Llama 2 70B in French, German, Spanish, and Italian, as shown in Table 4.\nActive Params French Arc-c HellaS MMLU German Arc-c HellaS MMLU Spanish Arc-c HellaS MMLU Italian Arc-c HellaS MMLU 33B 70B 13B 42.9% 65.4% 49.0% 39.3% 68.1% 49.9% 49.9% 72.5% 64.3% 49.4% 70.9% 65.1% 58.2% 77.4% 70.9% 54.3% 73.0% 71.5% 55.4% 77.6% 72.5% 52.8% 75.1% 70.9% 41.1% 63.3% 48.7% 47.3% 68.7% 64.2% 45.7% 69.8% 52.3% 50.5% 74.5% 66.0%",
            "Table 4: Comparison of Mixtral with Llama on Multilingual Benchmarks. On ARC Challenge, Hellaswag, and MMLU, Mixtral outperforms Llama 2 70B on 4 languages: French, German, Spanish, and Italian.\n# 3.2 Long range performance\nTo assess the capabilities of Mixtral to tackle long context, we evaluate it on the passkey retrieval task introduced in [23], a synthetic task designed to measure the ability of the model to retrieve a passkey inserted randomly in a long prompt. Results in Figure 4 (Left) show that Mixtral achieves a 100% retrieval accuracy regardless of the context length or the position of passkey in the sequence. Figure 4 (Right) shows that the perplexity of Mixtral on a subset of the proof-pile dataset [2] decreases monotonically as the size of the context increases.\nPasskey Performance ry 0.8 0.6 04 0.2 0.0 OK 4K 8K 12K 16K 20K 24K 28K Seq Len Passkey Loc\n3.8 â Mixtral_8x7B 3.5 32 > $3.0 i] 228 fos a 2.0 0 5k 10k 15k 20k 25k 30k Context length",
            "n-1 y= Ss Softmax(Top2(a - W,)); - SwiGLU;(a). i=0\nThis formulation is similar to the GShard architecture [21], with the exceptions that we replace all FFN sub-blocks by MoE layers while GShard replaces every other block, and that GShard uses a more elaborate gating strategy for the second expert assigned to each token.\n# 3 Results\nWe compare Mixtral to Llama, and re-run all benchmarks with our own evaluation pipeline for fair comparison. We measure performance on a wide variety of tasks categorized as follow:\nâ¢ Commonsense Reasoning (0-shot): Hellaswag [32], Winogrande [26], PIQA [3], SIQA [27], OpenbookQA [22], ARC-Easy, ARC-Challenge [8], CommonsenseQA [30]",
            "Abstract\nWe introduce Mixtral 8x7B, a Sparse Mixture of Experts (SMoE) language model. Mixtral has the same architecture as Mistral 7B, with the difference that each layer is composed of 8 feedforward blocks (i.e. experts). For every token, at each layer, a router network selects two experts to process the current state and combine their outputs. Even though each token only sees two experts, the selected experts can be different at each timestep. As a result, each token has access to 47B parameters, but only uses 13B active parameters during inference. Mixtral was trained with a context size of 32k tokens and it outperforms or matches Llama 2 70B and GPT-3.5 across all evaluated benchmarks. In particular, Mixtral vastly outperforms Llama 2 70B on mathematics, code generation, and multilingual benchmarks. We also provide a model fine- tuned to follow instructions, Mixtral 8x7B â Instruct, that surpasses GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human bench- marks. Both the base and instruct models are released under the Apache 2.0 license.\nCode: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/",
            "# 6 Conclusion\nIn this paper, we introduced Mixtral 8x7B, the first mixture-of-experts network to reach a state-of-the- art performance among open-source models. Mixtral 8x7B Instruct outperforms Claude-2.1, Gem- ini Pro, and GPT-3.5 Turbo on human evaluation benchmarks. Because it only uses two experts at each time step, Mixtral only uses 13B active parameters per token while outperforming the previous best model using 70B parameters per token (Llama 2 70B). We are making our trained and fine-tuned mod- els publicly available under the Apache 2.0 license. By sharing our models, we aim to facilitate the de- velopment of new techniques and applications that can benefit a wide range of industries and domains."
        ],
        "response": "Mixtral 8x7B is vastly superior to Llama 2 70B on both code and mathematics benchmarks; for example, it achieves 60.7% on MBPP (pass@1) versus Llama 2 70B’s 49.8%, and 58.4% on GSM-8K (5-shot) versus Llama 2 70B’s 53.6%, while using only 13B active parameters—about 5× fewer than Llama 2 70B’s 70B active parameters—making it significantly more inference-efficient. [source: unknown]",
        "reference": "Mixtral's performance in code and math benchmarks is superior to Llama 2 70B."
    },
    {
        "user_input": "Which model outperforms Llama 2 70B on multilingual benchmarks?",
        "retrieved_contexts": [
            "2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4\nLLaMA 2 70B GPT-3.5 MMLU (MCQ in 57 subjects) 69.9% 70.0% 70.6% HellaSwag (10-shot) 87.1% 85.5% 86.7% ARC Challenge (25-shot) 85.1% 85.2% 85.8% WinoGrande (5-shot) 83.2% 81.6% 81.2% MBPP (pass@1) 49.8% 52.2% 60.7% GSM-8K (5-shot) 53.6% 57.1% 58.4% MT Bench (for Instruct Models) 6.86 8.32 8.30\n# Mixtral 8x7B\nTable 3: Comparison of Mixtral with Llama 2 70B and GPT-3.5. Mixtral outperforms or matches Llama 2 70B and GPT-3.5 performance on most metrics.\nEvaluation Differences. On some benchmarks, there are some differences between our evaluation protocol and the one reported in the Llama 2 paper: 1) on MBPP, we use the hand-verified subset 2) on TriviaQA, we do not provide Wikipedia contexts.\n# 3.1 Multilingual benchmarks",
            "Table 4: Comparison of Mixtral with Llama on Multilingual Benchmarks. On ARC Challenge, Hellaswag, and MMLU, Mixtral outperforms Llama 2 70B on 4 languages: French, German, Spanish, and Italian.\n# 3.2 Long range performance\nTo assess the capabilities of Mixtral to tackle long context, we evaluate it on the passkey retrieval task introduced in [23], a synthetic task designed to measure the ability of the model to retrieve a passkey inserted randomly in a long prompt. Results in Figure 4 (Left) show that Mixtral achieves a 100% retrieval accuracy regardless of the context length or the position of passkey in the sequence. Figure 4 (Right) shows that the perplexity of Mixtral on a subset of the proof-pile dataset [2] decreases monotonically as the size of the context increases.\nPasskey Performance ry 0.8 0.6 04 0.2 0.0 OK 4K 8K 12K 16K 20K 24K 28K Seq Len Passkey Loc\n3.8 â Mixtral_8x7B 3.5 32 > $3.0 i] 228 fos a 2.0 0 5k 10k 15k 20k 25k 30k Context length",
            "Abstract\nWe introduce Mixtral 8x7B, a Sparse Mixture of Experts (SMoE) language model. Mixtral has the same architecture as Mistral 7B, with the difference that each layer is composed of 8 feedforward blocks (i.e. experts). For every token, at each layer, a router network selects two experts to process the current state and combine their outputs. Even though each token only sees two experts, the selected experts can be different at each timestep. As a result, each token has access to 47B parameters, but only uses 13B active parameters during inference. Mixtral was trained with a context size of 32k tokens and it outperforms or matches Llama 2 70B and GPT-3.5 across all evaluated benchmarks. In particular, Mixtral vastly outperforms Llama 2 70B on mathematics, code generation, and multilingual benchmarks. We also provide a model fine- tuned to follow instructions, Mixtral 8x7B â Instruct, that surpasses GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human bench- marks. Both the base and instruct models are released under the Apache 2.0 license.\nCode: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/",
            "Comparison with Llama 2 70B and GPT-3.5. In Table 3, we report the performance of Mixtral 8x7B compared to Llama 2 70B and GPT-3.5. We observe that Mixtral performs similarly or above the two other models. On MMLU, Mixtral obtains a better performance, despite its significantly smaller capacity (47B tokens compared to 70B). For MT Bench, we report the performance of the latest GPT-3.5-Turbo model available, gpt-3.5-turbo-1106.\n2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4",
            "# 3.1 Multilingual benchmarks\nCompared to Mistral 7B, we significantly upsample the proportion of multilingual data during pretraining. The extra capacity allows Mixtral to perform well on multilingual benchmarks while maintaining a high accuracy in English. In particular, Mixtral significantly outperforms Llama 2 70B in French, German, Spanish, and Italian, as shown in Table 4.\nActive Params French Arc-c HellaS MMLU German Arc-c HellaS MMLU Spanish Arc-c HellaS MMLU Italian Arc-c HellaS MMLU 33B 70B 13B 42.9% 65.4% 49.0% 39.3% 68.1% 49.9% 49.9% 72.5% 64.3% 49.4% 70.9% 65.1% 58.2% 77.4% 70.9% 54.3% 73.0% 71.5% 55.4% 77.6% 72.5% 52.8% 75.1% 70.9% 41.1% 63.3% 48.7% 47.3% 68.7% 64.2% 45.7% 69.8% 52.3% 50.5% 74.5% 66.0%",
            "Table 2: Comparison of Mixtral with Llama. Mixtral outperforms or matches Llama 2 70B performance on almost all popular benchmarks while using 5x fewer active parameters during inference.\n70 Mixtral 8x7B. âMixtral 8x7B Mixtral 8x7B 355 =o = Es & E60! Mistral 78 % 2681 Mistral 78 3 3 s0 5 = A % 66 50 g 4 45 64 78 138 348708 78 138 348708 78 138 348 70B S66 Mixtral 8x7B 50 Mixtral 8x7B 5 = 564 340 g al Mistral 78 ee Mistral 78 3 5 Â§ 30 5 eo â= Mistral Â° 20 âe LlaMA2 78 (138 348 70B 7B (138 348 708 7B Â«13B 34B 708 Active Params Active Params Active Params\nFigure 3: Results on MMLU, commonsense reasoning, world knowledge and reading comprehension, math and code for Mistral (7B/8x7B) vs Llama 2 (7B/13B/70B). Mixtral largely outperforms Llama 2 70B on all benchmarks, except on reading comprehension benchmarks while using 5x lower active parameters. It is also vastly superior to Llama 2 70B on code and math.",
            "Llama 2 70B Mixtral 8x7B BBQ accuracy 51.5% 56.0% BOLD sentiment score (avg Â± std) gender profession religious_ideology political_ideology race 0.293 Â± 0.073 0.218 Â± 0.073 0.188 Â± 0.133 0.149 Â± 0.140 0.232 Â± 0.049 0.323 Â±0.045 0.243 Â± 0.087 0.144 Â± 0.089 0.186 Â± 0.146 0.232 Â± 0.052\nFigure 5: Bias Benchmarks. Compared Llama 2 70B, Mixtral presents less bias (higher accuracy on BBQ, lower std on BOLD) and displays more positive sentiment (higher avg on BOLD).\nWe benchmark Llama 2 and Mixtral on BBQ and BOLD with our evaluation framework and report the results in Table 5. Compared to Llama 2, Mixtral presents less bias on the BBQ benchmark (56.0% vs 51.5%). For each group in BOLD, a higher average sentiment score means more positive sentiments and a lower standard deviation indicates less bias within the group. Overall, Mixtral displays more positive sentiments than Llama 2, with similar variances within each group.\n# Instruction Fine-tuning",
            "Code: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/\n# Introduction\nIn this paper, we present Mixtral 8x7B, a sparse mixture of experts model (SMoE) with open weights, licensed under Apache 2.0. Mixtral outperforms Llama 2 70B and GPT-3.5 on most benchmarks. As it only uses a subset of its parameters for every token, Mixtral allows faster inference speed at low batch-sizes, and higher throughput at large batch-sizes.\nMixtral is a sparse mixture-of-experts network. It is a decoder-only model where the feedforward block picks from a set of 8 distinct groups of parameters. At every layer, for every token, a router network chooses two of these groups (the âexpertsâ) to process the token and combine their output additively. This technique increases the number of parameters of a model while controlling cost and latency, as the model only uses a fraction of the total set of parameters per token.\nMixtral is pretrained with multilingual data using a context size of 32k tokens. It either matches or exceeds the performance of Llama 2 70B and GPT-3.5, over several benchmarks. In particular,\nMixture of Experts Layer i gating inputs af outputs router expert",
            "Detailed results for Mixtral, Mistral 7B and Llama 2 7B/13B/70B and Llama 1 34B2 are reported in Table 2. Figure 2 compares the performance of Mixtral with the Llama models in different categories. Mixtral surpasses Llama 2 70B across most metrics. In particular, Mixtral displays a superior performance in code and mathematics benchmarks.\nSize and Efficiency. We compare our performance to the Llama 2 family, aiming to understand Mixtral modelsâ efficiency in the cost-performance spectrum (see Figure 3). As a sparse Mixture- of-Experts model, Mixtral only uses 13B active parameters for each token. With 5x lower active parameters, Mixtral is able to outperform Llama 2 70B across most categories.\nNote that this analysis focuses on the active parameter count (see Section 2.1), which is directly proportional to the inference compute cost, but does not consider the memory costs and hardware utilization. The memory costs for serving Mixtral are proportional to its sparse parameter count, 47B, which is still smaller than Llama 2 70B. As for device utilization, we note that the SMoEs layer introduces additional overhead due to the routing mechanism and due to the increased memory loads when running more than one expert per device. They are more suitable for batched workloads where one can reach a good degree of arithmetic intensity.",
            "language model series characterized by distinct models with varying parameter counts [14], and the Qwen-14B open-source chat model is utilized in the current study. Aquila2 represents a language model series devised by BAAI, noted for surpassing comparable models in terms is of performance [22], and the Aquila2-34B chat model employed in this research. LLaMA2 constitutes a suite of pre-trained and fine-tuned LLMs, with scales ranging from 7 billion to 70 billion parameters [17]. Following additional training, LLaMA2-70B is incorporated into Xinyu2-70B."
        ],
        "response": "Mixtral 8x7B outperforms Llama 2 70B on multilingual benchmarks; it achieves higher scores in French, German, Spanish, and Italian on ARC Challenge, HellaSwag, and MMLU.[source: unknown]",
        "reference": "Mixtral outperforms Llama 2 70B on multilingual benchmarks."
    },
    {
        "user_input": "How does the use of sparse Mixture-of-Experts (MoE) in language models contribute to faster token generation?",
        "retrieved_contexts": [
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "Shazeer et al. (2017) builds on this idea to train a sparsely gated Mixture-of-Experts to serve as a language model. The full model consists of a recurrent neural network backbone and a MoE module with up to 131072 experts. When processing a given token, a linear gating function select 4 most suitable experts based on the latest hidden state. The resulting model (including the gating function and experts) is trained end-to-end to minimize cross-entropy, with an additional regularizer to promote equal expert utilization. Shazeer et al. (2017) observed that the MoE model not only improves perplexity, but also learns interpretable expert specializations: some experts would âspecializeâ on prepositions, while others learn to express a particular concept (e.g. speed).",
            "[10] Jwala Dhamala, Tony Sun, Varun Kumar, Satyapriya Krishna, Yada Pruksachatkun, Kai-Wei Chang, and Rahul Gupta. Bold: Dataset and metrics for measuring biases in open-ended language generation. In Proceedings of the 2021 ACM conference on fairness, accountability, and transparency, pages 862â872, 2021.\n[11] Artyom Eliseev and Denis Mazur. Fast inference of mixture-of-experts language models with offloading. arXiv preprint arXiv:2312.17238, 2023.\n[12] William Fedus, Jeff Dean, and Barret Zoph. A review of sparse expert models in deep learning. arXiv preprint arXiv:2209.01667, 2022.\n[13] Trevor Gale, Deepak Narayanan, Cliff Young, and Matei Zaharia. Megablocks: Efficient sparse training with mixture-of-experts. arXiv preprint arXiv:2211.15841, 2022.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "Since then, several lines of work explore Mixture-of-Experts with Transformer-based language models for machine translation Lepikhin et al. (2020), masked language modeling Fedus et al. (2021), general-purpose LLMs Du et al. (2022) and others. Most of these models follow traditional (dense) Transformer architecture for embeddings and attention layers, and only use Mixture for the feedforward (MLP) blocks and use a linear token-level gating function. A common observation across most of these works is that MoE models are cheaper to train and inference Fedus et al. (2021); Lepikhin et al. (2020), but require more parameters than a dense model with equivalent perplexity. Pre-trained Mixture-of-Experts LLMs have been openly available for over a year3. However, these models seem to have gained less traction than equivalent dense models, arguable because their sheer model size (over a trillion parameters) makes them difficult to use. Most recently, Mistral AI released a family of sparse Mixture of Experts models called Mixtral-8x7B with near state-of-the-art performance Mixtral AI team (2023). This model has already inspired several follow-up works and practical applications, but it still requires a high-end GPU accelerator.\n# 2.2 Post-training Quantization of LLMs",
            "Several recent works modify transformer architecture by introducing sparse Mixture-of-Experts blocks (Jacobs et al., 1991; Shazeer et al., 2017). MoE blocks contain multiple âexpertsâ (layers), as well as a âgating functionâ that selects which experts are used on a given input. As a result, the MoE block uses a small portion of all âexpertsâ for any single forward pass, allowing for more compute-efficient training Fedus et al. (2021); Du et al. (2022). Notably, MoEs are among the largest Fedus et al. (2021) and among the best Mixtral AI team (2023) of available LLMs. While Mixture-of-Experts models can be more efficient than their dense counterparts, many techniques for efficient LLM inference were not designed with MoE in mind and perform suboptimally on modern large language models that use mixture-of-experts layers.\n1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.",
            "The generative inference workload consists of two phases: 1) encoding the input prompt and 2) generating tokens conditioned on that prompt. The key difference between these two phases is that prompt tokens are encoded in parallel (layer-by-layer), whereas the generation runs sequentially (token-by-token and layer-by-layer). In general, phase 1 works relatively well with existing Mixture- of-Experts algorithms, since each layer can only be loaded once for the entire prompt. In turn, when generating tokens, one must load layer once per each token generated. In practice, this means that inference speed is limited by how fast one can fetch parameters from system memory.\nBelow, we look for patterns in how the MoE model loads its experts and propose ways to exploit these patterns to speed up inference time.\n4To learn more about these methods, please refer to surveys such as Gholami et al. (2021); Liang et al. (2021) 5As opposed to running a processing a large batch of texts over many seconds, as in Sheng et al. (2023)\n3\nSelected experts for Mixtral-8x7B-Instruct woe 0 (top) and 15 ae =n a oa ao a âme: a n: ee Layer 15 expert # Layer 0 expert # MAUR STARR O However about |= and 4 training data owerful language model based trained Trans former f architecture",
            "# 2.4 Hardware Setup\nWhile our analysis is not specific to any hardware setup, we target the hardware specifications of cheap / free-tier cloud instances Google (2023) and the upper half of gaming computers Steam (2023): i) enough system memory to hold model parameters, ii) a GPU with 11-16GB VRAM and iii) host-to-device communication at 8-16GB/s (PCIe Gen.3). If we examine popular open-access MoE models (Mixtral-8x7B and switch-c-2048), we find that all non-experts can fit a fraction of available GPU memory. In turn, the experts that constitute vast majority of model parameters do not fit even with quantization. Finally, even if we could fit the model parameters in memory, running generative inference requires additional memory for layer activations and past attention keys & values.\n# 3 Method\nIn this work, we aim to systematically find the optimal way to inference modern Mixture-of-Experts LLMs on desktop or low-end cloud instances. More specifically, we focus on the task of generating tokens interactively, i.e. generate multiple tokens per second at batch size 15.",
            "Google. Google colaboratory, 2023. URL https://colab.research.google.com/.\nHendrycks, D., Burns, C., Basart, S., Zou, A., Mazeika, M., Song, D., and Steinhardt, J. Measuring massive multitask language understanding. Proceedings of the International Conference on Learning Representations (ICLR), 2021.\nHsu, Y.-C., Hua, T., Chang, S., Lou, Q., Shen, Y., and Jin, H. Language model compression with weighted low-rank factorization. arXiv preprint arXiv:2207.00112, 2022.\nJacobs, R. A., Jordan, M. I., Nowlan, S. J., and Hinton, G. E. Adaptive mixtures of local experts. Neural Computation, 3(1):79â87, March 1991. ISSN 0899-7667. doi: 10.1162/neco.1991.3.1.79. URL https://doi.org/10.1162/neco.1991.3.1.79.\nJordan, M. I. and Jacobs, R. A. Hierarchical mixtures of experts and the em algorithm. Neural computation, 6(2):181â214, 1994."
        ],
        "response": "Sparse MoE makes token generation faster because only the gating-selected subset of experts is activated per forward pass, cutting per-token compute compared with a dense model that always uses every parameter [arXiv:2312.17238]. In addition, empirical analysis shows that i) experts are frequently reused across adjacent tokens, and ii) hidden states in early layers already anticipate which experts later layers will need, so a LRU cache plus speculative pre-loading can overlap parameter transfers with computation, yielding interactive throughput of 2-3 tokens/s on 11-16GB GPUs [arXiv:2312.17238].",
        "reference": "The use of sparse Mixture-of-Experts (MoE) in language models contributes to faster token generation because only a fraction of model layers are active for any given input. This means that MoE-based language models can generate tokens faster than their \"dense\" counterparts. The MoE blocks in the model contain multiple \"experts\" (layers) and a \"gating function\" that selects which experts are used for a given input. By using a small portion of all \"experts\" for each forward pass, the MoE block allows for more compute-efficient training, leading to faster token generation."
    },
    {
        "user_input": "What impact does the use of sparse Mixture-of-Experts (MoE) have on the size of language models?",
        "retrieved_contexts": [
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction",
            "Several recent works modify transformer architecture by introducing sparse Mixture-of-Experts blocks (Jacobs et al., 1991; Shazeer et al., 2017). MoE blocks contain multiple âexpertsâ (layers), as well as a âgating functionâ that selects which experts are used on a given input. As a result, the MoE block uses a small portion of all âexpertsâ for any single forward pass, allowing for more compute-efficient training Fedus et al. (2021); Du et al. (2022). Notably, MoEs are among the largest Fedus et al. (2021) and among the best Mixtral AI team (2023) of available LLMs. While Mixture-of-Experts models can be more efficient than their dense counterparts, many techniques for efficient LLM inference were not designed with MoE in mind and perform suboptimally on modern large language models that use mixture-of-experts layers.\n1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.",
            "Shazeer et al. (2017) builds on this idea to train a sparsely gated Mixture-of-Experts to serve as a language model. The full model consists of a recurrent neural network backbone and a MoE module with up to 131072 experts. When processing a given token, a linear gating function select 4 most suitable experts based on the latest hidden state. The resulting model (including the gating function and experts) is trained end-to-end to minimize cross-entropy, with an additional regularizer to promote equal expert utilization. Shazeer et al. (2017) observed that the MoE model not only improves perplexity, but also learns interpretable expert specializations: some experts would âspecializeâ on prepositions, while others learn to express a particular concept (e.g. speed).",
            "[10] Jwala Dhamala, Tony Sun, Varun Kumar, Satyapriya Krishna, Yada Pruksachatkun, Kai-Wei Chang, and Rahul Gupta. Bold: Dataset and metrics for measuring biases in open-ended language generation. In Proceedings of the 2021 ACM conference on fairness, accountability, and transparency, pages 862â872, 2021.\n[11] Artyom Eliseev and Denis Mazur. Fast inference of mixture-of-experts language models with offloading. arXiv preprint arXiv:2312.17238, 2023.\n[12] William Fedus, Jeff Dean, and Barret Zoph. A review of sparse expert models in deep learning. arXiv preprint arXiv:2209.01667, 2022.\n[13] Trevor Gale, Deepak Narayanan, Cliff Young, and Matei Zaharia. Megablocks: Efficient sparse training with mixture-of-experts. arXiv preprint arXiv:2211.15841, 2022.",
            "Since then, several lines of work explore Mixture-of-Experts with Transformer-based language models for machine translation Lepikhin et al. (2020), masked language modeling Fedus et al. (2021), general-purpose LLMs Du et al. (2022) and others. Most of these models follow traditional (dense) Transformer architecture for embeddings and attention layers, and only use Mixture for the feedforward (MLP) blocks and use a linear token-level gating function. A common observation across most of these works is that MoE models are cheaper to train and inference Fedus et al. (2021); Lepikhin et al. (2020), but require more parameters than a dense model with equivalent perplexity. Pre-trained Mixture-of-Experts LLMs have been openly available for over a year3. However, these models seem to have gained less traction than equivalent dense models, arguable because their sheer model size (over a trillion parameters) makes them difficult to use. Most recently, Mistral AI released a family of sparse Mixture of Experts models called Mixtral-8x7B with near state-of-the-art performance Mixtral AI team (2023). This model has already inspired several follow-up works and practical applications, but it still requires a high-end GPU accelerator.\n# 2.2 Post-training Quantization of LLMs",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "Abstract\nWe introduce Mixtral 8x7B, a Sparse Mixture of Experts (SMoE) language model. Mixtral has the same architecture as Mistral 7B, with the difference that each layer is composed of 8 feedforward blocks (i.e. experts). For every token, at each layer, a router network selects two experts to process the current state and combine their outputs. Even though each token only sees two experts, the selected experts can be different at each timestep. As a result, each token has access to 47B parameters, but only uses 13B active parameters during inference. Mixtral was trained with a context size of 32k tokens and it outperforms or matches Llama 2 70B and GPT-3.5 across all evaluated benchmarks. In particular, Mixtral vastly outperforms Llama 2 70B on mathematics, code generation, and multilingual benchmarks. We also provide a model fine- tuned to follow instructions, Mixtral 8x7B â Instruct, that surpasses GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human bench- marks. Both the base and instruct models are released under the Apache 2.0 license.\nCode: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/",
            "Google. Google colaboratory, 2023. URL https://colab.research.google.com/.\nHendrycks, D., Burns, C., Basart, S., Zou, A., Mazeika, M., Song, D., and Steinhardt, J. Measuring massive multitask language understanding. Proceedings of the International Conference on Learning Representations (ICLR), 2021.\nHsu, Y.-C., Hua, T., Chang, S., Lou, Q., Shen, Y., and Jin, H. Language model compression with weighted low-rank factorization. arXiv preprint arXiv:2207.00112, 2022.\nJacobs, R. A., Jordan, M. I., Nowlan, S. J., and Hinton, G. E. Adaptive mixtures of local experts. Neural Computation, 3(1):79â87, March 1991. ISSN 0899-7667. doi: 10.1162/neco.1991.3.1.79. URL https://doi.org/10.1162/neco.1991.3.1.79.\nJordan, M. I. and Jacobs, R. A. Hierarchical mixtures of experts and the em algorithm. Neural computation, 6(2):181â214, 1994.",
            "# 2 Background & Related Work\n# 2.1 Mixture-of-Experts\nThe recent surge in MoE language models builds on a relatively old idea (Jacobs et al., 1991; Jordan & Jacobs, 1994) of training ensembles of specialized models (âexpertsâ) and a gating function to select the right expert for the task. To achieve specialization, Mixture-of-Experts learn by simultaneously i) training the gating function to choose the best experts and ii) training the experts themselves on samples assigned to them by the gating function. Since then, many different MoE variants emerged, including mixture of SVM models (Collobert et al., 2002), Dirichlet processes (Shahbaba & Neal, 2009) and various neural networks."
        ],
        "response": "Sparse Mixture-of-Experts increases the total parameter count because it keeps multiple distinct feed-forward networks (“experts”) inside every MoE layer, so while only a few experts are active for any token, the model stores weights for all of them. For example, Mixtral-8x7B offers access to 47 B parameters even though just 13 B are used per inference step, and the extra mass makes the checkpoint harder to fit on consumer GPUs without offloading tricks [https://arxiv.org/abs/2312.17238].",
        "reference": "The use of sparse Mixture-of-Experts (MoE) increases the size of language models due to having multiple \"experts.\""
    },
    {
        "user_input": "How does LRU caching improve the inference speed of Mixture-of-Experts language models?",
        "retrieved_contexts": [
            "We illustrate an example of how LRU cache saves experts in Figure 1 (see caption). LRU is a very simple strategy that does not consider factors like expert activation frequencies, varying cache size between MoE layers, or any sequential patterns in expert activation. However, we found that even this simple strategy can significantly speed up inference for modern Mixture-of-Experts models such as Mixtral-8x7B (see Section 4 for detailed evaluation).\n# 3.2 Speculative Expert Loading\nWhile LRU caching can reduce the average expert loading time, most of the inference time is still spent waiting for the next expert to be loaded. The reason behind this is that, unlike with dense models, MoE offloading cannot effectively overlap expert loading with computation. To understand this problem, let us zoom into the process of generating a single token, layer-by-layer. The full compute workload starts by embedding the previous token via look-up, then alternates between running self-attention and MLP for each transformer block in the model. Finally, the outputs from the last transformer block are used to predict next token logits with a linear projection.",
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization",
            "7Notably, Google Colab RAM cannot fit Mixtral-8x7B with a reasonable compression rate 8This corresponds to tensor.pin_memory() command in PyTorch.\n5\niy & cache_size =3 cache_size = 2 cache_size =4 0.84 | PIO â prefetch 1 experts ~ escent ae | PRS aa 0.2} ââ prefetch 2 experts ââ prefetch 3 experts 0.0 00 0 5 10 15 20 25 30 0 5 10 15 20 25 30 Layer # Layer # S Fd Ed Cache hit rate Bd ES Prediction recall = ES Ss &\nFigure 2: (left) LRU cache hit ratio for different cache size k; (right) speculative loading recall when pre-loading a different number of experts. Regular lines represent loading 1 layer ahead; dashed line stands for 2 layers ahead; dotted line is 10 layers ahead.\n# 4.1 Expert LRU Cache and Speculative Loading\nIn this section, we benchmark the effectiveness of the two expert offloading strategies: LRU caching and and speculative loading, as defined in Sections 3.1 and 3.2 respectively. For this evaluation, we measure âexpert recallâ â the fraction of times when an expert needed for inference was already available on GPU.",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "Figure 1: An example of expert loading pattern in Mixtral-8x7B-Instruct for select layers. Blue cells indicate that a certain expert was active when encoding a certain token; deeper blue indicates higher gating weight. Small gray squares show which experts are cached with an LRU cache for k=2.\n# 3.1 Expert Locality and LRU caching\nAs we discussed earlier in Section 2.1, Mixture-of-Experts language models were often observed to assign individual experts to distinct sub-tasks. However, this does not mean that the model uses the same expert over long stretches of tokens. Instead, some experts are active in short sequences of 2-4 tokens, while others are often used with âgapsâ, as shown in Figure 1.\nTo take advantage of this pattern, we can keep active experts in GPU memory as a âcacheâ for future tokens. If the same experts are activated again in future, they will be available instantaneously. Naturally, the number of experts that can be stored this way if very limited by the available GPU memory. For simplicity, we choose to always keep k least recently used experts as a type of LRU cache. If k is greater than the number of active experts, the cache will save experts from multiple previous tokens. For simplicity, we keep the same number of cached experts for each MoE layer.",
            "Expert Offloading. As described earlier, we use LRU cache with an equal number k of cached experts per layer. For Mixtral-8x7B, we use k=2 for 12GB GPUs and k=4 for 16GB ones. We trigger speculative expert loading immediately after the system finished loading all experts for the current layer. The speculative expert loading fetches 1 â 2 most likely experts. The newly loaded experts do not replace the currently cached experts. If a speculatively loaded expert was later used during next layer inference, it will replace the least recently used expert from the next layerâs cache.\nMany consumer devices and free-tier cloud instances have limited host RAM that cannot fit the entire model7. In these cases, the experts must be split between host and device memory. To support this, our implementation of expert LRU cache splits experts between host and GPU devices. When loading and expert to the GPU cache, the system also offloads the least recently used on-device expert back to RAM so as to preserve memory parity.",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction",
            "Google. Google colaboratory, 2023. URL https://colab.research.google.com/.\nHendrycks, D., Burns, C., Basart, S., Zou, A., Mazeika, M., Song, D., and Steinhardt, J. Measuring massive multitask language understanding. Proceedings of the International Conference on Learning Representations (ICLR), 2021.\nHsu, Y.-C., Hua, T., Chang, S., Lou, Q., Shen, Y., and Jin, H. Language model compression with weighted low-rank factorization. arXiv preprint arXiv:2207.00112, 2022.\nJacobs, R. A., Jordan, M. I., Nowlan, S. J., and Hinton, G. E. Adaptive mixtures of local experts. Neural Computation, 3(1):79â87, March 1991. ISSN 0899-7667. doi: 10.1162/neco.1991.3.1.79. URL https://doi.org/10.1162/neco.1991.3.1.79.\nJordan, M. I. and Jacobs, R. A. Hierarchical mixtures of experts and the em algorithm. Neural computation, 6(2):181â214, 1994.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2"
        ],
        "response": "LRU caching keeps the k least-recently used experts in GPU memory after each forward pass instead of offloading them back to RAM. When the same experts are requested again for subsequent tokens they are already resident on the device, eliminating the PCIe transfer latency and yielding noticeable speed-ups for Mixtral-8x7B despite the policy’s simplicity [source: unknown].",
        "reference": "LRU caching improves the inference speed of Mixture-of-Experts language models by keeping active experts in GPU memory as a cache for future tokens. This allows for faster retrieval of experts when needed during inference."
    },
    {
        "user_input": "In terms of expert loading time, what impact does the use of LRU caching have on Mixture-of-Experts language models?",
        "retrieved_contexts": [
            "We illustrate an example of how LRU cache saves experts in Figure 1 (see caption). LRU is a very simple strategy that does not consider factors like expert activation frequencies, varying cache size between MoE layers, or any sequential patterns in expert activation. However, we found that even this simple strategy can significantly speed up inference for modern Mixture-of-Experts models such as Mixtral-8x7B (see Section 4 for detailed evaluation).\n# 3.2 Speculative Expert Loading\nWhile LRU caching can reduce the average expert loading time, most of the inference time is still spent waiting for the next expert to be loaded. The reason behind this is that, unlike with dense models, MoE offloading cannot effectively overlap expert loading with computation. To understand this problem, let us zoom into the process of generating a single token, layer-by-layer. The full compute workload starts by embedding the previous token via look-up, then alternates between running self-attention and MLP for each transformer block in the model. Finally, the outputs from the last transformer block are used to predict next token logits with a linear projection.",
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization",
            "Expert Offloading. As described earlier, we use LRU cache with an equal number k of cached experts per layer. For Mixtral-8x7B, we use k=2 for 12GB GPUs and k=4 for 16GB ones. We trigger speculative expert loading immediately after the system finished loading all experts for the current layer. The speculative expert loading fetches 1 â 2 most likely experts. The newly loaded experts do not replace the currently cached experts. If a speculatively loaded expert was later used during next layer inference, it will replace the least recently used expert from the next layerâs cache.\nMany consumer devices and free-tier cloud instances have limited host RAM that cannot fit the entire model7. In these cases, the experts must be split between host and device memory. To support this, our implementation of expert LRU cache splits experts between host and GPU devices. When loading and expert to the GPU cache, the system also offloads the least recently used on-device expert back to RAM so as to preserve memory parity.",
            "Figure 1: An example of expert loading pattern in Mixtral-8x7B-Instruct for select layers. Blue cells indicate that a certain expert was active when encoding a certain token; deeper blue indicates higher gating weight. Small gray squares show which experts are cached with an LRU cache for k=2.\n# 3.1 Expert Locality and LRU caching\nAs we discussed earlier in Section 2.1, Mixture-of-Experts language models were often observed to assign individual experts to distinct sub-tasks. However, this does not mean that the model uses the same expert over long stretches of tokens. Instead, some experts are active in short sequences of 2-4 tokens, while others are often used with âgapsâ, as shown in Figure 1.\nTo take advantage of this pattern, we can keep active experts in GPU memory as a âcacheâ for future tokens. If the same experts are activated again in future, they will be available instantaneously. Naturally, the number of experts that can be stored this way if very limited by the available GPU memory. For simplicity, we choose to always keep k least recently used experts as a type of LRU cache. If k is greater than the number of active experts, the cache will save experts from multiple previous tokens. For simplicity, we keep the same number of cached experts for each MoE layer.",
            "7Notably, Google Colab RAM cannot fit Mixtral-8x7B with a reasonable compression rate 8This corresponds to tensor.pin_memory() command in PyTorch.\n5\niy & cache_size =3 cache_size = 2 cache_size =4 0.84 | PIO â prefetch 1 experts ~ escent ae | PRS aa 0.2} ââ prefetch 2 experts ââ prefetch 3 experts 0.0 00 0 5 10 15 20 25 30 0 5 10 15 20 25 30 Layer # Layer # S Fd Ed Cache hit rate Bd ES Prediction recall = ES Ss &\nFigure 2: (left) LRU cache hit ratio for different cache size k; (right) speculative loading recall when pre-loading a different number of experts. Regular lines represent loading 1 layer ahead; dashed line stands for 2 layers ahead; dotted line is 10 layers ahead.\n# 4.1 Expert LRU Cache and Speculative Loading\nIn this section, we benchmark the effectiveness of the two expert offloading strategies: LRU caching and and speculative loading, as defined in Sections 3.1 and 3.2 respectively. For this evaluation, we measure âexpert recallâ â the fraction of times when an expert needed for inference was already available on GPU.",
            "For regular (dense) models, this architecture allows for efficient offloading schedule that pre-loads the next transformer layer ahead of time, while the previous layer is still running. Unfortunately, this schedule is no longer possible for Mixture-of-Experts models, where MoE MLP layers choose which experts to load just-in-time for computation. This is because the system cannot pre-fetch the next layer until it learns which experts should be loaded. Modern open-access MoE language models choose active experts using the final outputs of the previous layer, which means they cannot be pre-fetched them in parallel with previous layer. While it is not possible6 to pre-reliably prefetch the next set of experts ahead of time, the system could still try to guess the likely next experts and load them speculatively, while processing the previous layer. It the guess is correct, it will speed up the next layer inference; if not, it can load the actual next layerâs experts later. In other words, this type of speculative loading does not change the final model predictions, but may reduce latency if the guess is accurate enough.\n6More specifically, not possible without changing the model architecture, which would require re-training\n4",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction"
        ],
        "response": "LRU caching lowers average expert loading time for Mixture-of-Experts models by keeping the k least-recently-used experts on GPU; experiments on Mixtral-8x7B show this raises expert recall (cache hit ratio) and yields significant inference speed-ups even though the simple policy ignores activation frequencies or layer-specific cache sizing [source: unknown].",
        "reference": "The use of LRU caching in Mixture-of-Experts language models can significantly speed up inference by reducing the average expert loading time. However, most of the inference time is still spent waiting for the next expert to be loaded. This is because the architecture of Mixture-of-Experts models does not allow for efficient offloading schedules like regular (dense) models, where the next layer can be pre-loaded ahead of time. In Mixture-of-Experts models, the experts to be loaded are chosen just-in-time for computation, so the system cannot pre-fetch the next layer until it learns which experts should be loaded."
    },
    {
        "user_input": "How does the loading pattern of experts in Mixture-of-Experts models impact the efficiency of inference time?",
        "retrieved_contexts": [
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization",
            "For regular (dense) models, this architecture allows for efficient offloading schedule that pre-loads the next transformer layer ahead of time, while the previous layer is still running. Unfortunately, this schedule is no longer possible for Mixture-of-Experts models, where MoE MLP layers choose which experts to load just-in-time for computation. This is because the system cannot pre-fetch the next layer until it learns which experts should be loaded. Modern open-access MoE language models choose active experts using the final outputs of the previous layer, which means they cannot be pre-fetched them in parallel with previous layer. While it is not possible6 to pre-reliably prefetch the next set of experts ahead of time, the system could still try to guess the likely next experts and load them speculatively, while processing the previous layer. It the guess is correct, it will speed up the next layer inference; if not, it can load the actual next layerâs experts later. In other words, this type of speculative loading does not change the final model predictions, but may reduce latency if the guess is accurate enough.\n6More specifically, not possible without changing the model architecture, which would require re-training\n4",
            "Expert Offloading. As described earlier, we use LRU cache with an equal number k of cached experts per layer. For Mixtral-8x7B, we use k=2 for 12GB GPUs and k=4 for 16GB ones. We trigger speculative expert loading immediately after the system finished loading all experts for the current layer. The speculative expert loading fetches 1 â 2 most likely experts. The newly loaded experts do not replace the currently cached experts. If a speculatively loaded expert was later used during next layer inference, it will replace the least recently used expert from the next layerâs cache.\nMany consumer devices and free-tier cloud instances have limited host RAM that cannot fit the entire model7. In these cases, the experts must be split between host and device memory. To support this, our implementation of expert LRU cache splits experts between host and GPU devices. When loading and expert to the GPU cache, the system also offloads the least recently used on-device expert back to RAM so as to preserve memory parity.",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "The generative inference workload consists of two phases: 1) encoding the input prompt and 2) generating tokens conditioned on that prompt. The key difference between these two phases is that prompt tokens are encoded in parallel (layer-by-layer), whereas the generation runs sequentially (token-by-token and layer-by-layer). In general, phase 1 works relatively well with existing Mixture- of-Experts algorithms, since each layer can only be loaded once for the entire prompt. In turn, when generating tokens, one must load layer once per each token generated. In practice, this means that inference speed is limited by how fast one can fetch parameters from system memory.\nBelow, we look for patterns in how the MoE model loads its experts and propose ways to exploit these patterns to speed up inference time.\n4To learn more about these methods, please refer to surveys such as Gholami et al. (2021); Liang et al. (2021) 5As opposed to running a processing a large batch of texts over many seconds, as in Sheng et al. (2023)\n3\nSelected experts for Mixtral-8x7B-Instruct woe 0 (top) and 15 ae =n a oa ao a âme: a n: ee Layer 15 expert # Layer 0 expert # MAUR STARR O However about |= and 4 training data owerful language model based trained Trans former f architecture",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "Figure 1: An example of expert loading pattern in Mixtral-8x7B-Instruct for select layers. Blue cells indicate that a certain expert was active when encoding a certain token; deeper blue indicates higher gating weight. Small gray squares show which experts are cached with an LRU cache for k=2.\n# 3.1 Expert Locality and LRU caching\nAs we discussed earlier in Section 2.1, Mixture-of-Experts language models were often observed to assign individual experts to distinct sub-tasks. However, this does not mean that the model uses the same expert over long stretches of tokens. Instead, some experts are active in short sequences of 2-4 tokens, while others are often used with âgapsâ, as shown in Figure 1.\nTo take advantage of this pattern, we can keep active experts in GPU memory as a âcacheâ for future tokens. If the same experts are activated again in future, they will be available instantaneously. Naturally, the number of experts that can be stored this way if very limited by the available GPU memory. For simplicity, we choose to always keep k least recently used experts as a type of LRU cache. If k is greater than the number of active experts, the cache will save experts from multiple previous tokens. For simplicity, we keep the same number of cached experts for each MoE layer.",
            "Google. Google colaboratory, 2023. URL https://colab.research.google.com/.\nHendrycks, D., Burns, C., Basart, S., Zou, A., Mazeika, M., Song, D., and Steinhardt, J. Measuring massive multitask language understanding. Proceedings of the International Conference on Learning Representations (ICLR), 2021.\nHsu, Y.-C., Hua, T., Chang, S., Lou, Q., Shen, Y., and Jin, H. Language model compression with weighted low-rank factorization. arXiv preprint arXiv:2207.00112, 2022.\nJacobs, R. A., Jordan, M. I., Nowlan, S. J., and Hinton, G. E. Adaptive mixtures of local experts. Neural Computation, 3(1):79â87, March 1991. ISSN 0899-7667. doi: 10.1162/neco.1991.3.1.79. URL https://doi.org/10.1162/neco.1991.3.1.79.\nJordan, M. I. and Jacobs, R. A. Hierarchical mixtures of experts and the em algorithm. Neural computation, 6(2):181â214, 1994.",
            "Jordan, M. I. and Jacobs, R. A. Hierarchical mixtures of experts and the em algorithm. Neural computation, 6(2):181â214, 1994.\nKim, Y. J., Fahim, R., and Awadalla, H. H. Mixture of quantized experts (moqe): Complementary effect of low-bit quantization and robustness, 2023.\nKÃ¶pf, A., Kilcher, Y., von RÃ¼tte, D., Anagnostidis, S., Tam, Z.-R., Stevens, K., Barhoum, A., Duc, N. M., Stanley, O., Nagyfi, R., ES, S., Suri, S., Glushkov, D., Dantuluri, A., Maguire, A., Schuhmann, C., Nguyen, H., and Mattick, A. Openassistant conversations â democratizing large language model alignment, 2023.",
            "We illustrate an example of how LRU cache saves experts in Figure 1 (see caption). LRU is a very simple strategy that does not consider factors like expert activation frequencies, varying cache size between MoE layers, or any sequential patterns in expert activation. However, we found that even this simple strategy can significantly speed up inference for modern Mixture-of-Experts models such as Mixtral-8x7B (see Section 4 for detailed evaluation).\n# 3.2 Speculative Expert Loading\nWhile LRU caching can reduce the average expert loading time, most of the inference time is still spent waiting for the next expert to be loaded. The reason behind this is that, unlike with dense models, MoE offloading cannot effectively overlap expert loading with computation. To understand this problem, let us zoom into the process of generating a single token, layer-by-layer. The full compute workload starts by embedding the previous token via look-up, then alternates between running self-attention and MLP for each transformer block in the model. Finally, the outputs from the last transformer block are used to predict next token logits with a linear projection."
        ],
        "response": "The loading pattern directly determines inference latency because the MoE router selects experts layer-by-layer using the previous layer’s output, so the next experts cannot be prefetched while the current layer is still computing; the system must instead load them just-in-time after the gating decision is known, leaving the GPU idle during the fetch unless speculative loading is used [https://colab.research.google.com/]. Speculative loading applies the next layer’s gating function early and pre-loads the 1–2 most likely experts; if the guess is correct the experts are already resident and the layer proceeds without stall, giving a recall of 1.0 when both Mixtral active experts are pre-fetched, but incorrect guesses incur an additional late fetch and do not change the model’s output [https://colab.research.google.com/]. Combining this with an LRU cache that keeps the k least-recently-used experts per layer (k=2 on 12 GB GPUs, k=4 on 16 GB GPUs) exploits the short 2-4 token locality bursts observed in Mixtral-8x7B-Instruct, further reducing the frequency of off-chip fetches during the sequential token-generation phase [https://colab.research.google.com/].",
        "reference": "The loading pattern of experts in Mixture-of-Experts models impacts the efficiency of inference time. In interactive inference scenarios, where tokens are generated one at a time, the inference system spends most of the time waiting for the next layer's parameters to be loaded. This is because the system cannot pre-fetch the next layer until it learns which experts should be loaded. However, in non-interactive scenarios with large batches of data, each layer processes a lot of tokens at once, which improves efficiency. Additionally, by keeping active experts in GPU memory as a cache, the inference time can be further sped up."
    },
    {
        "user_input": "In terms of generating tokens, what is the effect of the loading pattern of experts in Mixture-of-Experts models?",
        "retrieved_contexts": [
            "Figure 1: An example of expert loading pattern in Mixtral-8x7B-Instruct for select layers. Blue cells indicate that a certain expert was active when encoding a certain token; deeper blue indicates higher gating weight. Small gray squares show which experts are cached with an LRU cache for k=2.\n# 3.1 Expert Locality and LRU caching\nAs we discussed earlier in Section 2.1, Mixture-of-Experts language models were often observed to assign individual experts to distinct sub-tasks. However, this does not mean that the model uses the same expert over long stretches of tokens. Instead, some experts are active in short sequences of 2-4 tokens, while others are often used with âgapsâ, as shown in Figure 1.\nTo take advantage of this pattern, we can keep active experts in GPU memory as a âcacheâ for future tokens. If the same experts are activated again in future, they will be available instantaneously. Naturally, the number of experts that can be stored this way if very limited by the available GPU memory. For simplicity, we choose to always keep k least recently used experts as a type of LRU cache. If k is greater than the number of active experts, the cache will save experts from multiple previous tokens. For simplicity, we keep the same number of cached experts for each MoE layer.",
            "The generative inference workload consists of two phases: 1) encoding the input prompt and 2) generating tokens conditioned on that prompt. The key difference between these two phases is that prompt tokens are encoded in parallel (layer-by-layer), whereas the generation runs sequentially (token-by-token and layer-by-layer). In general, phase 1 works relatively well with existing Mixture- of-Experts algorithms, since each layer can only be loaded once for the entire prompt. In turn, when generating tokens, one must load layer once per each token generated. In practice, this means that inference speed is limited by how fast one can fetch parameters from system memory.\nBelow, we look for patterns in how the MoE model loads its experts and propose ways to exploit these patterns to speed up inference time.\n4To learn more about these methods, please refer to surveys such as Gholami et al. (2021); Liang et al. (2021) 5As opposed to running a processing a large batch of texts over many seconds, as in Sheng et al. (2023)\n3\nSelected experts for Mixtral-8x7B-Instruct woe 0 (top) and 15 ae =n a oa ao a âme: a n: ee Layer 15 expert # Layer 0 expert # MAUR STARR O However about |= and 4 training data owerful language model based trained Trans former f architecture",
            "Jordan, M. I. and Jacobs, R. A. Hierarchical mixtures of experts and the em algorithm. Neural computation, 6(2):181â214, 1994.\nKim, Y. J., Fahim, R., and Awadalla, H. H. Mixture of quantized experts (moqe): Complementary effect of low-bit quantization and robustness, 2023.\nKÃ¶pf, A., Kilcher, Y., von RÃ¼tte, D., Anagnostidis, S., Tam, Z.-R., Stevens, K., Barhoum, A., Duc, N. M., Stanley, O., Nagyfi, R., ES, S., Suri, S., Glushkov, D., Dantuluri, A., Maguire, A., Schuhmann, C., Nguyen, H., and Mattick, A. Openassistant conversations â democratizing large language model alignment, 2023.",
            "For regular (dense) models, this architecture allows for efficient offloading schedule that pre-loads the next transformer layer ahead of time, while the previous layer is still running. Unfortunately, this schedule is no longer possible for Mixture-of-Experts models, where MoE MLP layers choose which experts to load just-in-time for computation. This is because the system cannot pre-fetch the next layer until it learns which experts should be loaded. Modern open-access MoE language models choose active experts using the final outputs of the previous layer, which means they cannot be pre-fetched them in parallel with previous layer. While it is not possible6 to pre-reliably prefetch the next set of experts ahead of time, the system could still try to guess the likely next experts and load them speculatively, while processing the previous layer. It the guess is correct, it will speed up the next layer inference; if not, it can load the actual next layerâs experts later. In other words, this type of speculative loading does not change the final model predictions, but may reduce latency if the guess is accurate enough.\n6More specifically, not possible without changing the model architecture, which would require re-training\n4",
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization",
            "# 2 Background & Related Work\n# 2.1 Mixture-of-Experts\nThe recent surge in MoE language models builds on a relatively old idea (Jacobs et al., 1991; Jordan & Jacobs, 1994) of training ensembles of specialized models (âexpertsâ) and a gating function to select the right expert for the task. To achieve specialization, Mixture-of-Experts learn by simultaneously i) training the gating function to choose the best experts and ii) training the experts themselves on samples assigned to them by the gating function. Since then, many different MoE variants emerged, including mixture of SVM models (Collobert et al., 2002), Dirichlet processes (Shahbaba & Neal, 2009) and various neural networks.",
            "Mixture of Experts Layer i gating inputs af outputs router expert\nFigure 1: Mixture of Experts Layer. Each input vector is assigned to 2 of the 8 experts by a router. The layerâs output is the weighted sum of the outputs of the two selected experts. In Mixtral, an expert is a standard feedforward block as in a vanilla transformer architecture.\nMixtral demonstrates superior capabilities in mathematics, code generation, and tasks that require multilingual understanding, significantly outperforming Llama 2 70B in these domains. Experiments show that Mixtral is able to successfully retrieve information from its context window of 32k tokens, regardless of the sequence length and the location of the information in the sequence.",
            "Expert Offloading. As described earlier, we use LRU cache with an equal number k of cached experts per layer. For Mixtral-8x7B, we use k=2 for 12GB GPUs and k=4 for 16GB ones. We trigger speculative expert loading immediately after the system finished loading all experts for the current layer. The speculative expert loading fetches 1 â 2 most likely experts. The newly loaded experts do not replace the currently cached experts. If a speculatively loaded expert was later used during next layer inference, it will replace the least recently used expert from the next layerâs cache.\nMany consumer devices and free-tier cloud instances have limited host RAM that cannot fit the entire model7. In these cases, the experts must be split between host and device memory. To support this, our implementation of expert LRU cache splits experts between host and GPU devices. When loading and expert to the GPU cache, the system also offloads the least recently used on-device expert back to RAM so as to preserve memory parity.",
            "Table 5: Percentage of expert assignment repetitions. We evaluate the proportion of times the same expert is assigned to a token i and its following token i+1. We report whether the first chosen expert is the same, or whether the same expert is observed as first or second choice in consecutive tokens. For reference, the expected proportion of repetitions in the case of random assignments is 1 5 7 â 46% for âFirst and second choiceâ. Repetitions at the first layer are close to random, but are significantly higher at layers 15 and 31. The high number of repetitions shows that expert choice exhibits high temporal locality at these layers.\nconsecutive assignments is significantly higher than random for higher layers. This has implications in how one might optimize the model for fast training and inference. For example, cases with high locality are more likely to cause over-subscription of certain experts when doing Expert Parallelism. Conversely, this locality can be leveraged for caching, as is done in [11]. A more complete view of these same expert frequency is provided for all layers and across datasets in Figure 10 in the Appendix.\n# 6 Conclusion",
            "Shazeer et al. (2017) builds on this idea to train a sparsely gated Mixture-of-Experts to serve as a language model. The full model consists of a recurrent neural network backbone and a MoE module with up to 131072 experts. When processing a given token, a linear gating function select 4 most suitable experts based on the latest hidden state. The resulting model (including the gating function and experts) is trained end-to-end to minimize cross-entropy, with an additional regularizer to promote equal expert utilization. Shazeer et al. (2017) observed that the MoE model not only improves perplexity, but also learns interpretable expert specializations: some experts would âspecializeâ on prepositions, while others learn to express a particular concept (e.g. speed)."
        ],
        "response": "During token generation, each new token forces the MoE layer to be loaded once, so the router must choose experts just-in-time; because the gating decision depends on the final output of the previous layer, the set of required experts cannot be pre-fetched, making inference latency bound by the speed of fetching parameters from system memory. Speculative loading that guesses the likely experts while the current layer runs can hide some of this latency without changing model outputs, and LRU caching of recently used experts exploits high temporal locality—especially in higher layers where the same expert is re-selected for consecutive tokens more often than random—to reduce reloads.",
        "reference": "The loading pattern of experts in Mixture-of-Experts models has an effect on generating tokens. When generating tokens, each layer needs to be loaded once per each token generated. This means that the inference speed is limited by how fast the parameters can be fetched from system memory. In interactive inference, where tokens are generated autoregressively from left to right, the inference system spends most of the time waiting for the next layer's parameters to be loaded. To speed up inference time, active experts can be kept in GPU memory as a cache for future tokens. If the same experts are activated again in the future, they will be available instantaneously. However, even with caching, most of the inference time is still spent waiting for the next expert to be loaded, as MoE offloading cannot effectively overlap expert loading with computation like dense models."
    },
    {
        "user_input": "What are the architectural differences in terms of feedforward blocks and active parameters used during inference between Mixtral 8x7B and Mistral 7B?",
        "retrieved_contexts": [
            "We also present Mixtral 8x7B â Instruct, a chat model fine-tuned to follow instructions using supervised fine-tuning and Direct Preference Optimization [25]. Its performance notably surpasses that of GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human evaluation benchmarks. Mixtral â Instruct also demonstrates reduced biases, and a more balanced sentiment profile in benchmarks such as BBQ, and BOLD. We release both Mixtral 8x7B and Mixtral 8x7B â Instruct under the Apache 2.0 license1, free for academic and commercial usage, ensuring broad accessibility and potential for diverse applications. To enable the community to run Mixtral with a fully open-source stack, we submitted changes to the vLLM project, which integrates Megablocks CUDA kernels for efficient inference. Skypilot also allows the deployment of vLLM endpoints on any instance in the cloud.\n# 2 Architectural details\nMixtral is based on a transformer architecture [31] and uses the same modifications as described in [18], with the notable exceptions that Mix- tral supports a fully dense context length of 32k tokens, and the feed- forward blocks are replaced by Mixture-of-Expert layers (Section 2.1). The model architecture parameters are summarized in Table 1. Parameter Value",
            "Table 2: Comparison of Mixtral with Llama. Mixtral outperforms or matches Llama 2 70B performance on almost all popular benchmarks while using 5x fewer active parameters during inference.\n70 Mixtral 8x7B. âMixtral 8x7B Mixtral 8x7B 355 =o = Es & E60! Mistral 78 % 2681 Mistral 78 3 3 s0 5 = A % 66 50 g 4 45 64 78 138 348708 78 138 348708 78 138 348 70B S66 Mixtral 8x7B 50 Mixtral 8x7B 5 = 564 340 g al Mistral 78 ee Mistral 78 3 5 Â§ 30 5 eo â= Mistral Â° 20 âe LlaMA2 78 (138 348 70B 7B (138 348 708 7B Â«13B 34B 708 Active Params Active Params Active Params\nFigure 3: Results on MMLU, commonsense reasoning, world knowledge and reading comprehension, math and code for Mistral (7B/8x7B) vs Llama 2 (7B/13B/70B). Mixtral largely outperforms Llama 2 70B on all benchmarks, except on reading comprehension benchmarks while using 5x lower active parameters. It is also vastly superior to Llama 2 70B on code and math.",
            "Abstract\nWe introduce Mixtral 8x7B, a Sparse Mixture of Experts (SMoE) language model. Mixtral has the same architecture as Mistral 7B, with the difference that each layer is composed of 8 feedforward blocks (i.e. experts). For every token, at each layer, a router network selects two experts to process the current state and combine their outputs. Even though each token only sees two experts, the selected experts can be different at each timestep. As a result, each token has access to 47B parameters, but only uses 13B active parameters during inference. Mixtral was trained with a context size of 32k tokens and it outperforms or matches Llama 2 70B and GPT-3.5 across all evaluated benchmarks. In particular, Mixtral vastly outperforms Llama 2 70B on mathematics, code generation, and multilingual benchmarks. We also provide a model fine- tuned to follow instructions, Mixtral 8x7B â Instruct, that surpasses GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human bench- marks. Both the base and instruct models are released under the Apache 2.0 license.\nCode: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/",
            "# 6 Conclusion\nIn this paper, we introduced Mixtral 8x7B, the first mixture-of-experts network to reach a state-of-the- art performance among open-source models. Mixtral 8x7B Instruct outperforms Claude-2.1, Gem- ini Pro, and GPT-3.5 Turbo on human evaluation benchmarks. Because it only uses two experts at each time step, Mixtral only uses 13B active parameters per token while outperforming the previous best model using 70B parameters per token (Llama 2 70B). We are making our trained and fine-tuned mod- els publicly available under the Apache 2.0 license. By sharing our models, we aim to facilitate the de- velopment of new techniques and applications that can benefit a wide range of industries and domains.",
            "Detailed results for Mixtral, Mistral 7B and Llama 2 7B/13B/70B and Llama 1 34B2 are reported in Table 2. Figure 2 compares the performance of Mixtral with the Llama models in different categories. Mixtral surpasses Llama 2 70B across most metrics. In particular, Mixtral displays a superior performance in code and mathematics benchmarks.\nSize and Efficiency. We compare our performance to the Llama 2 family, aiming to understand Mixtral modelsâ efficiency in the cost-performance spectrum (see Figure 3). As a sparse Mixture- of-Experts model, Mixtral only uses 13B active parameters for each token. With 5x lower active parameters, Mixtral is able to outperform Llama 2 70B across most categories.\nNote that this analysis focuses on the active parameter count (see Section 2.1), which is directly proportional to the inference compute cost, but does not consider the memory costs and hardware utilization. The memory costs for serving Mixtral are proportional to its sparse parameter count, 47B, which is still smaller than Llama 2 70B. As for device utilization, we note that the SMoEs layer introduces additional overhead due to the routing mechanism and due to the increased memory loads when running more than one expert per device. They are more suitable for batched workloads where one can reach a good degree of arithmetic intensity.",
            "# 3.1 Multilingual benchmarks\nCompared to Mistral 7B, we significantly upsample the proportion of multilingual data during pretraining. The extra capacity allows Mixtral to perform well on multilingual benchmarks while maintaining a high accuracy in English. In particular, Mixtral significantly outperforms Llama 2 70B in French, German, Spanish, and Italian, as shown in Table 4.\nActive Params French Arc-c HellaS MMLU German Arc-c HellaS MMLU Spanish Arc-c HellaS MMLU Italian Arc-c HellaS MMLU 33B 70B 13B 42.9% 65.4% 49.0% 39.3% 68.1% 49.9% 49.9% 72.5% 64.3% 49.4% 70.9% 65.1% 58.2% 77.4% 70.9% 54.3% 73.0% 71.5% 55.4% 77.6% 72.5% 52.8% 75.1% 70.9% 41.1% 63.3% 48.7% 47.3% 68.7% 64.2% 45.7% 69.8% 52.3% 50.5% 74.5% 66.0%",
            "Comparison with Llama 2 70B and GPT-3.5. In Table 3, we report the performance of Mixtral 8x7B compared to Llama 2 70B and GPT-3.5. We observe that Mixtral performs similarly or above the two other models. On MMLU, Mixtral obtains a better performance, despite its significantly smaller capacity (47B tokens compared to 70B). For MT Bench, we report the performance of the latest GPT-3.5-Turbo model available, gpt-3.5-turbo-1106.\n2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4",
            "Table 1: Perplexity and model size evaluation of Mixtral-8x7B with different quantization for shared attention (Attn quant) and experts (Experts quant) layers. For comprarison, a Mistral-7B 4-bit quantized model has Wiki2 perplexity 5.03, C4 perplexity 7.56 and MMLU score 61.3%. See Section 4.2 for details. Green values correspond to the configurations we chose for full system evaluation.\n6\nAlgorithm 2-bit Experts 3-bit Experts A100 3080 Mobile 3060 T4 (Colab) A100 3080 Mobile 3060 T4 (Cloud) 3.061 Full algorithm 2.918 W/o expert pre-loading 2.265 W/o LRU cache & pre-loading Naive offloading (accelerate) 1.392 2.655 2.227 1.758 1.059 2.278 2.051 1.547 0.919 2.092 1.567 1.168 0.661 2.845 2.683 2.055 1.246 2.475 2.024 1.595 0.914 2.038 1.857 1.346 1.791 1.603 1.365 1.061 0.580",
            "n-1 y= Ss Softmax(Top2(a - W,)); - SwiGLU;(a). i=0\nThis formulation is similar to the GShard architecture [21], with the exceptions that we replace all FFN sub-blocks by MoE layers while GShard replaces every other block, and that GShard uses a more elaborate gating strategy for the second expert assigned to each token.\n# 3 Results\nWe compare Mixtral to Llama, and re-run all benchmarks with our own evaluation pipeline for fair comparison. We measure performance on a wide variety of tasks categorized as follow:\nâ¢ Commonsense Reasoning (0-shot): Hellaswag [32], Winogrande [26], PIQA [3], SIQA [27], OpenbookQA [22], ARC-Easy, ARC-Challenge [8], CommonsenseQA [30]",
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization"
        ],
        "response": "Mistral 7B uses standard dense feed-forward blocks, whereas Mixtral 8x7B replaces every FFN with a Mixture-of-Experts layer containing 8 expert feed-forward blocks. At inference, for each token the Mixtral router selects only 2 of these 8 experts, so while the model totals 47 B parameters, only 13 B are active per token, roughly 5× fewer than the 70 B active parameters of Llama 2 70B and significantly fewer than the 7 B active parameters of Mistral 7B.",
        "reference": "The architectural difference between Mixtral 8x7B and Mistral 7B lies in the number of feedforward blocks (experts) in each layer. Mixtral 8x7B has 8 feedforward blocks per layer, while Mistral 7B has a different number of feedforward blocks. Additionally, during inference, each token in both models has access to 47B parameters, but only 13B active parameters are used."
    },
    {
        "user_input": "When is offloading used on the A100 server for accelerating MoE-based language models?",
        "retrieved_contexts": [
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "For regular (dense) models, this architecture allows for efficient offloading schedule that pre-loads the next transformer layer ahead of time, while the previous layer is still running. Unfortunately, this schedule is no longer possible for Mixture-of-Experts models, where MoE MLP layers choose which experts to load just-in-time for computation. This is because the system cannot pre-fetch the next layer until it learns which experts should be loaded. Modern open-access MoE language models choose active experts using the final outputs of the previous layer, which means they cannot be pre-fetched them in parallel with previous layer. While it is not possible6 to pre-reliably prefetch the next set of experts ahead of time, the system could still try to guess the likely next experts and load them speculatively, while processing the previous layer. It the guess is correct, it will speed up the next layer inference; if not, it can load the actual next layerâs experts later. In other words, this type of speculative loading does not change the final model predictions, but may reduce latency if the guess is accurate enough.\n6More specifically, not possible without changing the model architecture, which would require re-training\n4",
            "# 4.3 Practical offloading performance\nFinally we evaluate the performance of the Mixtral8x7B-Instruct model using the offloading tech- niquesproposed throughout this report. Based on the perplexity evaluations from the previous section, we chose 4-bit HQQ quantization for the shared attention layers and 2- or 3-bit quantization for experts. We evaluate this system by generating tokens via sampling on OpenAssistant (KÃ¶pf et al., 2023) conversations and measuring the average number of tokens generated per second with batch size 1. For this evaluation, we always sample proportionally to the predicted probabilities, i.e. without temperature or nucleus sampling.",
            "Ren, J., Rajbhandari, S., Aminabadi, R. Y., Ruwase, O., Yang, S., Zhang, M., Li, D., and He, Y. Zero-offload: Democratizing billion-scale model training. CoRR, abs/2101.06840, 2021. URL https://arxiv.org/abs/2101.06840.\nScao, T. L., Fan, A., Akiki, C., Pavlick, E., IliÂ´c, S., Hesslow, D., CastagnÃ©, R., Luccioni, A. S., Yvon, F., GallÃ©, M., et al. Bloom: A 176b-parameter open-access multilingual language model. arXiv preprint arXiv:2211.05100, 2022.\nShahbaba, B. and Neal, R. Nonlinear models using dirichlet process mixtures. Journal of Machine Learning Research, 10(Aug):1829â1850, 2009.",
            "This technique works particularly well when processing large batches of data, during train- ing Pudipeddi et al. (2020); Ren et al. (2021) or large-batch non-interactive inference Aminabadi et al. (2022); Sheng et al. (2023), where each layer processes a lot of tokens each time the layer is loaded from RAM. In turn, when doing interactive inference (e.g. as a chat assistants), offloading works significantly slower than on-device inference. This is because interactive inference generates tokens autoregressively, from left to right. This way, the inference system processes one or few tokens at a time, and therefore spends most of the time waiting for next layerâs parameters to be loaded.\n# 2.4 Hardware Setup",
            "We consider four hardware configurations: a free-tier Colab instance with a T4 GPU (16GB VRAM, PCIe Gen.3), a past generation gaming laptop with RTX 3080 Mobile (16GB, PCIe Gen.4), a mid- range gaming desktop with RTX 3060 (12GB, PCIe Gen.3) and a high-end data-center server with A100-80GB-SXM. Note that the A100 server could run the model without offloading. We use offloading on A100 mostly to provide a reference for other setups. Finally, when evaluating 3-bit models, we use a cloud T4 from Microsoft Azure because the free-tier colab instances did not have enough RAM for this specific configuration. We use k = 2 for RTX 3060 and k = 4 for all other GPUs.\nAs shown in Table 2, all evaluated setups can generate 2-4 tokens per second with the full algorithm. Using pre-loading appears to be most beneficial on RTX 3060, possibly due to lower LRU cache size. Cursiously, RTX 3060 (desktop) performs nearly equally with a much higher end 3080 Mobile. We attribute this to the fact that both GPUs are still bottlenecked by host-to-device bandwidth, limited by the PCIe architecture. Finally, all schemes significantly outperform naive offloading that loads the entire MoE layer.\n# 5 Conclusion and Future Work",
            "MoE layers can be run efficiently on single GPUs with high performance specialized kernels. For example, Megablocks [13] casts the feed-forward network (FFN) operations of the MoE layer as large sparse matrix multiplications, significantly enhancing the execution speed and naturally handling cases where different experts get a variable number of tokens assigned to them. Moreover, the MoE layer can be distributed to multiple GPUs through standard Model Parallelism techniques, and through a particular kind of partitioning strategy called Expert Parallelism (EP) [28]. During the MoE layerâs execution, tokens meant to be processed by a specific expert are routed to the corresponding GPU for processing, and the expertâs output is returned to the original token location. Note that EP introduces challenges in load balancing, as it is essential to distribute the workload evenly across the GPUs to prevent overloading individual GPUs or hitting computational bottlenecks.\nIn a Transformer model, the MoE layer is applied independently per token and replaces the feed-forward (FFN) sub-block of the transformer block. For Mixtral we use the same SwiGLU architecture as the expert function Ei(x) and set K = 2. This means each token is routed to two SwiGLU sub-blocks with different sets of weights. Taking this all together, the output y for an input token x is computed as:"
        ],
        "response": "Offloading on the A100 server is used only to provide a performance reference for other hardware setups, since the A100-80GB-SXM has enough memory to run Mixtral-8x7B-Instruct without any offloading.[source: unknown]",
        "reference": "Offloading is used on the A100 server for accelerating MoE-based language models when there is resource-constricted hardware and the goal is to enable broader access to these powerful models for research and development."
    },
    {
        "user_input": "Which model outperforms Llama 2 70B on multilingual benchmarks?",
        "retrieved_contexts": [
            "2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4\nLLaMA 2 70B GPT-3.5 MMLU (MCQ in 57 subjects) 69.9% 70.0% 70.6% HellaSwag (10-shot) 87.1% 85.5% 86.7% ARC Challenge (25-shot) 85.1% 85.2% 85.8% WinoGrande (5-shot) 83.2% 81.6% 81.2% MBPP (pass@1) 49.8% 52.2% 60.7% GSM-8K (5-shot) 53.6% 57.1% 58.4% MT Bench (for Instruct Models) 6.86 8.32 8.30\n# Mixtral 8x7B\nTable 3: Comparison of Mixtral with Llama 2 70B and GPT-3.5. Mixtral outperforms or matches Llama 2 70B and GPT-3.5 performance on most metrics.\nEvaluation Differences. On some benchmarks, there are some differences between our evaluation protocol and the one reported in the Llama 2 paper: 1) on MBPP, we use the hand-verified subset 2) on TriviaQA, we do not provide Wikipedia contexts.\n# 3.1 Multilingual benchmarks",
            "Table 4: Comparison of Mixtral with Llama on Multilingual Benchmarks. On ARC Challenge, Hellaswag, and MMLU, Mixtral outperforms Llama 2 70B on 4 languages: French, German, Spanish, and Italian.\n# 3.2 Long range performance\nTo assess the capabilities of Mixtral to tackle long context, we evaluate it on the passkey retrieval task introduced in [23], a synthetic task designed to measure the ability of the model to retrieve a passkey inserted randomly in a long prompt. Results in Figure 4 (Left) show that Mixtral achieves a 100% retrieval accuracy regardless of the context length or the position of passkey in the sequence. Figure 4 (Right) shows that the perplexity of Mixtral on a subset of the proof-pile dataset [2] decreases monotonically as the size of the context increases.\nPasskey Performance ry 0.8 0.6 04 0.2 0.0 OK 4K 8K 12K 16K 20K 24K 28K Seq Len Passkey Loc\n3.8 â Mixtral_8x7B 3.5 32 > $3.0 i] 228 fos a 2.0 0 5k 10k 15k 20k 25k 30k Context length",
            "Abstract\nWe introduce Mixtral 8x7B, a Sparse Mixture of Experts (SMoE) language model. Mixtral has the same architecture as Mistral 7B, with the difference that each layer is composed of 8 feedforward blocks (i.e. experts). For every token, at each layer, a router network selects two experts to process the current state and combine their outputs. Even though each token only sees two experts, the selected experts can be different at each timestep. As a result, each token has access to 47B parameters, but only uses 13B active parameters during inference. Mixtral was trained with a context size of 32k tokens and it outperforms or matches Llama 2 70B and GPT-3.5 across all evaluated benchmarks. In particular, Mixtral vastly outperforms Llama 2 70B on mathematics, code generation, and multilingual benchmarks. We also provide a model fine- tuned to follow instructions, Mixtral 8x7B â Instruct, that surpasses GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human bench- marks. Both the base and instruct models are released under the Apache 2.0 license.\nCode: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/",
            "Comparison with Llama 2 70B and GPT-3.5. In Table 3, we report the performance of Mixtral 8x7B compared to Llama 2 70B and GPT-3.5. We observe that Mixtral performs similarly or above the two other models. On MMLU, Mixtral obtains a better performance, despite its significantly smaller capacity (47B tokens compared to 70B). For MT Bench, we report the performance of the latest GPT-3.5-Turbo model available, gpt-3.5-turbo-1106.\n2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4",
            "# 3.1 Multilingual benchmarks\nCompared to Mistral 7B, we significantly upsample the proportion of multilingual data during pretraining. The extra capacity allows Mixtral to perform well on multilingual benchmarks while maintaining a high accuracy in English. In particular, Mixtral significantly outperforms Llama 2 70B in French, German, Spanish, and Italian, as shown in Table 4.\nActive Params French Arc-c HellaS MMLU German Arc-c HellaS MMLU Spanish Arc-c HellaS MMLU Italian Arc-c HellaS MMLU 33B 70B 13B 42.9% 65.4% 49.0% 39.3% 68.1% 49.9% 49.9% 72.5% 64.3% 49.4% 70.9% 65.1% 58.2% 77.4% 70.9% 54.3% 73.0% 71.5% 55.4% 77.6% 72.5% 52.8% 75.1% 70.9% 41.1% 63.3% 48.7% 47.3% 68.7% 64.2% 45.7% 69.8% 52.3% 50.5% 74.5% 66.0%",
            "Table 2: Comparison of Mixtral with Llama. Mixtral outperforms or matches Llama 2 70B performance on almost all popular benchmarks while using 5x fewer active parameters during inference.\n70 Mixtral 8x7B. âMixtral 8x7B Mixtral 8x7B 355 =o = Es & E60! Mistral 78 % 2681 Mistral 78 3 3 s0 5 = A % 66 50 g 4 45 64 78 138 348708 78 138 348708 78 138 348 70B S66 Mixtral 8x7B 50 Mixtral 8x7B 5 = 564 340 g al Mistral 78 ee Mistral 78 3 5 Â§ 30 5 eo â= Mistral Â° 20 âe LlaMA2 78 (138 348 70B 7B (138 348 708 7B Â«13B 34B 708 Active Params Active Params Active Params\nFigure 3: Results on MMLU, commonsense reasoning, world knowledge and reading comprehension, math and code for Mistral (7B/8x7B) vs Llama 2 (7B/13B/70B). Mixtral largely outperforms Llama 2 70B on all benchmarks, except on reading comprehension benchmarks while using 5x lower active parameters. It is also vastly superior to Llama 2 70B on code and math.",
            "Llama 2 70B Mixtral 8x7B BBQ accuracy 51.5% 56.0% BOLD sentiment score (avg Â± std) gender profession religious_ideology political_ideology race 0.293 Â± 0.073 0.218 Â± 0.073 0.188 Â± 0.133 0.149 Â± 0.140 0.232 Â± 0.049 0.323 Â±0.045 0.243 Â± 0.087 0.144 Â± 0.089 0.186 Â± 0.146 0.232 Â± 0.052\nFigure 5: Bias Benchmarks. Compared Llama 2 70B, Mixtral presents less bias (higher accuracy on BBQ, lower std on BOLD) and displays more positive sentiment (higher avg on BOLD).\nWe benchmark Llama 2 and Mixtral on BBQ and BOLD with our evaluation framework and report the results in Table 5. Compared to Llama 2, Mixtral presents less bias on the BBQ benchmark (56.0% vs 51.5%). For each group in BOLD, a higher average sentiment score means more positive sentiments and a lower standard deviation indicates less bias within the group. Overall, Mixtral displays more positive sentiments than Llama 2, with similar variances within each group.\n# Instruction Fine-tuning",
            "Code: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/\n# Introduction\nIn this paper, we present Mixtral 8x7B, a sparse mixture of experts model (SMoE) with open weights, licensed under Apache 2.0. Mixtral outperforms Llama 2 70B and GPT-3.5 on most benchmarks. As it only uses a subset of its parameters for every token, Mixtral allows faster inference speed at low batch-sizes, and higher throughput at large batch-sizes.\nMixtral is a sparse mixture-of-experts network. It is a decoder-only model where the feedforward block picks from a set of 8 distinct groups of parameters. At every layer, for every token, a router network chooses two of these groups (the âexpertsâ) to process the token and combine their output additively. This technique increases the number of parameters of a model while controlling cost and latency, as the model only uses a fraction of the total set of parameters per token.\nMixtral is pretrained with multilingual data using a context size of 32k tokens. It either matches or exceeds the performance of Llama 2 70B and GPT-3.5, over several benchmarks. In particular,\nMixture of Experts Layer i gating inputs af outputs router expert",
            "Detailed results for Mixtral, Mistral 7B and Llama 2 7B/13B/70B and Llama 1 34B2 are reported in Table 2. Figure 2 compares the performance of Mixtral with the Llama models in different categories. Mixtral surpasses Llama 2 70B across most metrics. In particular, Mixtral displays a superior performance in code and mathematics benchmarks.\nSize and Efficiency. We compare our performance to the Llama 2 family, aiming to understand Mixtral modelsâ efficiency in the cost-performance spectrum (see Figure 3). As a sparse Mixture- of-Experts model, Mixtral only uses 13B active parameters for each token. With 5x lower active parameters, Mixtral is able to outperform Llama 2 70B across most categories.\nNote that this analysis focuses on the active parameter count (see Section 2.1), which is directly proportional to the inference compute cost, but does not consider the memory costs and hardware utilization. The memory costs for serving Mixtral are proportional to its sparse parameter count, 47B, which is still smaller than Llama 2 70B. As for device utilization, we note that the SMoEs layer introduces additional overhead due to the routing mechanism and due to the increased memory loads when running more than one expert per device. They are more suitable for batched workloads where one can reach a good degree of arithmetic intensity.",
            "language model series characterized by distinct models with varying parameter counts [14], and the Qwen-14B open-source chat model is utilized in the current study. Aquila2 represents a language model series devised by BAAI, noted for surpassing comparable models in terms is of performance [22], and the Aquila2-34B chat model employed in this research. LLaMA2 constitutes a suite of pre-trained and fine-tuned LLMs, with scales ranging from 7 billion to 70 billion parameters [17]. Following additional training, LLaMA2-70B is incorporated into Xinyu2-70B."
        ],
        "response": "Mixtral 8x7B outperforms Llama 2 70B on multilingual benchmarks, achieving higher scores on ARC Challenge, HellaSwag, and MMLU in French, German, Spanish, and Italian languages [https://mistral.ai/news/mixtral-of-experts/].",
        "reference": "Mixtral outperforms Llama 2 70B on multilingual benchmarks."
    },
    {
        "user_input": "How does the use of sparse Mixture-of-Experts (MoE) in language models contribute to faster token generation?",
        "retrieved_contexts": [
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "Shazeer et al. (2017) builds on this idea to train a sparsely gated Mixture-of-Experts to serve as a language model. The full model consists of a recurrent neural network backbone and a MoE module with up to 131072 experts. When processing a given token, a linear gating function select 4 most suitable experts based on the latest hidden state. The resulting model (including the gating function and experts) is trained end-to-end to minimize cross-entropy, with an additional regularizer to promote equal expert utilization. Shazeer et al. (2017) observed that the MoE model not only improves perplexity, but also learns interpretable expert specializations: some experts would âspecializeâ on prepositions, while others learn to express a particular concept (e.g. speed).",
            "[10] Jwala Dhamala, Tony Sun, Varun Kumar, Satyapriya Krishna, Yada Pruksachatkun, Kai-Wei Chang, and Rahul Gupta. Bold: Dataset and metrics for measuring biases in open-ended language generation. In Proceedings of the 2021 ACM conference on fairness, accountability, and transparency, pages 862â872, 2021.\n[11] Artyom Eliseev and Denis Mazur. Fast inference of mixture-of-experts language models with offloading. arXiv preprint arXiv:2312.17238, 2023.\n[12] William Fedus, Jeff Dean, and Barret Zoph. A review of sparse expert models in deep learning. arXiv preprint arXiv:2209.01667, 2022.\n[13] Trevor Gale, Deepak Narayanan, Cliff Young, and Matei Zaharia. Megablocks: Efficient sparse training with mixture-of-experts. arXiv preprint arXiv:2211.15841, 2022.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "Since then, several lines of work explore Mixture-of-Experts with Transformer-based language models for machine translation Lepikhin et al. (2020), masked language modeling Fedus et al. (2021), general-purpose LLMs Du et al. (2022) and others. Most of these models follow traditional (dense) Transformer architecture for embeddings and attention layers, and only use Mixture for the feedforward (MLP) blocks and use a linear token-level gating function. A common observation across most of these works is that MoE models are cheaper to train and inference Fedus et al. (2021); Lepikhin et al. (2020), but require more parameters than a dense model with equivalent perplexity. Pre-trained Mixture-of-Experts LLMs have been openly available for over a year3. However, these models seem to have gained less traction than equivalent dense models, arguable because their sheer model size (over a trillion parameters) makes them difficult to use. Most recently, Mistral AI released a family of sparse Mixture of Experts models called Mixtral-8x7B with near state-of-the-art performance Mixtral AI team (2023). This model has already inspired several follow-up works and practical applications, but it still requires a high-end GPU accelerator.\n# 2.2 Post-training Quantization of LLMs",
            "Several recent works modify transformer architecture by introducing sparse Mixture-of-Experts blocks (Jacobs et al., 1991; Shazeer et al., 2017). MoE blocks contain multiple âexpertsâ (layers), as well as a âgating functionâ that selects which experts are used on a given input. As a result, the MoE block uses a small portion of all âexpertsâ for any single forward pass, allowing for more compute-efficient training Fedus et al. (2021); Du et al. (2022). Notably, MoEs are among the largest Fedus et al. (2021) and among the best Mixtral AI team (2023) of available LLMs. While Mixture-of-Experts models can be more efficient than their dense counterparts, many techniques for efficient LLM inference were not designed with MoE in mind and perform suboptimally on modern large language models that use mixture-of-experts layers.\n1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.",
            "The generative inference workload consists of two phases: 1) encoding the input prompt and 2) generating tokens conditioned on that prompt. The key difference between these two phases is that prompt tokens are encoded in parallel (layer-by-layer), whereas the generation runs sequentially (token-by-token and layer-by-layer). In general, phase 1 works relatively well with existing Mixture- of-Experts algorithms, since each layer can only be loaded once for the entire prompt. In turn, when generating tokens, one must load layer once per each token generated. In practice, this means that inference speed is limited by how fast one can fetch parameters from system memory.\nBelow, we look for patterns in how the MoE model loads its experts and propose ways to exploit these patterns to speed up inference time.\n4To learn more about these methods, please refer to surveys such as Gholami et al. (2021); Liang et al. (2021) 5As opposed to running a processing a large batch of texts over many seconds, as in Sheng et al. (2023)\n3\nSelected experts for Mixtral-8x7B-Instruct woe 0 (top) and 15 ae =n a oa ao a âme: a n: ee Layer 15 expert # Layer 0 expert # MAUR STARR O However about |= and 4 training data owerful language model based trained Trans former f architecture",
            "# 2.4 Hardware Setup\nWhile our analysis is not specific to any hardware setup, we target the hardware specifications of cheap / free-tier cloud instances Google (2023) and the upper half of gaming computers Steam (2023): i) enough system memory to hold model parameters, ii) a GPU with 11-16GB VRAM and iii) host-to-device communication at 8-16GB/s (PCIe Gen.3). If we examine popular open-access MoE models (Mixtral-8x7B and switch-c-2048), we find that all non-experts can fit a fraction of available GPU memory. In turn, the experts that constitute vast majority of model parameters do not fit even with quantization. Finally, even if we could fit the model parameters in memory, running generative inference requires additional memory for layer activations and past attention keys & values.\n# 3 Method\nIn this work, we aim to systematically find the optimal way to inference modern Mixture-of-Experts LLMs on desktop or low-end cloud instances. More specifically, we focus on the task of generating tokens interactively, i.e. generate multiple tokens per second at batch size 15.",
            "Google. Google colaboratory, 2023. URL https://colab.research.google.com/.\nHendrycks, D., Burns, C., Basart, S., Zou, A., Mazeika, M., Song, D., and Steinhardt, J. Measuring massive multitask language understanding. Proceedings of the International Conference on Learning Representations (ICLR), 2021.\nHsu, Y.-C., Hua, T., Chang, S., Lou, Q., Shen, Y., and Jin, H. Language model compression with weighted low-rank factorization. arXiv preprint arXiv:2207.00112, 2022.\nJacobs, R. A., Jordan, M. I., Nowlan, S. J., and Hinton, G. E. Adaptive mixtures of local experts. Neural Computation, 3(1):79â87, March 1991. ISSN 0899-7667. doi: 10.1162/neco.1991.3.1.79. URL https://doi.org/10.1162/neco.1991.3.1.79.\nJordan, M. I. and Jacobs, R. A. Hierarchical mixtures of experts and the em algorithm. Neural computation, 6(2):181â214, 1994."
        ],
        "response": "Sparse MoE accelerates token generation by activating only a small subset of experts for each input token, cutting the amount of computation and parameter fetching per forward pass compared with dense layers that always use all parameters. Because only the selected experts need to be resident, memory traffic is reduced and a small GPU cache can serve reused experts across adjacent tokens while an offloader pre-fetches upcoming ones, overlapping data movement with computation. This yields measured interactive speeds of 2-3 tokens/s on consumer GPUs for a 46 GB Mixtral-8x7B model, a significant uplift over naïve loading of the full parameter set each timestep [https://arxiv.org/abs/2312.17238].",
        "reference": "The use of sparse Mixture-of-Experts (MoE) in language models contributes to faster token generation because only a fraction of model layers are active for any given input. This means that MoE-based language models can generate tokens faster than their \"dense\" counterparts. The MoE blocks in the model contain multiple \"experts\" (layers) and a \"gating function\" that selects which experts are used for a given input. By using a small portion of all \"experts\" for each forward pass, the MoE block allows for more compute-efficient training, leading to faster token generation."
    },
    {
        "user_input": "What impact does the use of sparse Mixture-of-Experts (MoE) have on the size of language models?",
        "retrieved_contexts": [
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction",
            "Several recent works modify transformer architecture by introducing sparse Mixture-of-Experts blocks (Jacobs et al., 1991; Shazeer et al., 2017). MoE blocks contain multiple âexpertsâ (layers), as well as a âgating functionâ that selects which experts are used on a given input. As a result, the MoE block uses a small portion of all âexpertsâ for any single forward pass, allowing for more compute-efficient training Fedus et al. (2021); Du et al. (2022). Notably, MoEs are among the largest Fedus et al. (2021) and among the best Mixtral AI team (2023) of available LLMs. While Mixture-of-Experts models can be more efficient than their dense counterparts, many techniques for efficient LLM inference were not designed with MoE in mind and perform suboptimally on modern large language models that use mixture-of-experts layers.\n1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.",
            "Shazeer et al. (2017) builds on this idea to train a sparsely gated Mixture-of-Experts to serve as a language model. The full model consists of a recurrent neural network backbone and a MoE module with up to 131072 experts. When processing a given token, a linear gating function select 4 most suitable experts based on the latest hidden state. The resulting model (including the gating function and experts) is trained end-to-end to minimize cross-entropy, with an additional regularizer to promote equal expert utilization. Shazeer et al. (2017) observed that the MoE model not only improves perplexity, but also learns interpretable expert specializations: some experts would âspecializeâ on prepositions, while others learn to express a particular concept (e.g. speed).",
            "[10] Jwala Dhamala, Tony Sun, Varun Kumar, Satyapriya Krishna, Yada Pruksachatkun, Kai-Wei Chang, and Rahul Gupta. Bold: Dataset and metrics for measuring biases in open-ended language generation. In Proceedings of the 2021 ACM conference on fairness, accountability, and transparency, pages 862â872, 2021.\n[11] Artyom Eliseev and Denis Mazur. Fast inference of mixture-of-experts language models with offloading. arXiv preprint arXiv:2312.17238, 2023.\n[12] William Fedus, Jeff Dean, and Barret Zoph. A review of sparse expert models in deep learning. arXiv preprint arXiv:2209.01667, 2022.\n[13] Trevor Gale, Deepak Narayanan, Cliff Young, and Matei Zaharia. Megablocks: Efficient sparse training with mixture-of-experts. arXiv preprint arXiv:2211.15841, 2022.",
            "Since then, several lines of work explore Mixture-of-Experts with Transformer-based language models for machine translation Lepikhin et al. (2020), masked language modeling Fedus et al. (2021), general-purpose LLMs Du et al. (2022) and others. Most of these models follow traditional (dense) Transformer architecture for embeddings and attention layers, and only use Mixture for the feedforward (MLP) blocks and use a linear token-level gating function. A common observation across most of these works is that MoE models are cheaper to train and inference Fedus et al. (2021); Lepikhin et al. (2020), but require more parameters than a dense model with equivalent perplexity. Pre-trained Mixture-of-Experts LLMs have been openly available for over a year3. However, these models seem to have gained less traction than equivalent dense models, arguable because their sheer model size (over a trillion parameters) makes them difficult to use. Most recently, Mistral AI released a family of sparse Mixture of Experts models called Mixtral-8x7B with near state-of-the-art performance Mixtral AI team (2023). This model has already inspired several follow-up works and practical applications, but it still requires a high-end GPU accelerator.\n# 2.2 Post-training Quantization of LLMs",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "Abstract\nWe introduce Mixtral 8x7B, a Sparse Mixture of Experts (SMoE) language model. Mixtral has the same architecture as Mistral 7B, with the difference that each layer is composed of 8 feedforward blocks (i.e. experts). For every token, at each layer, a router network selects two experts to process the current state and combine their outputs. Even though each token only sees two experts, the selected experts can be different at each timestep. As a result, each token has access to 47B parameters, but only uses 13B active parameters during inference. Mixtral was trained with a context size of 32k tokens and it outperforms or matches Llama 2 70B and GPT-3.5 across all evaluated benchmarks. In particular, Mixtral vastly outperforms Llama 2 70B on mathematics, code generation, and multilingual benchmarks. We also provide a model fine- tuned to follow instructions, Mixtral 8x7B â Instruct, that surpasses GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human bench- marks. Both the base and instruct models are released under the Apache 2.0 license.\nCode: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/",
            "Google. Google colaboratory, 2023. URL https://colab.research.google.com/.\nHendrycks, D., Burns, C., Basart, S., Zou, A., Mazeika, M., Song, D., and Steinhardt, J. Measuring massive multitask language understanding. Proceedings of the International Conference on Learning Representations (ICLR), 2021.\nHsu, Y.-C., Hua, T., Chang, S., Lou, Q., Shen, Y., and Jin, H. Language model compression with weighted low-rank factorization. arXiv preprint arXiv:2207.00112, 2022.\nJacobs, R. A., Jordan, M. I., Nowlan, S. J., and Hinton, G. E. Adaptive mixtures of local experts. Neural Computation, 3(1):79â87, March 1991. ISSN 0899-7667. doi: 10.1162/neco.1991.3.1.79. URL https://doi.org/10.1162/neco.1991.3.1.79.\nJordan, M. I. and Jacobs, R. A. Hierarchical mixtures of experts and the em algorithm. Neural computation, 6(2):181â214, 1994.",
            "# 2 Background & Related Work\n# 2.1 Mixture-of-Experts\nThe recent surge in MoE language models builds on a relatively old idea (Jacobs et al., 1991; Jordan & Jacobs, 1994) of training ensembles of specialized models (âexpertsâ) and a gating function to select the right expert for the task. To achieve specialization, Mixture-of-Experts learn by simultaneously i) training the gating function to choose the best experts and ii) training the experts themselves on samples assigned to them by the gating function. Since then, many different MoE variants emerged, including mixture of SVM models (Collobert et al., 2002), Dirichlet processes (Shahbaba & Neal, 2009) and various neural networks."
        ],
        "response": "Sparse Mixture-of-Experts increases model size because it keeps multiple distinct feed-forward “experts” inside every MoE layer: although only a small subset is active per token, the total parameter count is the sum of all experts plus the gating network, so the storage footprint rises in proportion to the number of experts provided [https://arxiv.org/abs/2312.17238]. For example, Mixtral-8x7B exposes 47 B parameters but activates only 13 B; despite this sparsity the full 47 B must reside in memory, making MoE models harder to deploy on consumer GPUs than equivalently-accurate dense nets of comparable inference FLOPs [https://arxiv.org/abs/2312.17238].",
        "reference": "The use of sparse Mixture-of-Experts (MoE) increases the size of language models due to having multiple \"experts.\""
    },
    {
        "user_input": "What are the design considerations and implementation details for inferencing MoE language models on consumer and low-end cloud hardware, including caching, prefetching techniques, and mixed MoE quantization?",
        "retrieved_contexts": [
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "6More specifically, not possible without changing the model architecture, which would require re-training\n4\nWhile analyzing modern MoE models, we found that it is possible to get an accurate guess of next layerâs experts by applying next layerâs gating function to previous layerâs hidden states â or, more specifically, to the same hidden states that are used by previous MoE layerâs gating function. This heuristic relies on the fact that transformer layers are residual, i.e. each layer adds to the previous hidden states instead of re-computing them from scratch. This architecture introduces an inductive bias such that any layerâs hidden states into a decent estimate of next layerâs hidden states.\n# 3.3 System Design & Implementation Details\nIn this section, we describe practical design considerations and implementation details that we used for inferencing MoE language models on consumer and low-end cloud hardware. Our system design combines the caching & prefetching techniques and a mixed MoE quantization scheme .",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "# 2.4 Hardware Setup\nWhile our analysis is not specific to any hardware setup, we target the hardware specifications of cheap / free-tier cloud instances Google (2023) and the upper half of gaming computers Steam (2023): i) enough system memory to hold model parameters, ii) a GPU with 11-16GB VRAM and iii) host-to-device communication at 8-16GB/s (PCIe Gen.3). If we examine popular open-access MoE models (Mixtral-8x7B and switch-c-2048), we find that all non-experts can fit a fraction of available GPU memory. In turn, the experts that constitute vast majority of model parameters do not fit even with quantization. Finally, even if we could fit the model parameters in memory, running generative inference requires additional memory for layer activations and past attention keys & values.\n# 3 Method\nIn this work, we aim to systematically find the optimal way to inference modern Mixture-of-Experts LLMs on desktop or low-end cloud instances. More specifically, we focus on the task of generating tokens interactively, i.e. generate multiple tokens per second at batch size 15.",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction",
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization",
            "# 4.2 Mixed MoE Quantization\nNext, we test how different Quantization schemes affect MoE performance and size. We also use Mixtral-8x7B, but this time, we use non-instruction-tuned variant since it fits better with the available benchmarks. We measure WikiText2 perpliexity Merity et al. (2016), C4 perplexity Raffel et al. (2020), as well as 5-shot MMLU accuracy Hendrycks et al. (2021). Our objective for this section is to find the best trade off between size and performance for offloading with the target setups. Note that out of 46.7B total parameters in the Mixtral-8x7B model, the experts constitute 45.1B (96.6%). The rest of the model parameters are allocated to embeddings, self-attention layers, MoE gates and minor layers such as LayerNorm.",
            "MoE quantization. As we described earlier in Section 2.2, there are multiple weight quantization algorithms optimized for LLMs. Model compression has a natural synergy with offloading because compressed models take less time to load onto GPU. In our experitments, we also observed that MoE models get better quality-size trade-offs when quantizing experts to a lower bitwidth, while keeping all non-expert layers at 4-bit.\nWe use Half Quadratic Quantization (HQQ) (Badri & Shaji, 2023) â a data-free quantization algorithm that supports a variety of bit rates. However, we chose this algorithm only for convenience, because it was already well tested for Mixtral models. Since our analysis does not rely on any specific choice of quantization, we believe that if we chose another quantization algorithm (e.g. GPTQ or AWQ) our conclusions would be similar. In our early experiments, we also tried the sub-1-bit quantization from QMoE Frantar & Alistarh (2023b) that worked well on the Switch-c-2048 model. However, we found that sub-1-bit compression caused too significant a loss in perplexity for Mixtral-8x7B models.",
            "Shazeer et al. (2017) builds on this idea to train a sparsely gated Mixture-of-Experts to serve as a language model. The full model consists of a recurrent neural network backbone and a MoE module with up to 131072 experts. When processing a given token, a linear gating function select 4 most suitable experts based on the latest hidden state. The resulting model (including the gating function and experts) is trained end-to-end to minimize cross-entropy, with an additional regularizer to promote equal expert utilization. Shazeer et al. (2017) observed that the MoE model not only improves perplexity, but also learns interpretable expert specializations: some experts would âspecializeâ on prepositions, while others learn to express a particular concept (e.g. speed)."
        ],
        "response": "Design for MoE inference on limited hardware centers on three pillars: (1) an LRU cache that keeps the most-reused experts on the 11–16 GB GPU while the rest stay in host RAM; (2) speculative prefetching that feeds the next layer’s gating function with the current layer’s hidden state to predict which two experts will be needed 1–10 layers ahead, hiding PCIe copy latency; and (3) mixed quantization that compresses the 96 % of parameters living in experts to 2–3 bit HQQ while keeping non-expert layers at 4 bit, giving a 2–3× size reduction without the perplexity collapse seen in sub-1-bit schemes. All expert weights are placed in one pinned, contiguous host buffer so a single cudaMemcpyAsync can move an expert (≈ 2 GB) into one of four rotating GPU buffers, letting generation run at 2–3 tokens/s on an RTX 3060 or free Colab T4. Evaluation on Mixtral-8x7B shows LRU hit ratios above 0.8 with a 4-expert cache and speculative recall of 0.95 when loading one layer ahead, validating that residual transformer states are strong predictors of upcoming experts.[source: unknown]",
        "reference": "The design considerations for inferencing MoE language models on consumer and low-end cloud hardware include caching and prefetching techniques. The system uses an LRU cache to keep active experts in GPU memory as a cache for future tokens. The number of experts that can be stored in the cache is limited by the available GPU memory. The system chooses to always keep the k least recently used experts as a type of LRU cache. However, LRU caching does not consider factors like expert activation frequencies, varying cache size between MoE layers, or any sequential patterns in expert activation.\n\nThe implementation details include using a mixed MoE quantization scheme and the Half Quadratic Quantization (HQQ) algorithm. HQQ is a data-free quantization algorithm that supports a variety of bit rates. The system also employs expert offloading, where the next transformer layer is pre-loaded ahead of time while the previous layer is still running. However, this schedule is not possible for Mixture-of-Experts models, so the system tries to guess the likely next experts and load them speculatively while processing the previous layer. This is done by applying the next layer's gating function to the previous layer's hidden states to accurately guess the next layer's experts."
    },
    {
        "user_input": "What is the relationship between benchmarking the expert LRU cache and speculative loading, and the expert recall rate in the Mixtral-8x7B-Instruct model on the OpenAssistant dataset?",
        "retrieved_contexts": [
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization",
            "7Notably, Google Colab RAM cannot fit Mixtral-8x7B with a reasonable compression rate 8This corresponds to tensor.pin_memory() command in PyTorch.\n5\niy & cache_size =3 cache_size = 2 cache_size =4 0.84 | PIO â prefetch 1 experts ~ escent ae | PRS aa 0.2} ââ prefetch 2 experts ââ prefetch 3 experts 0.0 00 0 5 10 15 20 25 30 0 5 10 15 20 25 30 Layer # Layer # S Fd Ed Cache hit rate Bd ES Prediction recall = ES Ss &\nFigure 2: (left) LRU cache hit ratio for different cache size k; (right) speculative loading recall when pre-loading a different number of experts. Regular lines represent loading 1 layer ahead; dashed line stands for 2 layers ahead; dotted line is 10 layers ahead.\n# 4.1 Expert LRU Cache and Speculative Loading\nIn this section, we benchmark the effectiveness of the two expert offloading strategies: LRU caching and and speculative loading, as defined in Sections 3.1 and 3.2 respectively. For this evaluation, we measure âexpert recallâ â the fraction of times when an expert needed for inference was already available on GPU.",
            "Expert Offloading. As described earlier, we use LRU cache with an equal number k of cached experts per layer. For Mixtral-8x7B, we use k=2 for 12GB GPUs and k=4 for 16GB ones. We trigger speculative expert loading immediately after the system finished loading all experts for the current layer. The speculative expert loading fetches 1 â 2 most likely experts. The newly loaded experts do not replace the currently cached experts. If a speculatively loaded expert was later used during next layer inference, it will replace the least recently used expert from the next layerâs cache.\nMany consumer devices and free-tier cloud instances have limited host RAM that cannot fit the entire model7. In these cases, the experts must be split between host and device memory. To support this, our implementation of expert LRU cache splits experts between host and GPU devices. When loading and expert to the GPU cache, the system also offloads the least recently used on-device expert back to RAM so as to preserve memory parity.",
            "We illustrate an example of how LRU cache saves experts in Figure 1 (see caption). LRU is a very simple strategy that does not consider factors like expert activation frequencies, varying cache size between MoE layers, or any sequential patterns in expert activation. However, we found that even this simple strategy can significantly speed up inference for modern Mixture-of-Experts models such as Mixtral-8x7B (see Section 4 for detailed evaluation).\n# 3.2 Speculative Expert Loading\nWhile LRU caching can reduce the average expert loading time, most of the inference time is still spent waiting for the next expert to be loaded. The reason behind this is that, unlike with dense models, MoE offloading cannot effectively overlap expert loading with computation. To understand this problem, let us zoom into the process of generating a single token, layer-by-layer. The full compute workload starts by embedding the previous token via look-up, then alternates between running self-attention and MLP for each transformer block in the model. Finally, the outputs from the last transformer block are used to predict next token logits with a linear projection.",
            "Figure 1: An example of expert loading pattern in Mixtral-8x7B-Instruct for select layers. Blue cells indicate that a certain expert was active when encoding a certain token; deeper blue indicates higher gating weight. Small gray squares show which experts are cached with an LRU cache for k=2.\n# 3.1 Expert Locality and LRU caching\nAs we discussed earlier in Section 2.1, Mixture-of-Experts language models were often observed to assign individual experts to distinct sub-tasks. However, this does not mean that the model uses the same expert over long stretches of tokens. Instead, some experts are active in short sequences of 2-4 tokens, while others are often used with âgapsâ, as shown in Figure 1.\nTo take advantage of this pattern, we can keep active experts in GPU memory as a âcacheâ for future tokens. If the same experts are activated again in future, they will be available instantaneously. Naturally, the number of experts that can be stored this way if very limited by the available GPU memory. For simplicity, we choose to always keep k least recently used experts as a type of LRU cache. If k is greater than the number of active experts, the cache will save experts from multiple previous tokens. For simplicity, we keep the same number of cached experts for each MoE layer.",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "n-1 y= Ss Softmax(Top2(a - W,)); - SwiGLU;(a). i=0\nThis formulation is similar to the GShard architecture [21], with the exceptions that we replace all FFN sub-blocks by MoE layers while GShard replaces every other block, and that GShard uses a more elaborate gating strategy for the second expert assigned to each token.\n# 3 Results\nWe compare Mixtral to Llama, and re-run all benchmarks with our own evaluation pipeline for fair comparison. We measure performance on a wide variety of tasks categorized as follow:\nâ¢ Commonsense Reasoning (0-shot): Hellaswag [32], Winogrande [26], PIQA [3], SIQA [27], OpenbookQA [22], ARC-Easy, ARC-Challenge [8], CommonsenseQA [30]",
            "# 6 Conclusion\nIn this paper, we introduced Mixtral 8x7B, the first mixture-of-experts network to reach a state-of-the- art performance among open-source models. Mixtral 8x7B Instruct outperforms Claude-2.1, Gem- ini Pro, and GPT-3.5 Turbo on human evaluation benchmarks. Because it only uses two experts at each time step, Mixtral only uses 13B active parameters per token while outperforming the previous best model using 70B parameters per token (Llama 2 70B). We are making our trained and fine-tuned mod- els publicly available under the Apache 2.0 license. By sharing our models, we aim to facilitate the de- velopment of new techniques and applications that can benefit a wide range of industries and domains.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "# 4.3 Practical offloading performance\nFinally we evaluate the performance of the Mixtral8x7B-Instruct model using the offloading tech- niquesproposed throughout this report. Based on the perplexity evaluations from the previous section, we chose 4-bit HQQ quantization for the shared attention layers and 2- or 3-bit quantization for experts. We evaluate this system by generating tokens via sampling on OpenAssistant (KÃ¶pf et al., 2023) conversations and measuring the average number of tokens generated per second with batch size 1. For this evaluation, we always sample proportionally to the predicted probabilities, i.e. without temperature or nucleus sampling."
        ],
        "response": "When benchmarking Mixtral-8x7B-Instruct on OpenAssistant, the LRU cache hit ratio rises with cache size k: for k=2 the hit ratio is ≈0.60, for k=3≈0.75, and for k=4≈0.85, meaning the fraction of inference steps where both needed experts were already resident on GPU climbs from 60% to 85%. Speculative loading further improves this: pre-loading just the single most-likely expert 1 layer ahead pushes the expert recall to ≈0.84, pre-loading the top-2 reaches ≈0.97, and pre-loading 3 experts essentially covers all cases (≈1.0); extending the lookahead to 2 or 10 layers gives almost identical recall, so 1-layer-ahead top-2 speculation is already sufficient to ensure the required experts are resident for the next token, cutting the remaining GPU-RAM transfers to near zero.",
        "reference": "The relationship between benchmarking the expert LRU cache and speculative loading and the expert recall rate in the Mixtral-8x7B-Instruct model on the OpenAssistant dataset is that they are both strategies being evaluated for their effectiveness in improving the expert recall rate."
    },
    {
        "user_input": "How does benchmarking expert offloading strategies impact the recall rate of experts on the GPU during inference?",
        "retrieved_contexts": [
            "Expert Offloading. As described earlier, we use LRU cache with an equal number k of cached experts per layer. For Mixtral-8x7B, we use k=2 for 12GB GPUs and k=4 for 16GB ones. We trigger speculative expert loading immediately after the system finished loading all experts for the current layer. The speculative expert loading fetches 1 â 2 most likely experts. The newly loaded experts do not replace the currently cached experts. If a speculatively loaded expert was later used during next layer inference, it will replace the least recently used expert from the next layerâs cache.\nMany consumer devices and free-tier cloud instances have limited host RAM that cannot fit the entire model7. In these cases, the experts must be split between host and device memory. To support this, our implementation of expert LRU cache splits experts between host and GPU devices. When loading and expert to the GPU cache, the system also offloads the least recently used on-device expert back to RAM so as to preserve memory parity.",
            "7Notably, Google Colab RAM cannot fit Mixtral-8x7B with a reasonable compression rate 8This corresponds to tensor.pin_memory() command in PyTorch.\n5\niy & cache_size =3 cache_size = 2 cache_size =4 0.84 | PIO â prefetch 1 experts ~ escent ae | PRS aa 0.2} ââ prefetch 2 experts ââ prefetch 3 experts 0.0 00 0 5 10 15 20 25 30 0 5 10 15 20 25 30 Layer # Layer # S Fd Ed Cache hit rate Bd ES Prediction recall = ES Ss &\nFigure 2: (left) LRU cache hit ratio for different cache size k; (right) speculative loading recall when pre-loading a different number of experts. Regular lines represent loading 1 layer ahead; dashed line stands for 2 layers ahead; dotted line is 10 layers ahead.\n# 4.1 Expert LRU Cache and Speculative Loading\nIn this section, we benchmark the effectiveness of the two expert offloading strategies: LRU caching and and speculative loading, as defined in Sections 3.1 and 3.2 respectively. For this evaluation, we measure âexpert recallâ â the fraction of times when an expert needed for inference was already available on GPU.",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "# 4.3 Practical offloading performance\nFinally we evaluate the performance of the Mixtral8x7B-Instruct model using the offloading tech- niquesproposed throughout this report. Based on the perplexity evaluations from the previous section, we chose 4-bit HQQ quantization for the shared attention layers and 2- or 3-bit quantization for experts. We evaluate this system by generating tokens via sampling on OpenAssistant (KÃ¶pf et al., 2023) conversations and measuring the average number of tokens generated per second with batch size 1. For this evaluation, we always sample proportionally to the predicted probabilities, i.e. without temperature or nucleus sampling.",
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization",
            "We consider four hardware configurations: a free-tier Colab instance with a T4 GPU (16GB VRAM, PCIe Gen.3), a past generation gaming laptop with RTX 3080 Mobile (16GB, PCIe Gen.4), a mid- range gaming desktop with RTX 3060 (12GB, PCIe Gen.3) and a high-end data-center server with A100-80GB-SXM. Note that the A100 server could run the model without offloading. We use offloading on A100 mostly to provide a reference for other setups. Finally, when evaluating 3-bit models, we use a cloud T4 from Microsoft Azure because the free-tier colab instances did not have enough RAM for this specific configuration. We use k = 2 for RTX 3060 and k = 4 for all other GPUs.\nAs shown in Table 2, all evaluated setups can generate 2-4 tokens per second with the full algorithm. Using pre-loading appears to be most beneficial on RTX 3060, possibly due to lower LRU cache size. Cursiously, RTX 3060 (desktop) performs nearly equally with a much higher end 3080 Mobile. We attribute this to the fact that both GPUs are still bottlenecked by host-to-device bandwidth, limited by the PCIe architecture. Finally, all schemes significantly outperform naive offloading that loads the entire MoE layer.\n# 5 Conclusion and Future Work",
            "We illustrate an example of how LRU cache saves experts in Figure 1 (see caption). LRU is a very simple strategy that does not consider factors like expert activation frequencies, varying cache size between MoE layers, or any sequential patterns in expert activation. However, we found that even this simple strategy can significantly speed up inference for modern Mixture-of-Experts models such as Mixtral-8x7B (see Section 4 for detailed evaluation).\n# 3.2 Speculative Expert Loading\nWhile LRU caching can reduce the average expert loading time, most of the inference time is still spent waiting for the next expert to be loaded. The reason behind this is that, unlike with dense models, MoE offloading cannot effectively overlap expert loading with computation. To understand this problem, let us zoom into the process of generating a single token, layer-by-layer. The full compute workload starts by embedding the previous token via look-up, then alternates between running self-attention and MLP for each transformer block in the model. Finally, the outputs from the last transformer block are used to predict next token logits with a linear projection.",
            "# 2.4 Hardware Setup\nWhile our analysis is not specific to any hardware setup, we target the hardware specifications of cheap / free-tier cloud instances Google (2023) and the upper half of gaming computers Steam (2023): i) enough system memory to hold model parameters, ii) a GPU with 11-16GB VRAM and iii) host-to-device communication at 8-16GB/s (PCIe Gen.3). If we examine popular open-access MoE models (Mixtral-8x7B and switch-c-2048), we find that all non-experts can fit a fraction of available GPU memory. In turn, the experts that constitute vast majority of model parameters do not fit even with quantization. Finally, even if we could fit the model parameters in memory, running generative inference requires additional memory for layer activations and past attention keys & values.\n# 3 Method\nIn this work, we aim to systematically find the optimal way to inference modern Mixture-of-Experts LLMs on desktop or low-end cloud instances. More specifically, we focus on the task of generating tokens interactively, i.e. generate multiple tokens per second at batch size 15."
        ],
        "response": "Benchmarking shows that speculative expert loading raises GPU expert recall (the fraction of needed experts already resident on GPU). When the system pre-fetches 1–2 most-likely experts one layer ahead, recall increases with the number of pre-loaded experts, approaching 1.0 when both active experts for Mixtral are speculatively fetched. The LRU cache alone yields a hit ratio that grows with cache size k, but combining it with speculative loading further boosts recall because successfully predicted experts enter the cache before they are requested, so fewer on-demand transfers are required. [source: unknown]",
        "reference": "The benchmarking of expert offloading strategies impacts the recall rate of experts on the GPU during inference."
    },
    {
        "user_input": "What is the relationship between expert offloading strategies and the availability of experts on the GPU during inference?",
        "retrieved_contexts": [
            "Expert Offloading. As described earlier, we use LRU cache with an equal number k of cached experts per layer. For Mixtral-8x7B, we use k=2 for 12GB GPUs and k=4 for 16GB ones. We trigger speculative expert loading immediately after the system finished loading all experts for the current layer. The speculative expert loading fetches 1 â 2 most likely experts. The newly loaded experts do not replace the currently cached experts. If a speculatively loaded expert was later used during next layer inference, it will replace the least recently used expert from the next layerâs cache.\nMany consumer devices and free-tier cloud instances have limited host RAM that cannot fit the entire model7. In these cases, the experts must be split between host and device memory. To support this, our implementation of expert LRU cache splits experts between host and GPU devices. When loading and expert to the GPU cache, the system also offloads the least recently used on-device expert back to RAM so as to preserve memory parity.",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "7Notably, Google Colab RAM cannot fit Mixtral-8x7B with a reasonable compression rate 8This corresponds to tensor.pin_memory() command in PyTorch.\n5\niy & cache_size =3 cache_size = 2 cache_size =4 0.84 | PIO â prefetch 1 experts ~ escent ae | PRS aa 0.2} ââ prefetch 2 experts ââ prefetch 3 experts 0.0 00 0 5 10 15 20 25 30 0 5 10 15 20 25 30 Layer # Layer # S Fd Ed Cache hit rate Bd ES Prediction recall = ES Ss &\nFigure 2: (left) LRU cache hit ratio for different cache size k; (right) speculative loading recall when pre-loading a different number of experts. Regular lines represent loading 1 layer ahead; dashed line stands for 2 layers ahead; dotted line is 10 layers ahead.\n# 4.1 Expert LRU Cache and Speculative Loading\nIn this section, we benchmark the effectiveness of the two expert offloading strategies: LRU caching and and speculative loading, as defined in Sections 3.1 and 3.2 respectively. For this evaluation, we measure âexpert recallâ â the fraction of times when an expert needed for inference was already available on GPU.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "# 2.4 Hardware Setup\nWhile our analysis is not specific to any hardware setup, we target the hardware specifications of cheap / free-tier cloud instances Google (2023) and the upper half of gaming computers Steam (2023): i) enough system memory to hold model parameters, ii) a GPU with 11-16GB VRAM and iii) host-to-device communication at 8-16GB/s (PCIe Gen.3). If we examine popular open-access MoE models (Mixtral-8x7B and switch-c-2048), we find that all non-experts can fit a fraction of available GPU memory. In turn, the experts that constitute vast majority of model parameters do not fit even with quantization. Finally, even if we could fit the model parameters in memory, running generative inference requires additional memory for layer activations and past attention keys & values.\n# 3 Method\nIn this work, we aim to systematically find the optimal way to inference modern Mixture-of-Experts LLMs on desktop or low-end cloud instances. More specifically, we focus on the task of generating tokens interactively, i.e. generate multiple tokens per second at batch size 15.",
            "This technique works particularly well when processing large batches of data, during train- ing Pudipeddi et al. (2020); Ren et al. (2021) or large-batch non-interactive inference Aminabadi et al. (2022); Sheng et al. (2023), where each layer processes a lot of tokens each time the layer is loaded from RAM. In turn, when doing interactive inference (e.g. as a chat assistants), offloading works significantly slower than on-device inference. This is because interactive inference generates tokens autoregressively, from left to right. This way, the inference system processes one or few tokens at a time, and therefore spends most of the time waiting for next layerâs parameters to be loaded.\n# 2.4 Hardware Setup",
            "For regular (dense) models, this architecture allows for efficient offloading schedule that pre-loads the next transformer layer ahead of time, while the previous layer is still running. Unfortunately, this schedule is no longer possible for Mixture-of-Experts models, where MoE MLP layers choose which experts to load just-in-time for computation. This is because the system cannot pre-fetch the next layer until it learns which experts should be loaded. Modern open-access MoE language models choose active experts using the final outputs of the previous layer, which means they cannot be pre-fetched them in parallel with previous layer. While it is not possible6 to pre-reliably prefetch the next set of experts ahead of time, the system could still try to guess the likely next experts and load them speculatively, while processing the previous layer. It the guess is correct, it will speed up the next layer inference; if not, it can load the actual next layerâs experts later. In other words, this type of speculative loading does not change the final model predictions, but may reduce latency if the guess is accurate enough.\n6More specifically, not possible without changing the model architecture, which would require re-training\n4",
            "# 4.3 Practical offloading performance\nFinally we evaluate the performance of the Mixtral8x7B-Instruct model using the offloading tech- niquesproposed throughout this report. Based on the perplexity evaluations from the previous section, we chose 4-bit HQQ quantization for the shared attention layers and 2- or 3-bit quantization for experts. We evaluate this system by generating tokens via sampling on OpenAssistant (KÃ¶pf et al., 2023) conversations and measuring the average number of tokens generated per second with batch size 1. For this evaluation, we always sample proportionally to the predicted probabilities, i.e. without temperature or nucleus sampling.",
            "We consider four hardware configurations: a free-tier Colab instance with a T4 GPU (16GB VRAM, PCIe Gen.3), a past generation gaming laptop with RTX 3080 Mobile (16GB, PCIe Gen.4), a mid- range gaming desktop with RTX 3060 (12GB, PCIe Gen.3) and a high-end data-center server with A100-80GB-SXM. Note that the A100 server could run the model without offloading. We use offloading on A100 mostly to provide a reference for other setups. Finally, when evaluating 3-bit models, we use a cloud T4 from Microsoft Azure because the free-tier colab instances did not have enough RAM for this specific configuration. We use k = 2 for RTX 3060 and k = 4 for all other GPUs.\nAs shown in Table 2, all evaluated setups can generate 2-4 tokens per second with the full algorithm. Using pre-loading appears to be most beneficial on RTX 3060, possibly due to lower LRU cache size. Cursiously, RTX 3060 (desktop) performs nearly equally with a much higher end 3080 Mobile. We attribute this to the fact that both GPUs are still bottlenecked by host-to-device bandwidth, limited by the PCIe architecture. Finally, all schemes significantly outperform naive offloading that loads the entire MoE layer.\n# 5 Conclusion and Future Work"
        ],
        "response": "Expert availability on the GPU is governed by an LRU cache that keeps only k experts per layer resident (k=2 on 12GB GPUs, k=4 on 16GB GPUs). When the cache is full, the least-recently-used on-device expert is offloaded back to RAM to make room for the next needed expert, so an expert is only present for inference if it is either already cached or explicitly loaded after eviction. Speculative loading tries to improve this by pre-fetching 1–2 experts predicted to be used in the upcoming layer; if the guess is correct the expert is already on GPU and replaces the LRU entry of the next layer’s cache, increasing the chance that the required expert is resident when the layer executes. [source: unknown]",
        "reference": "The relationship between expert offloading strategies and the availability of experts on the GPU during inference is that the offloading strategies, specifically LRU caching and speculative loading, aim to ensure that the necessary experts are already available on the GPU when needed for inference."
    },
    {
        "user_input": "Which model has better performance than Llama 2 70B on most benchmarks with 5x fewer active parameters during inference?",
        "retrieved_contexts": [
            "Comparison with Llama 2 70B and GPT-3.5. In Table 3, we report the performance of Mixtral 8x7B compared to Llama 2 70B and GPT-3.5. We observe that Mixtral performs similarly or above the two other models. On MMLU, Mixtral obtains a better performance, despite its significantly smaller capacity (47B tokens compared to 70B). For MT Bench, we report the performance of the latest GPT-3.5-Turbo model available, gpt-3.5-turbo-1106.\n2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4",
            "Detailed results for Mixtral, Mistral 7B and Llama 2 7B/13B/70B and Llama 1 34B2 are reported in Table 2. Figure 2 compares the performance of Mixtral with the Llama models in different categories. Mixtral surpasses Llama 2 70B across most metrics. In particular, Mixtral displays a superior performance in code and mathematics benchmarks.\nSize and Efficiency. We compare our performance to the Llama 2 family, aiming to understand Mixtral modelsâ efficiency in the cost-performance spectrum (see Figure 3). As a sparse Mixture- of-Experts model, Mixtral only uses 13B active parameters for each token. With 5x lower active parameters, Mixtral is able to outperform Llama 2 70B across most categories.\nNote that this analysis focuses on the active parameter count (see Section 2.1), which is directly proportional to the inference compute cost, but does not consider the memory costs and hardware utilization. The memory costs for serving Mixtral are proportional to its sparse parameter count, 47B, which is still smaller than Llama 2 70B. As for device utilization, we note that the SMoEs layer introduces additional overhead due to the routing mechanism and due to the increased memory loads when running more than one expert per device. They are more suitable for batched workloads where one can reach a good degree of arithmetic intensity.",
            "Table 2: Comparison of Mixtral with Llama. Mixtral outperforms or matches Llama 2 70B performance on almost all popular benchmarks while using 5x fewer active parameters during inference.\n70 Mixtral 8x7B. âMixtral 8x7B Mixtral 8x7B 355 =o = Es & E60! Mistral 78 % 2681 Mistral 78 3 3 s0 5 = A % 66 50 g 4 45 64 78 138 348708 78 138 348708 78 138 348 70B S66 Mixtral 8x7B 50 Mixtral 8x7B 5 = 564 340 g al Mistral 78 ee Mistral 78 3 5 Â§ 30 5 eo â= Mistral Â° 20 âe LlaMA2 78 (138 348 70B 7B (138 348 708 7B Â«13B 34B 708 Active Params Active Params Active Params\nFigure 3: Results on MMLU, commonsense reasoning, world knowledge and reading comprehension, math and code for Mistral (7B/8x7B) vs Llama 2 (7B/13B/70B). Mixtral largely outperforms Llama 2 70B on all benchmarks, except on reading comprehension benchmarks while using 5x lower active parameters. It is also vastly superior to Llama 2 70B on code and math.",
            "2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4\nLLaMA 2 70B GPT-3.5 MMLU (MCQ in 57 subjects) 69.9% 70.0% 70.6% HellaSwag (10-shot) 87.1% 85.5% 86.7% ARC Challenge (25-shot) 85.1% 85.2% 85.8% WinoGrande (5-shot) 83.2% 81.6% 81.2% MBPP (pass@1) 49.8% 52.2% 60.7% GSM-8K (5-shot) 53.6% 57.1% 58.4% MT Bench (for Instruct Models) 6.86 8.32 8.30\n# Mixtral 8x7B\nTable 3: Comparison of Mixtral with Llama 2 70B and GPT-3.5. Mixtral outperforms or matches Llama 2 70B and GPT-3.5 performance on most metrics.\nEvaluation Differences. On some benchmarks, there are some differences between our evaluation protocol and the one reported in the Llama 2 paper: 1) on MBPP, we use the hand-verified subset 2) on TriviaQA, we do not provide Wikipedia contexts.\n# 3.1 Multilingual benchmarks",
            "Llama 2 70B Mixtral 8x7B BBQ accuracy 51.5% 56.0% BOLD sentiment score (avg Â± std) gender profession religious_ideology political_ideology race 0.293 Â± 0.073 0.218 Â± 0.073 0.188 Â± 0.133 0.149 Â± 0.140 0.232 Â± 0.049 0.323 Â±0.045 0.243 Â± 0.087 0.144 Â± 0.089 0.186 Â± 0.146 0.232 Â± 0.052\nFigure 5: Bias Benchmarks. Compared Llama 2 70B, Mixtral presents less bias (higher accuracy on BBQ, lower std on BOLD) and displays more positive sentiment (higher avg on BOLD).\nWe benchmark Llama 2 and Mixtral on BBQ and BOLD with our evaluation framework and report the results in Table 5. Compared to Llama 2, Mixtral presents less bias on the BBQ benchmark (56.0% vs 51.5%). For each group in BOLD, a higher average sentiment score means more positive sentiments and a lower standard deviation indicates less bias within the group. Overall, Mixtral displays more positive sentiments than Llama 2, with similar variances within each group.\n# Instruction Fine-tuning",
            "Model Llama 2 ChatGPT GPT-4 Avg Setting Instruction Induction (Zero-shot) 0.3409 Original+Zero-shot-CoT 0.3753 0.3778 0.4070 Original Original+Ours (avg) Original+Ours (max) 0.7581 0.7636 0.7826 0.8068 0.7858 0.5773 0.8018 0.8178 0.6283 0.5721 0.6541 0.6772 Setting Instruction Induction (Few-shot) 0.0590 Original+Zero-shot-CoT 0.0769 0.0922 0.1026 Original Original+Ours (avg) Original+Ours (max) 0.7750 0.7887 0.7934 0.8105 0.8235 0.7003 0.8447 0.8660 0.5525 0.5220 0.5768 0.5930 Setting Big-Bench (Zero-shot) 1.3332 Original+Zero-shot-CoT 1.9575 2.8094 3.4200 Original Original+Ours (avg) Original+Ours (max) 18.0068 18.448 20.9779 21.8116 17.4984 21.6865 19.7243 22.8790 12.28 14.03 14.50 16.04",
            "# 3.1 Multilingual benchmarks\nCompared to Mistral 7B, we significantly upsample the proportion of multilingual data during pretraining. The extra capacity allows Mixtral to perform well on multilingual benchmarks while maintaining a high accuracy in English. In particular, Mixtral significantly outperforms Llama 2 70B in French, German, Spanish, and Italian, as shown in Table 4.\nActive Params French Arc-c HellaS MMLU German Arc-c HellaS MMLU Spanish Arc-c HellaS MMLU Italian Arc-c HellaS MMLU 33B 70B 13B 42.9% 65.4% 49.0% 39.3% 68.1% 49.9% 49.9% 72.5% 64.3% 49.4% 70.9% 65.1% 58.2% 77.4% 70.9% 54.3% 73.0% 71.5% 55.4% 77.6% 72.5% 52.8% 75.1% 70.9% 41.1% 63.3% 48.7% 47.3% 68.7% 64.2% 45.7% 69.8% 52.3% 50.5% 74.5% 66.0%",
            "n-1 y= Ss Softmax(Top2(a - W,)); - SwiGLU;(a). i=0\nThis formulation is similar to the GShard architecture [21], with the exceptions that we replace all FFN sub-blocks by MoE layers while GShard replaces every other block, and that GShard uses a more elaborate gating strategy for the second expert assigned to each token.\n# 3 Results\nWe compare Mixtral to Llama, and re-run all benchmarks with our own evaluation pipeline for fair comparison. We measure performance on a wide variety of tasks categorized as follow:\nâ¢ Commonsense Reasoning (0-shot): Hellaswag [32], Winogrande [26], PIQA [3], SIQA [27], OpenbookQA [22], ARC-Easy, ARC-Challenge [8], CommonsenseQA [30]",
            "6\nBackbone Training LAMB XSum HEval GPT-Neo (1.3B) +IT +Leak+IT 45.40 43.50 8.34 8.25 14.24 12.20 OpenLLaMA (3B) +IT +Leak+IT 54.00 46.20 3.50 2.61 9.15 6.71 LLaMA-2 (7B) +IT +Leak+IT 60.30 53.60 8.64 8.55 28.66 20.73\nTable 4: The comparison among LLMs after instruction tuning. âLeakâ denotes the data leakage using all train- ing sets of the benchmarks in Section 2. âITâ denotes the instruction tuning using Alpaca and CodeAlpaca for text generation and code synthesis tasks, respectively.",
            "15\nScan vs Convolution vs Attention time (A100 80GB PCle) Inference throughput on A100 80GB (prompt length 2048) â Flashattention-2 ame ee ES 1000-1 â convolution @ 1500] mm Mamba 6.98 wwe ââ Scan (PyTorch) Py mmm Transformer 6.78 100 4 ââ Scan (ours) Ei % 00M 2 a tod S 1000 B us Ff = 2 500 â = pad oid r S12 1k 2k Â«= 4k BKK 32K GK 128k 256K 512k 1 2 Hi A 16 32 oa 128 Sequence length Batch size\n@ =\n~ Â£\nFigure 8: (Efficiency Benchmarks.) (Left) Training: our efficient scan is 40Ã faster than a standard implementation. (Right) Inference: as a recurrent model, Mamba can achieve 5Ã higher throughput than Transformers.\n# 4.6 Model Ablations\nWe perform a series of detailed ablations on components of our model, focusing on the setting of language modeling with size â 350M models at Chinchilla token counts (same setting as Figure 4).\n# 4.6.1 Architecture\nTable 6 investigates the eï¬ects of the architecture (block) and its inner SSM layer (Figure 3). We ï¬nd that"
        ],
        "response": "Mixtral 8x7B outperforms Llama 2 70B on most benchmarks while using only 13B active parameters per token—5× fewer than Llama 2 70B during inference [source: unknown].",
        "reference": "The model that has better performance than Llama 2 70B on most benchmarks with 5x fewer active parameters during inference is Mixtral."
    },
    {
        "user_input": "What are the differences in architecture between Mixtral 8x7B and Mistral 7B in terms of feedforward blocks and active parameters used during inference?",
        "retrieved_contexts": [
            "We also present Mixtral 8x7B â Instruct, a chat model fine-tuned to follow instructions using supervised fine-tuning and Direct Preference Optimization [25]. Its performance notably surpasses that of GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human evaluation benchmarks. Mixtral â Instruct also demonstrates reduced biases, and a more balanced sentiment profile in benchmarks such as BBQ, and BOLD. We release both Mixtral 8x7B and Mixtral 8x7B â Instruct under the Apache 2.0 license1, free for academic and commercial usage, ensuring broad accessibility and potential for diverse applications. To enable the community to run Mixtral with a fully open-source stack, we submitted changes to the vLLM project, which integrates Megablocks CUDA kernels for efficient inference. Skypilot also allows the deployment of vLLM endpoints on any instance in the cloud.\n# 2 Architectural details\nMixtral is based on a transformer architecture [31] and uses the same modifications as described in [18], with the notable exceptions that Mix- tral supports a fully dense context length of 32k tokens, and the feed- forward blocks are replaced by Mixture-of-Expert layers (Section 2.1). The model architecture parameters are summarized in Table 1. Parameter Value",
            "Table 2: Comparison of Mixtral with Llama. Mixtral outperforms or matches Llama 2 70B performance on almost all popular benchmarks while using 5x fewer active parameters during inference.\n70 Mixtral 8x7B. âMixtral 8x7B Mixtral 8x7B 355 =o = Es & E60! Mistral 78 % 2681 Mistral 78 3 3 s0 5 = A % 66 50 g 4 45 64 78 138 348708 78 138 348708 78 138 348 70B S66 Mixtral 8x7B 50 Mixtral 8x7B 5 = 564 340 g al Mistral 78 ee Mistral 78 3 5 Â§ 30 5 eo â= Mistral Â° 20 âe LlaMA2 78 (138 348 70B 7B (138 348 708 7B Â«13B 34B 708 Active Params Active Params Active Params\nFigure 3: Results on MMLU, commonsense reasoning, world knowledge and reading comprehension, math and code for Mistral (7B/8x7B) vs Llama 2 (7B/13B/70B). Mixtral largely outperforms Llama 2 70B on all benchmarks, except on reading comprehension benchmarks while using 5x lower active parameters. It is also vastly superior to Llama 2 70B on code and math.",
            "Abstract\nWe introduce Mixtral 8x7B, a Sparse Mixture of Experts (SMoE) language model. Mixtral has the same architecture as Mistral 7B, with the difference that each layer is composed of 8 feedforward blocks (i.e. experts). For every token, at each layer, a router network selects two experts to process the current state and combine their outputs. Even though each token only sees two experts, the selected experts can be different at each timestep. As a result, each token has access to 47B parameters, but only uses 13B active parameters during inference. Mixtral was trained with a context size of 32k tokens and it outperforms or matches Llama 2 70B and GPT-3.5 across all evaluated benchmarks. In particular, Mixtral vastly outperforms Llama 2 70B on mathematics, code generation, and multilingual benchmarks. We also provide a model fine- tuned to follow instructions, Mixtral 8x7B â Instruct, that surpasses GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human bench- marks. Both the base and instruct models are released under the Apache 2.0 license.\nCode: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/",
            "# 6 Conclusion\nIn this paper, we introduced Mixtral 8x7B, the first mixture-of-experts network to reach a state-of-the- art performance among open-source models. Mixtral 8x7B Instruct outperforms Claude-2.1, Gem- ini Pro, and GPT-3.5 Turbo on human evaluation benchmarks. Because it only uses two experts at each time step, Mixtral only uses 13B active parameters per token while outperforming the previous best model using 70B parameters per token (Llama 2 70B). We are making our trained and fine-tuned mod- els publicly available under the Apache 2.0 license. By sharing our models, we aim to facilitate the de- velopment of new techniques and applications that can benefit a wide range of industries and domains.",
            "Detailed results for Mixtral, Mistral 7B and Llama 2 7B/13B/70B and Llama 1 34B2 are reported in Table 2. Figure 2 compares the performance of Mixtral with the Llama models in different categories. Mixtral surpasses Llama 2 70B across most metrics. In particular, Mixtral displays a superior performance in code and mathematics benchmarks.\nSize and Efficiency. We compare our performance to the Llama 2 family, aiming to understand Mixtral modelsâ efficiency in the cost-performance spectrum (see Figure 3). As a sparse Mixture- of-Experts model, Mixtral only uses 13B active parameters for each token. With 5x lower active parameters, Mixtral is able to outperform Llama 2 70B across most categories.\nNote that this analysis focuses on the active parameter count (see Section 2.1), which is directly proportional to the inference compute cost, but does not consider the memory costs and hardware utilization. The memory costs for serving Mixtral are proportional to its sparse parameter count, 47B, which is still smaller than Llama 2 70B. As for device utilization, we note that the SMoEs layer introduces additional overhead due to the routing mechanism and due to the increased memory loads when running more than one expert per device. They are more suitable for batched workloads where one can reach a good degree of arithmetic intensity.",
            "# 3.1 Multilingual benchmarks\nCompared to Mistral 7B, we significantly upsample the proportion of multilingual data during pretraining. The extra capacity allows Mixtral to perform well on multilingual benchmarks while maintaining a high accuracy in English. In particular, Mixtral significantly outperforms Llama 2 70B in French, German, Spanish, and Italian, as shown in Table 4.\nActive Params French Arc-c HellaS MMLU German Arc-c HellaS MMLU Spanish Arc-c HellaS MMLU Italian Arc-c HellaS MMLU 33B 70B 13B 42.9% 65.4% 49.0% 39.3% 68.1% 49.9% 49.9% 72.5% 64.3% 49.4% 70.9% 65.1% 58.2% 77.4% 70.9% 54.3% 73.0% 71.5% 55.4% 77.6% 72.5% 52.8% 75.1% 70.9% 41.1% 63.3% 48.7% 47.3% 68.7% 64.2% 45.7% 69.8% 52.3% 50.5% 74.5% 66.0%",
            "Comparison with Llama 2 70B and GPT-3.5. In Table 3, we report the performance of Mixtral 8x7B compared to Llama 2 70B and GPT-3.5. We observe that Mixtral performs similarly or above the two other models. On MMLU, Mixtral obtains a better performance, despite its significantly smaller capacity (47B tokens compared to 70B). For MT Bench, we report the performance of the latest GPT-3.5-Turbo model available, gpt-3.5-turbo-1106.\n2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4",
            "Table 1: Perplexity and model size evaluation of Mixtral-8x7B with different quantization for shared attention (Attn quant) and experts (Experts quant) layers. For comprarison, a Mistral-7B 4-bit quantized model has Wiki2 perplexity 5.03, C4 perplexity 7.56 and MMLU score 61.3%. See Section 4.2 for details. Green values correspond to the configurations we chose for full system evaluation.\n6\nAlgorithm 2-bit Experts 3-bit Experts A100 3080 Mobile 3060 T4 (Colab) A100 3080 Mobile 3060 T4 (Cloud) 3.061 Full algorithm 2.918 W/o expert pre-loading 2.265 W/o LRU cache & pre-loading Naive offloading (accelerate) 1.392 2.655 2.227 1.758 1.059 2.278 2.051 1.547 0.919 2.092 1.567 1.168 0.661 2.845 2.683 2.055 1.246 2.475 2.024 1.595 0.914 2.038 1.857 1.346 1.791 1.603 1.365 1.061 0.580",
            "n-1 y= Ss Softmax(Top2(a - W,)); - SwiGLU;(a). i=0\nThis formulation is similar to the GShard architecture [21], with the exceptions that we replace all FFN sub-blocks by MoE layers while GShard replaces every other block, and that GShard uses a more elaborate gating strategy for the second expert assigned to each token.\n# 3 Results\nWe compare Mixtral to Llama, and re-run all benchmarks with our own evaluation pipeline for fair comparison. We measure performance on a wide variety of tasks categorized as follow:\nâ¢ Commonsense Reasoning (0-shot): Hellaswag [32], Winogrande [26], PIQA [3], SIQA [27], OpenbookQA [22], ARC-Easy, ARC-Challenge [8], CommonsenseQA [30]",
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization"
        ],
        "response": "Mixtral 8x7B replaces every feed-forward block of Mistral 7B with a Mixture-of-Experts (MoE) layer containing eight expert feed-forward networks; at each layer a router selects the top-2 experts for a token, whose outputs are combined, while Mistral 7B uses a single fixed feed-forward block per layer. Consequently Mixtral exposes 47 B total parameters but only 13 B are active during inference for any token, giving it 5× fewer active parameters than the 70 B active parameters of Llama 2 70B and roughly the same active count as Mistral 7B’s 7 B, despite the larger sparse capacity.",
        "reference": "The difference in architecture between Mixtral 8x7B and Mistral 7B lies in the number of feedforward blocks (experts) in each layer. Mixtral 8x7B has 8 feedforward blocks in each layer, while Mistral 7B has a different number of feedforward blocks. Additionally, during inference, Mixtral 8x7B uses 13B active parameters out of the total 47B parameters available for each token."
    },
    {
        "user_input": "How does Mixtral's performance in code and math benchmarks compare to Llama 2 70B?",
        "retrieved_contexts": [
            "Table 2: Comparison of Mixtral with Llama. Mixtral outperforms or matches Llama 2 70B performance on almost all popular benchmarks while using 5x fewer active parameters during inference.\n70 Mixtral 8x7B. âMixtral 8x7B Mixtral 8x7B 355 =o = Es & E60! Mistral 78 % 2681 Mistral 78 3 3 s0 5 = A % 66 50 g 4 45 64 78 138 348708 78 138 348708 78 138 348 70B S66 Mixtral 8x7B 50 Mixtral 8x7B 5 = 564 340 g al Mistral 78 ee Mistral 78 3 5 Â§ 30 5 eo â= Mistral Â° 20 âe LlaMA2 78 (138 348 70B 7B (138 348 708 7B Â«13B 34B 708 Active Params Active Params Active Params\nFigure 3: Results on MMLU, commonsense reasoning, world knowledge and reading comprehension, math and code for Mistral (7B/8x7B) vs Llama 2 (7B/13B/70B). Mixtral largely outperforms Llama 2 70B on all benchmarks, except on reading comprehension benchmarks while using 5x lower active parameters. It is also vastly superior to Llama 2 70B on code and math.",
            "Detailed results for Mixtral, Mistral 7B and Llama 2 7B/13B/70B and Llama 1 34B2 are reported in Table 2. Figure 2 compares the performance of Mixtral with the Llama models in different categories. Mixtral surpasses Llama 2 70B across most metrics. In particular, Mixtral displays a superior performance in code and mathematics benchmarks.\nSize and Efficiency. We compare our performance to the Llama 2 family, aiming to understand Mixtral modelsâ efficiency in the cost-performance spectrum (see Figure 3). As a sparse Mixture- of-Experts model, Mixtral only uses 13B active parameters for each token. With 5x lower active parameters, Mixtral is able to outperform Llama 2 70B across most categories.\nNote that this analysis focuses on the active parameter count (see Section 2.1), which is directly proportional to the inference compute cost, but does not consider the memory costs and hardware utilization. The memory costs for serving Mixtral are proportional to its sparse parameter count, 47B, which is still smaller than Llama 2 70B. As for device utilization, we note that the SMoEs layer introduces additional overhead due to the routing mechanism and due to the increased memory loads when running more than one expert per device. They are more suitable for batched workloads where one can reach a good degree of arithmetic intensity.",
            "Comparison with Llama 2 70B and GPT-3.5. In Table 3, we report the performance of Mixtral 8x7B compared to Llama 2 70B and GPT-3.5. We observe that Mixtral performs similarly or above the two other models. On MMLU, Mixtral obtains a better performance, despite its significantly smaller capacity (47B tokens compared to 70B). For MT Bench, we report the performance of the latest GPT-3.5-Turbo model available, gpt-3.5-turbo-1106.\n2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4",
            "2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4\nLLaMA 2 70B GPT-3.5 MMLU (MCQ in 57 subjects) 69.9% 70.0% 70.6% HellaSwag (10-shot) 87.1% 85.5% 86.7% ARC Challenge (25-shot) 85.1% 85.2% 85.8% WinoGrande (5-shot) 83.2% 81.6% 81.2% MBPP (pass@1) 49.8% 52.2% 60.7% GSM-8K (5-shot) 53.6% 57.1% 58.4% MT Bench (for Instruct Models) 6.86 8.32 8.30\n# Mixtral 8x7B\nTable 3: Comparison of Mixtral with Llama 2 70B and GPT-3.5. Mixtral outperforms or matches Llama 2 70B and GPT-3.5 performance on most metrics.\nEvaluation Differences. On some benchmarks, there are some differences between our evaluation protocol and the one reported in the Llama 2 paper: 1) on MBPP, we use the hand-verified subset 2) on TriviaQA, we do not provide Wikipedia contexts.\n# 3.1 Multilingual benchmarks",
            "Llama 2 70B Mixtral 8x7B BBQ accuracy 51.5% 56.0% BOLD sentiment score (avg Â± std) gender profession religious_ideology political_ideology race 0.293 Â± 0.073 0.218 Â± 0.073 0.188 Â± 0.133 0.149 Â± 0.140 0.232 Â± 0.049 0.323 Â±0.045 0.243 Â± 0.087 0.144 Â± 0.089 0.186 Â± 0.146 0.232 Â± 0.052\nFigure 5: Bias Benchmarks. Compared Llama 2 70B, Mixtral presents less bias (higher accuracy on BBQ, lower std on BOLD) and displays more positive sentiment (higher avg on BOLD).\nWe benchmark Llama 2 and Mixtral on BBQ and BOLD with our evaluation framework and report the results in Table 5. Compared to Llama 2, Mixtral presents less bias on the BBQ benchmark (56.0% vs 51.5%). For each group in BOLD, a higher average sentiment score means more positive sentiments and a lower standard deviation indicates less bias within the group. Overall, Mixtral displays more positive sentiments than Llama 2, with similar variances within each group.\n# Instruction Fine-tuning",
            "# 3.1 Multilingual benchmarks\nCompared to Mistral 7B, we significantly upsample the proportion of multilingual data during pretraining. The extra capacity allows Mixtral to perform well on multilingual benchmarks while maintaining a high accuracy in English. In particular, Mixtral significantly outperforms Llama 2 70B in French, German, Spanish, and Italian, as shown in Table 4.\nActive Params French Arc-c HellaS MMLU German Arc-c HellaS MMLU Spanish Arc-c HellaS MMLU Italian Arc-c HellaS MMLU 33B 70B 13B 42.9% 65.4% 49.0% 39.3% 68.1% 49.9% 49.9% 72.5% 64.3% 49.4% 70.9% 65.1% 58.2% 77.4% 70.9% 54.3% 73.0% 71.5% 55.4% 77.6% 72.5% 52.8% 75.1% 70.9% 41.1% 63.3% 48.7% 47.3% 68.7% 64.2% 45.7% 69.8% 52.3% 50.5% 74.5% 66.0%",
            "Table 4: Comparison of Mixtral with Llama on Multilingual Benchmarks. On ARC Challenge, Hellaswag, and MMLU, Mixtral outperforms Llama 2 70B on 4 languages: French, German, Spanish, and Italian.\n# 3.2 Long range performance\nTo assess the capabilities of Mixtral to tackle long context, we evaluate it on the passkey retrieval task introduced in [23], a synthetic task designed to measure the ability of the model to retrieve a passkey inserted randomly in a long prompt. Results in Figure 4 (Left) show that Mixtral achieves a 100% retrieval accuracy regardless of the context length or the position of passkey in the sequence. Figure 4 (Right) shows that the perplexity of Mixtral on a subset of the proof-pile dataset [2] decreases monotonically as the size of the context increases.\nPasskey Performance ry 0.8 0.6 04 0.2 0.0 OK 4K 8K 12K 16K 20K 24K 28K Seq Len Passkey Loc\n3.8 â Mixtral_8x7B 3.5 32 > $3.0 i] 228 fos a 2.0 0 5k 10k 15k 20k 25k 30k Context length",
            "n-1 y= Ss Softmax(Top2(a - W,)); - SwiGLU;(a). i=0\nThis formulation is similar to the GShard architecture [21], with the exceptions that we replace all FFN sub-blocks by MoE layers while GShard replaces every other block, and that GShard uses a more elaborate gating strategy for the second expert assigned to each token.\n# 3 Results\nWe compare Mixtral to Llama, and re-run all benchmarks with our own evaluation pipeline for fair comparison. We measure performance on a wide variety of tasks categorized as follow:\nâ¢ Commonsense Reasoning (0-shot): Hellaswag [32], Winogrande [26], PIQA [3], SIQA [27], OpenbookQA [22], ARC-Easy, ARC-Challenge [8], CommonsenseQA [30]",
            "Abstract\nWe introduce Mixtral 8x7B, a Sparse Mixture of Experts (SMoE) language model. Mixtral has the same architecture as Mistral 7B, with the difference that each layer is composed of 8 feedforward blocks (i.e. experts). For every token, at each layer, a router network selects two experts to process the current state and combine their outputs. Even though each token only sees two experts, the selected experts can be different at each timestep. As a result, each token has access to 47B parameters, but only uses 13B active parameters during inference. Mixtral was trained with a context size of 32k tokens and it outperforms or matches Llama 2 70B and GPT-3.5 across all evaluated benchmarks. In particular, Mixtral vastly outperforms Llama 2 70B on mathematics, code generation, and multilingual benchmarks. We also provide a model fine- tuned to follow instructions, Mixtral 8x7B â Instruct, that surpasses GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human bench- marks. Both the base and instruct models are released under the Apache 2.0 license.\nCode: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/",
            "# 6 Conclusion\nIn this paper, we introduced Mixtral 8x7B, the first mixture-of-experts network to reach a state-of-the- art performance among open-source models. Mixtral 8x7B Instruct outperforms Claude-2.1, Gem- ini Pro, and GPT-3.5 Turbo on human evaluation benchmarks. Because it only uses two experts at each time step, Mixtral only uses 13B active parameters per token while outperforming the previous best model using 70B parameters per token (Llama 2 70B). We are making our trained and fine-tuned mod- els publicly available under the Apache 2.0 license. By sharing our models, we aim to facilitate the de- velopment of new techniques and applications that can benefit a wide range of industries and domains."
        ],
        "response": "Mixtral 8x7B is vastly superior to Llama 2 70B on both code and mathematics benchmarks. Specifically, on MBPP (code generation) it scores 60.7% pass@1 versus Llama 2 70B’s 49.8%, and on GSM-8K (math word problems) it reaches 58.4% versus 53.6% for Llama 2 70B. These gains come while activating only 13B parameters per token—5× fewer than Llama 2 70B—making the advantage simultaneously performance and compute-efficient.",
        "reference": "Mixtral's performance in code and math benchmarks is superior to Llama 2 70B."
    },
    {
        "user_input": "How does benchmarking the expert LRU cache and speculative loading affect the effectiveness of the Mixtral-8x7B-Instruct model on the OpenAssistant dataset?",
        "retrieved_contexts": [
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization",
            "7Notably, Google Colab RAM cannot fit Mixtral-8x7B with a reasonable compression rate 8This corresponds to tensor.pin_memory() command in PyTorch.\n5\niy & cache_size =3 cache_size = 2 cache_size =4 0.84 | PIO â prefetch 1 experts ~ escent ae | PRS aa 0.2} ââ prefetch 2 experts ââ prefetch 3 experts 0.0 00 0 5 10 15 20 25 30 0 5 10 15 20 25 30 Layer # Layer # S Fd Ed Cache hit rate Bd ES Prediction recall = ES Ss &\nFigure 2: (left) LRU cache hit ratio for different cache size k; (right) speculative loading recall when pre-loading a different number of experts. Regular lines represent loading 1 layer ahead; dashed line stands for 2 layers ahead; dotted line is 10 layers ahead.\n# 4.1 Expert LRU Cache and Speculative Loading\nIn this section, we benchmark the effectiveness of the two expert offloading strategies: LRU caching and and speculative loading, as defined in Sections 3.1 and 3.2 respectively. For this evaluation, we measure âexpert recallâ â the fraction of times when an expert needed for inference was already available on GPU.",
            "We illustrate an example of how LRU cache saves experts in Figure 1 (see caption). LRU is a very simple strategy that does not consider factors like expert activation frequencies, varying cache size between MoE layers, or any sequential patterns in expert activation. However, we found that even this simple strategy can significantly speed up inference for modern Mixture-of-Experts models such as Mixtral-8x7B (see Section 4 for detailed evaluation).\n# 3.2 Speculative Expert Loading\nWhile LRU caching can reduce the average expert loading time, most of the inference time is still spent waiting for the next expert to be loaded. The reason behind this is that, unlike with dense models, MoE offloading cannot effectively overlap expert loading with computation. To understand this problem, let us zoom into the process of generating a single token, layer-by-layer. The full compute workload starts by embedding the previous token via look-up, then alternates between running self-attention and MLP for each transformer block in the model. Finally, the outputs from the last transformer block are used to predict next token logits with a linear projection.",
            "Expert Offloading. As described earlier, we use LRU cache with an equal number k of cached experts per layer. For Mixtral-8x7B, we use k=2 for 12GB GPUs and k=4 for 16GB ones. We trigger speculative expert loading immediately after the system finished loading all experts for the current layer. The speculative expert loading fetches 1 â 2 most likely experts. The newly loaded experts do not replace the currently cached experts. If a speculatively loaded expert was later used during next layer inference, it will replace the least recently used expert from the next layerâs cache.\nMany consumer devices and free-tier cloud instances have limited host RAM that cannot fit the entire model7. In these cases, the experts must be split between host and device memory. To support this, our implementation of expert LRU cache splits experts between host and GPU devices. When loading and expert to the GPU cache, the system also offloads the least recently used on-device expert back to RAM so as to preserve memory parity.",
            "Figure 1: An example of expert loading pattern in Mixtral-8x7B-Instruct for select layers. Blue cells indicate that a certain expert was active when encoding a certain token; deeper blue indicates higher gating weight. Small gray squares show which experts are cached with an LRU cache for k=2.\n# 3.1 Expert Locality and LRU caching\nAs we discussed earlier in Section 2.1, Mixture-of-Experts language models were often observed to assign individual experts to distinct sub-tasks. However, this does not mean that the model uses the same expert over long stretches of tokens. Instead, some experts are active in short sequences of 2-4 tokens, while others are often used with âgapsâ, as shown in Figure 1.\nTo take advantage of this pattern, we can keep active experts in GPU memory as a âcacheâ for future tokens. If the same experts are activated again in future, they will be available instantaneously. Naturally, the number of experts that can be stored this way if very limited by the available GPU memory. For simplicity, we choose to always keep k least recently used experts as a type of LRU cache. If k is greater than the number of active experts, the cache will save experts from multiple previous tokens. For simplicity, we keep the same number of cached experts for each MoE layer.",
            "# 6 Conclusion\nIn this paper, we introduced Mixtral 8x7B, the first mixture-of-experts network to reach a state-of-the- art performance among open-source models. Mixtral 8x7B Instruct outperforms Claude-2.1, Gem- ini Pro, and GPT-3.5 Turbo on human evaluation benchmarks. Because it only uses two experts at each time step, Mixtral only uses 13B active parameters per token while outperforming the previous best model using 70B parameters per token (Llama 2 70B). We are making our trained and fine-tuned mod- els publicly available under the Apache 2.0 license. By sharing our models, we aim to facilitate the de- velopment of new techniques and applications that can benefit a wide range of industries and domains.",
            "# 4.3 Practical offloading performance\nFinally we evaluate the performance of the Mixtral8x7B-Instruct model using the offloading tech- niquesproposed throughout this report. Based on the perplexity evaluations from the previous section, we chose 4-bit HQQ quantization for the shared attention layers and 2- or 3-bit quantization for experts. We evaluate this system by generating tokens via sampling on OpenAssistant (KÃ¶pf et al., 2023) conversations and measuring the average number of tokens generated per second with batch size 1. For this evaluation, we always sample proportionally to the predicted probabilities, i.e. without temperature or nucleus sampling.",
            "n-1 y= Ss Softmax(Top2(a - W,)); - SwiGLU;(a). i=0\nThis formulation is similar to the GShard architecture [21], with the exceptions that we replace all FFN sub-blocks by MoE layers while GShard replaces every other block, and that GShard uses a more elaborate gating strategy for the second expert assigned to each token.\n# 3 Results\nWe compare Mixtral to Llama, and re-run all benchmarks with our own evaluation pipeline for fair comparison. We measure performance on a wide variety of tasks categorized as follow:\nâ¢ Commonsense Reasoning (0-shot): Hellaswag [32], Winogrande [26], PIQA [3], SIQA [27], OpenbookQA [22], ARC-Easy, ARC-Challenge [8], CommonsenseQA [30]",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2"
        ],
        "response": "On OpenAssistant, the Mixtral-8x7B-Instruct model achieves an expert recall of ~0.84 with k=2 LRU experts cached per layer and a recall of ~0.88 with k=4. Speculative loading of the 1-2 most-likely next experts—predicted by applying the next layer’s gating function to the current-layer activations—pushes combined recall to 1.0 for a single layer ahead and stays above 0.9 even when prefetching 10 layers ahead, showing that the two techniques together eliminate almost all GPU-RAM expert transfers and thus cut per-token latency roughly in half compared with on-demand loading. [unknown]",
        "reference": "Benchmarking the expert LRU cache and speculative loading affects the effectiveness of the Mixtral-8x7B-Instruct model on the OpenAssistant dataset by reducing latency if the speculative loading guess is accurate enough. The system combines caching and prefetching techniques and uses the Half Quadratic Quantization (HQQ) algorithm for quantization. Speculative expert loading is triggered after loading all experts for the current layer and fetches the 1-2 most likely experts. The implementation of expert LRU cache splits experts between host and GPU devices. The benchmarking process evaluates the effectiveness of these two expert offloading strategies."
    },
    {
        "user_input": "Can you explain the relationship between the expert recall rate and the effectiveness of the Mixtral-8x7B-Instruct model on the OpenAssistant dataset?",
        "retrieved_contexts": [
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization",
            "# 6 Conclusion\nIn this paper, we introduced Mixtral 8x7B, the first mixture-of-experts network to reach a state-of-the- art performance among open-source models. Mixtral 8x7B Instruct outperforms Claude-2.1, Gem- ini Pro, and GPT-3.5 Turbo on human evaluation benchmarks. Because it only uses two experts at each time step, Mixtral only uses 13B active parameters per token while outperforming the previous best model using 70B parameters per token (Llama 2 70B). We are making our trained and fine-tuned mod- els publicly available under the Apache 2.0 license. By sharing our models, we aim to facilitate the de- velopment of new techniques and applications that can benefit a wide range of industries and domains.",
            "# 4.3 Practical offloading performance\nFinally we evaluate the performance of the Mixtral8x7B-Instruct model using the offloading tech- niquesproposed throughout this report. Based on the perplexity evaluations from the previous section, we chose 4-bit HQQ quantization for the shared attention layers and 2- or 3-bit quantization for experts. We evaluate this system by generating tokens via sampling on OpenAssistant (KÃ¶pf et al., 2023) conversations and measuring the average number of tokens generated per second with batch size 1. For this evaluation, we always sample proportionally to the predicted probabilities, i.e. without temperature or nucleus sampling.",
            "Abstract\nWe introduce Mixtral 8x7B, a Sparse Mixture of Experts (SMoE) language model. Mixtral has the same architecture as Mistral 7B, with the difference that each layer is composed of 8 feedforward blocks (i.e. experts). For every token, at each layer, a router network selects two experts to process the current state and combine their outputs. Even though each token only sees two experts, the selected experts can be different at each timestep. As a result, each token has access to 47B parameters, but only uses 13B active parameters during inference. Mixtral was trained with a context size of 32k tokens and it outperforms or matches Llama 2 70B and GPT-3.5 across all evaluated benchmarks. In particular, Mixtral vastly outperforms Llama 2 70B on mathematics, code generation, and multilingual benchmarks. We also provide a model fine- tuned to follow instructions, Mixtral 8x7B â Instruct, that surpasses GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human bench- marks. Both the base and instruct models are released under the Apache 2.0 license.\nCode: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/",
            "7Notably, Google Colab RAM cannot fit Mixtral-8x7B with a reasonable compression rate 8This corresponds to tensor.pin_memory() command in PyTorch.\n5\niy & cache_size =3 cache_size = 2 cache_size =4 0.84 | PIO â prefetch 1 experts ~ escent ae | PRS aa 0.2} ââ prefetch 2 experts ââ prefetch 3 experts 0.0 00 0 5 10 15 20 25 30 0 5 10 15 20 25 30 Layer # Layer # S Fd Ed Cache hit rate Bd ES Prediction recall = ES Ss &\nFigure 2: (left) LRU cache hit ratio for different cache size k; (right) speculative loading recall when pre-loading a different number of experts. Regular lines represent loading 1 layer ahead; dashed line stands for 2 layers ahead; dotted line is 10 layers ahead.\n# 4.1 Expert LRU Cache and Speculative Loading\nIn this section, we benchmark the effectiveness of the two expert offloading strategies: LRU caching and and speculative loading, as defined in Sections 3.1 and 3.2 respectively. For this evaluation, we measure âexpert recallâ â the fraction of times when an expert needed for inference was already available on GPU.",
            "We also present Mixtral 8x7B â Instruct, a chat model fine-tuned to follow instructions using supervised fine-tuning and Direct Preference Optimization [25]. Its performance notably surpasses that of GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human evaluation benchmarks. Mixtral â Instruct also demonstrates reduced biases, and a more balanced sentiment profile in benchmarks such as BBQ, and BOLD. We release both Mixtral 8x7B and Mixtral 8x7B â Instruct under the Apache 2.0 license1, free for academic and commercial usage, ensuring broad accessibility and potential for diverse applications. To enable the community to run Mixtral with a fully open-source stack, we submitted changes to the vLLM project, which integrates Megablocks CUDA kernels for efficient inference. Skypilot also allows the deployment of vLLM endpoints on any instance in the cloud.\n# 2 Architectural details\nMixtral is based on a transformer architecture [31] and uses the same modifications as described in [18], with the notable exceptions that Mix- tral supports a fully dense context length of 32k tokens, and the feed- forward blocks are replaced by Mixture-of-Expert layers (Section 2.1). The model architecture parameters are summarized in Table 1. Parameter Value",
            "n-1 y= Ss Softmax(Top2(a - W,)); - SwiGLU;(a). i=0\nThis formulation is similar to the GShard architecture [21], with the exceptions that we replace all FFN sub-blocks by MoE layers while GShard replaces every other block, and that GShard uses a more elaborate gating strategy for the second expert assigned to each token.\n# 3 Results\nWe compare Mixtral to Llama, and re-run all benchmarks with our own evaluation pipeline for fair comparison. We measure performance on a wide variety of tasks categorized as follow:\nâ¢ Commonsense Reasoning (0-shot): Hellaswag [32], Winogrande [26], PIQA [3], SIQA [27], OpenbookQA [22], ARC-Easy, ARC-Challenge [8], CommonsenseQA [30]",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "Code: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/\n# Introduction\nIn this paper, we present Mixtral 8x7B, a sparse mixture of experts model (SMoE) with open weights, licensed under Apache 2.0. Mixtral outperforms Llama 2 70B and GPT-3.5 on most benchmarks. As it only uses a subset of its parameters for every token, Mixtral allows faster inference speed at low batch-sizes, and higher throughput at large batch-sizes.\nMixtral is a sparse mixture-of-experts network. It is a decoder-only model where the feedforward block picks from a set of 8 distinct groups of parameters. At every layer, for every token, a router network chooses two of these groups (the âexpertsâ) to process the token and combine their output additively. This technique increases the number of parameters of a model while controlling cost and latency, as the model only uses a fraction of the total set of parameters per token.\nMixtral is pretrained with multilingual data using a context size of 32k tokens. It either matches or exceeds the performance of Llama 2 70B and GPT-3.5, over several benchmarks. In particular,\nMixture of Experts Layer i gating inputs af outputs router expert",
            "Table 1: Perplexity and model size evaluation of Mixtral-8x7B with different quantization for shared attention (Attn quant) and experts (Experts quant) layers. For comprarison, a Mistral-7B 4-bit quantized model has Wiki2 perplexity 5.03, C4 perplexity 7.56 and MMLU score 61.3%. See Section 4.2 for details. Green values correspond to the configurations we chose for full system evaluation.\n6\nAlgorithm 2-bit Experts 3-bit Experts A100 3080 Mobile 3060 T4 (Colab) A100 3080 Mobile 3060 T4 (Cloud) 3.061 Full algorithm 2.918 W/o expert pre-loading 2.265 W/o LRU cache & pre-loading Naive offloading (accelerate) 1.392 2.655 2.227 1.758 1.059 2.278 2.051 1.547 0.919 2.092 1.567 1.168 0.661 2.845 2.683 2.055 1.246 2.475 2.024 1.595 0.914 2.038 1.857 1.346 1.791 1.603 1.365 1.061 0.580"
        ],
        "response": "Higher expert recall directly raises effective inference speed because every recalled expert avoids a costly host-to-device copy. On the OpenAssistant conversations, speculative loading that successfully pre-fetches both of the next layer’s two active experts (recall = 1.0) lets the Mixtral-8x7B-Instruct model generate tokens without the ≈ 2–3 ms reloading delay. Figure 2 (right) shows that looking 1 layer ahead already reaches ~0.8 recall; pushing the lookahead to 10 layers lifts recall toward 0.95, so almost every expert is ready when needed and the measured throughput climbs from 1.392 tokens/s (naïve offloading) to 2.918 tokens/s with full speculative loading enabled—an ~2× gain. Thus, the closer recall is to 1.0, the closer overall latency gets to the unloaded GPU-only baseline, making high recall a key lever for practical deployment of the 8×7B-Instruct model under memory constraints.",
        "reference": "The given context does not provide any information about the relationship between the expert recall rate and the effectiveness of the Mixtral-8x7B-Instruct model on the OpenAssistant dataset."
    },
    {
        "user_input": "What is the purpose of LRU caching in Mixture-of-Experts language models?",
        "retrieved_contexts": [
            "Figure 1: An example of expert loading pattern in Mixtral-8x7B-Instruct for select layers. Blue cells indicate that a certain expert was active when encoding a certain token; deeper blue indicates higher gating weight. Small gray squares show which experts are cached with an LRU cache for k=2.\n# 3.1 Expert Locality and LRU caching\nAs we discussed earlier in Section 2.1, Mixture-of-Experts language models were often observed to assign individual experts to distinct sub-tasks. However, this does not mean that the model uses the same expert over long stretches of tokens. Instead, some experts are active in short sequences of 2-4 tokens, while others are often used with âgapsâ, as shown in Figure 1.\nTo take advantage of this pattern, we can keep active experts in GPU memory as a âcacheâ for future tokens. If the same experts are activated again in future, they will be available instantaneously. Naturally, the number of experts that can be stored this way if very limited by the available GPU memory. For simplicity, we choose to always keep k least recently used experts as a type of LRU cache. If k is greater than the number of active experts, the cache will save experts from multiple previous tokens. For simplicity, we keep the same number of cached experts for each MoE layer.",
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization",
            "We illustrate an example of how LRU cache saves experts in Figure 1 (see caption). LRU is a very simple strategy that does not consider factors like expert activation frequencies, varying cache size between MoE layers, or any sequential patterns in expert activation. However, we found that even this simple strategy can significantly speed up inference for modern Mixture-of-Experts models such as Mixtral-8x7B (see Section 4 for detailed evaluation).\n# 3.2 Speculative Expert Loading\nWhile LRU caching can reduce the average expert loading time, most of the inference time is still spent waiting for the next expert to be loaded. The reason behind this is that, unlike with dense models, MoE offloading cannot effectively overlap expert loading with computation. To understand this problem, let us zoom into the process of generating a single token, layer-by-layer. The full compute workload starts by embedding the previous token via look-up, then alternates between running self-attention and MLP for each transformer block in the model. Finally, the outputs from the last transformer block are used to predict next token logits with a linear projection.",
            "7Notably, Google Colab RAM cannot fit Mixtral-8x7B with a reasonable compression rate 8This corresponds to tensor.pin_memory() command in PyTorch.\n5\niy & cache_size =3 cache_size = 2 cache_size =4 0.84 | PIO â prefetch 1 experts ~ escent ae | PRS aa 0.2} ââ prefetch 2 experts ââ prefetch 3 experts 0.0 00 0 5 10 15 20 25 30 0 5 10 15 20 25 30 Layer # Layer # S Fd Ed Cache hit rate Bd ES Prediction recall = ES Ss &\nFigure 2: (left) LRU cache hit ratio for different cache size k; (right) speculative loading recall when pre-loading a different number of experts. Regular lines represent loading 1 layer ahead; dashed line stands for 2 layers ahead; dotted line is 10 layers ahead.\n# 4.1 Expert LRU Cache and Speculative Loading\nIn this section, we benchmark the effectiveness of the two expert offloading strategies: LRU caching and and speculative loading, as defined in Sections 3.1 and 3.2 respectively. For this evaluation, we measure âexpert recallâ â the fraction of times when an expert needed for inference was already available on GPU.",
            "Expert Offloading. As described earlier, we use LRU cache with an equal number k of cached experts per layer. For Mixtral-8x7B, we use k=2 for 12GB GPUs and k=4 for 16GB ones. We trigger speculative expert loading immediately after the system finished loading all experts for the current layer. The speculative expert loading fetches 1 â 2 most likely experts. The newly loaded experts do not replace the currently cached experts. If a speculatively loaded expert was later used during next layer inference, it will replace the least recently used expert from the next layerâs cache.\nMany consumer devices and free-tier cloud instances have limited host RAM that cannot fit the entire model7. In these cases, the experts must be split between host and device memory. To support this, our implementation of expert LRU cache splits experts between host and GPU devices. When loading and expert to the GPU cache, the system also offloads the least recently used on-device expert back to RAM so as to preserve memory parity.",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction",
            "Google. Google colaboratory, 2023. URL https://colab.research.google.com/.\nHendrycks, D., Burns, C., Basart, S., Zou, A., Mazeika, M., Song, D., and Steinhardt, J. Measuring massive multitask language understanding. Proceedings of the International Conference on Learning Representations (ICLR), 2021.\nHsu, Y.-C., Hua, T., Chang, S., Lou, Q., Shen, Y., and Jin, H. Language model compression with weighted low-rank factorization. arXiv preprint arXiv:2207.00112, 2022.\nJacobs, R. A., Jordan, M. I., Nowlan, S. J., and Hinton, G. E. Adaptive mixtures of local experts. Neural Computation, 3(1):79â87, March 1991. ISSN 0899-7667. doi: 10.1162/neco.1991.3.1.79. URL https://doi.org/10.1162/neco.1991.3.1.79.\nJordan, M. I. and Jacobs, R. A. Hierarchical mixtures of experts and the em algorithm. Neural computation, 6(2):181â214, 1994.",
            "Shazeer et al. (2017) builds on this idea to train a sparsely gated Mixture-of-Experts to serve as a language model. The full model consists of a recurrent neural network backbone and a MoE module with up to 131072 experts. When processing a given token, a linear gating function select 4 most suitable experts based on the latest hidden state. The resulting model (including the gating function and experts) is trained end-to-end to minimize cross-entropy, with an additional regularizer to promote equal expert utilization. Shazeer et al. (2017) observed that the MoE model not only improves perplexity, but also learns interpretable expert specializations: some experts would âspecializeâ on prepositions, while others learn to express a particular concept (e.g. speed).",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2"
        ],
        "response": "LRU caching in Mixture-of-Experts language models keeps the k least-recently used experts resident in GPU memory so that when the same experts are re-activated within a few tokens they are already available, avoiding expensive CPU-to-GPU transfers and significantly accelerating inference on memory-constrained hardware [https://colab.research.google.com/].",
        "reference": "The purpose of LRU caching in Mixture-of-Experts language models is to speed up inference by keeping active experts in GPU memory as a cache for future tokens. This allows for faster access to the necessary experts, even if the number of experts that can be stored in the cache is limited by the available GPU memory."
    },
    {
        "user_input": "What is the key difference between encoding the input prompt and generating tokens in generative inference?",
        "retrieved_contexts": [
            "The generative inference workload consists of two phases: 1) encoding the input prompt and 2) generating tokens conditioned on that prompt. The key difference between these two phases is that prompt tokens are encoded in parallel (layer-by-layer), whereas the generation runs sequentially (token-by-token and layer-by-layer). In general, phase 1 works relatively well with existing Mixture- of-Experts algorithms, since each layer can only be loaded once for the entire prompt. In turn, when generating tokens, one must load layer once per each token generated. In practice, this means that inference speed is limited by how fast one can fetch parameters from system memory.\nBelow, we look for patterns in how the MoE model loads its experts and propose ways to exploit these patterns to speed up inference time.\n4To learn more about these methods, please refer to surveys such as Gholami et al. (2021); Liang et al. (2021) 5As opposed to running a processing a large batch of texts over many seconds, as in Sheng et al. (2023)\n3\nSelected experts for Mixtral-8x7B-Instruct woe 0 (top) and 15 ae =n a oa ao a âme: a n: ee Layer 15 expert # Layer 0 expert # MAUR STARR O However about |= and 4 training data owerful language model based trained Trans former f architecture",
            "However, both discriminative and selective evaluations en- counter a substantial challenge. They are predicated on the assumption that âLLMsâs capacity to produce reliable text is contingent upon their discernment between hallucinated and non-hallucinated content.â These methods do not simulate the evaluation of the modelâs output for hallucinations. Conse- quently, generative evaluation is crucial as it directly evaluates the presence of hallucinations in the text generated by the LLM. Specifically, the LLM under evaluation is provided with an initial text and is then tasked with generating a continuation. Subsequently, various reference-based techniques are utilized to determine if the continuation includes hallucinations. How- ever, the challenge arises from the fact that it is not feasible to automatically and accurately ascertain if newly generated text is hallucinated; if it were, annotated datasets would be redun- dant. In scenarios of unrestrained text generation, this issue becomes increasingly complex. This complexity stems from the fact that text generated without constraints may introduce a multitude of entities and facts absent in the reference material, complicating the verification of their accuracy. Despite these hurdles, generative evaluation continues to be a predominant strategy in Natural Language Generation (NLG) tasks [26].",
            "# 2.4 Hardware Setup\nWhile our analysis is not specific to any hardware setup, we target the hardware specifications of cheap / free-tier cloud instances Google (2023) and the upper half of gaming computers Steam (2023): i) enough system memory to hold model parameters, ii) a GPU with 11-16GB VRAM and iii) host-to-device communication at 8-16GB/s (PCIe Gen.3). If we examine popular open-access MoE models (Mixtral-8x7B and switch-c-2048), we find that all non-experts can fit a fraction of available GPU memory. In turn, the experts that constitute vast majority of model parameters do not fit even with quantization. Finally, even if we could fit the model parameters in memory, running generative inference requires additional memory for layer activations and past attention keys & values.\n# 3 Method\nIn this work, we aim to systematically find the optimal way to inference modern Mixture-of-Experts LLMs on desktop or low-end cloud instances. More specifically, we focus on the task of generating tokens interactively, i.e. generate multiple tokens per second at batch size 15.",
            "Kaya Stechly, Matthew Marquez, and Subbarao Kambhampati. Gpt-4 doesnât know itâs wrong: An analysis of iterative prompting for reasoning problems. arXiv preprint arXiv:2310.12397, 2023.\nYashar Talebirad and Amirhossein Nadiri. Multi-agent collaboration: Harnessing the power of intelligent llm agents. arXiv preprint arXiv:2306.03314, 2023.\n16\nMiles Turpin, Julian Michael, Ethan Perez, and Samuel R Bowman. Language models donât al- ways say what they think: Unfaithful explanations in chain-of-thought prompting. arXiv preprint arXiv:2305.04388, 2023.\nPriyan Vaithilingam, Tianyi Zhang, and Elena L Glassman. Expectation vs. experience: Evaluating the usability of code generation tools powered by large language models. In Chi conference on human factors in computing systems extended abstracts, pp. 1â7, 2022.\nKarthik Valmeekam, Matthew Marquez, and Subbarao Kambhampati. Can large language models really improve by self-critiquing their own plans? arXiv preprint arXiv:2310.08118, 2023.",
            "# 3.1 Motivation: Selection as a Means of Compression\nWe argue that a fundamental problem of sequence modeling is compressing context into a smaller state. In fact, we can view the tradeoï¬s of popular sequence models from this point of view. For example, attention is both eï¬ective and ineï¬cient because it explicitly does not compress context at all. This can be seen from the fact that autoregressive inference requires explicitly storing the entire context (i.e. the KV cache), which directly causes the slow linear-time inference and quadratic-time training of Transformers. On the other hand, recurrent models are eï¬cient because they have a ï¬nite state, implying constant-time inference and linear-time training. However, their eï¬ectiveness is limited by how well this state has compressed the context.\nTo understand this principle, we focus on two running examples of synthetic tasks (Figure 2).\nâ¢ The Selective Copying task modiï¬es the popular Copying task (Arjovsky, Shah, and Bengio 2016) by varying the position of the tokens to memorize. It requires content-aware reasoning to be able to memorize the relevant tokens (colored) and ï¬lter out the irrelevant ones (white).",
            "Perfectly solved by LTI (e.g. convolutional) models that do not need to look at the actual inputs\nHi i Hl ] Bw H a H > BH\nFigure 2: (Left) The standard version of the Copying task involves constant spacing between input and output elements and is easily solved by time-invariant models such as linear recurrences and global convolutions. (Right Top) The Selective Copying task has random spacing in between inputs and requires time-varying models that can selectively remember or ignore inputs depending on their content. (Right Bottom) The Induction Heads task is an example of associative recall that requires retrieving an answer based on context, a key ability for LLMs.",
            "A neural network that is trained to perform a general task such as question- answering, could conceivably augment its view of the world by ârecallingâ in- formation from such a database and finding answers to new questions. This is particularly useful for generative agents such as chatbots who would oth- erwise be frozen in time, and whose knowledge limited to what they were\nPreface\n# Preface\nPreface\nexposed to during their training. With a vector database on the side, how- ever, they would have access to real-time information and can deduce new observations about content that is new to them. This is, in fact, the cor- nerstone of what is known as retrieval-augmented generation, an emerging learning paradigm.\nFinding the most similar vectors to a query vector is easy when the database is small or when time is not of the essence: We can simply com- pare every vector in the database with the query and sort them by similarity. When the database grows large and the time budget is limited, as is often the case in practice, a naÂ¨Ä±ve, exhaustive comparison of a query with database vectors is no longer realistic. That is where vector retrieval algorithms become relevant.",
            "# F. Discussion\nEach of the three evaluation methods possesses distinct advantages and drawbacks. Discriminative evaluation is often the method of choice for a range of standard benchmarks [6], [24]. This approach is intuitive, and the construction of evalua- tion prompts is straightforward. Selective evaluation resembles discriminative evaluation but is marginally less demanding because it includes a reference option for contrast. In both discriminative and selective evaluations, certain models might be suspected of conjecturing answers from few shots due to in- adequate reasoning skills, which can undermine the reliability of the outcomes. Consequently, the use of explainable prompt- ing becomes essential. Generative evaluation most closely mir- rors real-world applications. However, the generated content is unrestricted, which poses challenges for even the most dependable reference-based evaluation techniques. Therefore, employing a combination of metrics simultaneously, including lexical evaluation based on token coverage and semantic evaluation based on textual similarity, is imperative.",
            "Our approach engenders a more heterogeneous generation of hallucinations, mitigating the bias that may arise from the use of a single model and promoting equity within the dataset. This is due to the varying architectures and training corpora inherent to different LLMs. Furthermore, we have adopted an unconstrained generation methodology for the continuation of natural language content. This entails directly inputting the text to be continued into the model without any restrictive prompt thereby obtaining organic results. For each input example, we concurrently generate five candidate continuations. To maintain consistency across all models, we employ uniform parameter settings, with a temperature coefficient set at 1.0 and max new tokens limited to 1024.\n# C. Hallucination Ranking\nGiven the unconstrained nature of our generation paradigm, the task of discerning whether the generated content is indeed hallucinated presents a significant challenge. Upon generating the continuations, a straightforward reliance on human verifi- cation is infeasible. An exclusive dependence on human anno- tation would incur substantial costs and may not be sustainable at scale, whereas a purely machine-based approach, such as utilizing GPT4, could potentially yield less accurate results.",
            "Below are our key findings:\n1. Generative AI models understand and can be influenced by emotional stimuli. Emo- tionPrompt and EmotionAttack demonstrate consistent effectiveness in semantic under- standing and reasoning tasks. As shown in Fig. 2(a), the textual and visual Emotion- Prompt improve the semantic understanding performance by 13.88% and 16.79%, re- spectively, and improve the reasoning performance by 11.76% and 15.13%, respectively. In contrast, the textual and visual EmotionAttack impair the semantic understanding per- formance by 10.13% and 53.14%, respectively, and decrease the reasoning performance by 12.30% and 37.53%, respectively.\n2. As for generation tasks, EmotionPrompt demonstrates consistent improvement in performance, truthfulness, and responsibility over most generative questions. As shown in Fig. 1(a), EmotionPrompt improves these metrics by 15%, 9%, and 9%, re- spectively. This verifies that emotional stimuli can also work in generative tasks. The detailed results can be found in Appendices B and C."
        ],
        "response": "Prompt tokens are encoded in parallel, layer-by-layer, whereas token generation proceeds sequentially—one token at a time and layer-by-layer. Thus, phase 1 requires each layer’s parameters to be loaded only once for the entire prompt, while phase 2 must reload each layer once per generated token, making inference speed memory-bandwidth-bound.[source: unknown]",
        "reference": "The key difference between encoding the input prompt and generating tokens in generative inference is that encoding the prompt is done in parallel, layer-by-layer, while generating tokens is done sequentially, token-by-token and layer-by-layer. Additionally, generating tokens requires loading the layer once per each token generated. This difference affects the inference speed, as it is limited by how fast one can fetch parameters from system memory."
    },
    {
        "user_input": "How can the model size of large language models be reduced through quantization?",
        "retrieved_contexts": [
            "# 2.2 Post-training Quantization of LLMs\nA natural way to circumvent this is to reduce the model size through quantization (Nagel et al., 2020; Gholami et al., 2021; Frantar et al., 2022), sparsification Frantar & Alistarh (2023a); Ma et al. (2023),\n2https://github.com/dvmazur/mixtral-offloading 3https://huggingface.co/google/switch-c-2048, released in November 15th, 2022\n2\nfactorization Hsu et al. (2022), or a combination thereof. These compression types are not specific to LLMs and are based on much older methods outside the scope of our work4. However, recent works found that there are unique challenges to quantizing very large transformer-based language models due to emergent outliersDettmers et al. (2022); Lin et al. (2023); Dettmers et al. (2023).",
            "Badri, H. and Shaji, A. Half-quadratic quantization of large machine learning models, November 2023. URL https://mobiusml.github.io/hqq_blog/.\nBiderman, S., Schoelkopf, H., Anthony, Q., Bradley, H., OâBrien, K., Hallahan, E., Khan, M. A., Purohit, S., Prashanth, U. S., Raff, E., et al. Pythia: A suite for analyzing large language models across training and scaling. arXiv preprint arXiv:2304.01373, 2023.\nBrown, T., Mann, B., Ryder, N., Subbiah, M., Kaplan, J. D., Dhariwal, P., Neelakantan, A., Shyam, P., Sastry, G., Askell, A., et al. Language models are few-shot learners. In Conference on Neural Information Processing Systems (NeurIPS), 2020.\nChee, J., Cai, Y., Kuleshov, V., and Sa, C. D. Quip: 2-bit quantization of large language models with guarantees, 2023.",
            "MoE quantization. As we described earlier in Section 2.2, there are multiple weight quantization algorithms optimized for LLMs. Model compression has a natural synergy with offloading because compressed models take less time to load onto GPU. In our experitments, we also observed that MoE models get better quality-size trade-offs when quantizing experts to a lower bitwidth, while keeping all non-expert layers at 4-bit.\nWe use Half Quadratic Quantization (HQQ) (Badri & Shaji, 2023) â a data-free quantization algorithm that supports a variety of bit rates. However, we chose this algorithm only for convenience, because it was already well tested for Mixtral models. Since our analysis does not rely on any specific choice of quantization, we believe that if we chose another quantization algorithm (e.g. GPTQ or AWQ) our conclusions would be similar. In our early experiments, we also tried the sub-1-bit quantization from QMoE Frantar & Alistarh (2023b) that worked well on the Switch-c-2048 model. However, we found that sub-1-bit compression caused too significant a loss in perplexity for Mixtral-8x7B models.",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "Generally speaking, the optimal compression rate for most LLMs is 4 bits per parameter Dettmers & Zettlemoyer (2022). While there are more extreme algorithms for 3- and even 2-bit compression Chee et al. (2023); Lin et al. (2023); Dettmers et al. (2023), they are typically inferior to choosing a smaller model and quantizing it to around 4 bits. Most recently, there has been several concurrent works for quantizing Mixture-of-Experts models (Kim et al., 2023; Frantar & Alistarh, 2023b).\n# Inference with Parameter Offloading\nA recent line of work explores inferencing and training large models with limited accelerator mem- ory by âoffloadingâ their parameters to another, cheaper memory, such as system RAM or even SSD (Pudipeddi et al., 2020; Ren et al., 2021). This technique works by loading model parameters just-in-time when they are needed for computation. Since most deep learning models use layers in a fixed order, offloading can pre-dispatch the next layer parameters in the background, ahead of time.",
            "R. Guo, P. Sun, E. Lindgren, Q. Geng, D. Simcha, F. Chern, and S. Kumar. Accelerating large-scale inference with anisotropic vector quantization. In Proceedings of the 37th International Conference on Machine Learning, 2020.\nY. K. Jang and N. I. Cho. Self-supervised product quantization for deep un- supervised image retrieval. In Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 12085â12094, October 2021.\nH. JÂ´egou, M. Douze, and C. Schmid. Product quantization for nearest neigh- bor search. IEEE Transactions on Pattern Analysis and Machine Intelli- gence, 33(1):117â128, 2011.\nJ. Johnson, M. Douze, and H. JÂ´egou. Billion-scale similarity search with gpus. IEEE Transactions on Big Data, 7(3):535â547, 2021.\nY. Kalantidis and Y. Avrithis. Locally optimized product quantization for approximate nearest neighbor search. In 2014 IEEE Conference on Com- puter Vision and Pattern Recognition, pages 2329â2336, 2014.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "# REFERENCES\n[1] W. X. Zhao, K. Zhou, J. Li, T. Tang, X. Wang, Y. Hou et al., âA survey of large language models,â arXiv preprint arXiv:2303.18223, 2023. [2] V. Rawte, S. Chakraborty, A. Pathak, A. Sarkar, S. Tonmoy, A. Chadha et al., âThe troubling emergence of hallucination in large language modelsâan extensive definition, quantification, and prescriptive reme- diations,â arXiv preprint arXiv:2310.04988, 2023.\n[3] C. Wang, X. Liu, Y. Yue, X. Tang, T. Zhang, C. Jiayang et al., âSurvey on factuality in large language models: Knowledge, retrieval and domain- specificity,â arXiv preprint arXiv:2310.07521, 2023.\n[4] V. Rawte, A. Sheth, and A. Das, âA survey of hallucination in large foundation models,â arXiv preprint arXiv:2309.05922, 2023.",
            "Fedus, W., Zoph, B., and Shazeer, N. Switch transformers: Scaling to trillion parameter models with simple and efficient sparsity. arXiv preprint arXiv:2101.03961, 2021.\n8\nFrantar, E. and Alistarh, D. SparseGPT: Massive language models can be accurately pruned in one-shot. arXiv preprint arXiv:2301.00774, 2023a.\nFrantar, E. and Alistarh, D. Qmoe: Practical sub-1-bit compression of trillion-parameter models, 2023b.\nFrantar, E., Ashkboos, S., Hoefler, T., and Alistarh, D. Gptq: Accurate post-training quantization for generative pre-trained transformers. arXiv preprint arXiv:2210.17323, 2022.\nGholami, A., Kim, S., Dong, Z., Yao, Z., Mahoney, M. W., and Keutzer, K. A survey of quantization methods for efficient neural network inference. arXiv preprint arXiv:2103.13630, 2021.\nGoogle. Google colaboratory, 2023. URL https://colab.research.google.com/.",
            "A. Babenko and V. Lempitsky. Additive quantization for extreme vector compression. In 2014 IEEE Conference on Computer Vision and Pattern Recognition, pages 931â938, 2014.\n# References\nReferences\nT. Chen, L. Li, and Y. Sun. Differentiable product quantization for end- to-end embedding compression. In Proceedings of the 37th International Conference on Machine Learning, volume 119 of Proceedings of Machine Learning Research, pages 1617â1626, 7 2020.\nY. Chen, T. Guan, and C. Wang. Approximate nearest neighbor search by residual vector quantization. Sensors, 10(12):11259â11273, 2010.\nT. Ge, K. He, Q. Ke, and J. Sun. Optimized product quantization. IEEE Transactions on Pattern Analysis and Machine Intelligence, 36(4):744â755, 2014.\nR. Gray and D. Neuhoff. Quantization. IEEE Transactions on Information Theory, 44(6):2325â2383, 1998.\nR. Guo, S. Kumar, K. Choromanski, and D. Simcha. Quantization based fast inner product search. In Proceedings of the 19th International Confer- ence on Artificial Intelligence and Statistics, volume 51 of Proceedings of Machine Learning Research, pages 482â490, Cadiz, Spain, 5 2016."
        ],
        "response": "Model size can be reduced by post-training quantization that lowers the bit-width of each parameter, typically to about 4 bits per weight while maintaining acceptable quality [source unknown]. Algorithms such as Half Quadratic Quantization (HQQ), GPTQ and AWQ can be applied data-free and support 4-bit or even 2-bit representation; sub-1-bit schemes have also been explored but show larger perplexity penalties [Badri & Shaji, 2023,https://mobiusml.github.io/hqq_blog/]. Mixture-of-Experts models are often quantized with lower bitwidth only for the experts while keeping other layers at 4 bits, yielding a favorable size-accuracy trade-off [source unknown].",
        "reference": "The model size of large language models can be reduced through quantization by using compression techniques such as reducing the number of bits per parameter. The optimal compression rate for most large language models is 4 bits per parameter, although there are more extreme algorithms for 3- and 2-bit compression. However, choosing a smaller model and quantizing it to around 4 bits is typically a better option. Additionally, there have been recent works on quantizing Mixture-of-Experts models."
    },
    {
        "user_input": "Alternatively, how can the model size be reduced through sparsification while maintaining performance?",
        "retrieved_contexts": [
            "# 3.1 Motivation: Selection as a Means of Compression\nWe argue that a fundamental problem of sequence modeling is compressing context into a smaller state. In fact, we can view the tradeoï¬s of popular sequence models from this point of view. For example, attention is both eï¬ective and ineï¬cient because it explicitly does not compress context at all. This can be seen from the fact that autoregressive inference requires explicitly storing the entire context (i.e. the KV cache), which directly causes the slow linear-time inference and quadratic-time training of Transformers. On the other hand, recurrent models are eï¬cient because they have a ï¬nite state, implying constant-time inference and linear-time training. However, their eï¬ectiveness is limited by how well this state has compressed the context.\nTo understand this principle, we focus on two running examples of synthetic tasks (Figure 2).\nâ¢ The Selective Copying task modiï¬es the popular Copying task (Arjovsky, Shah, and Bengio 2016) by varying the position of the tokens to memorize. It requires content-aware reasoning to be able to memorize the relevant tokens (colored) and ï¬lter out the irrelevant ones (white).",
            "# 2.2 Post-training Quantization of LLMs\nA natural way to circumvent this is to reduce the model size through quantization (Nagel et al., 2020; Gholami et al., 2021; Frantar et al., 2022), sparsification Frantar & Alistarh (2023a); Ma et al. (2023),\n2https://github.com/dvmazur/mixtral-offloading 3https://huggingface.co/google/switch-c-2048, released in November 15th, 2022\n2\nfactorization Hsu et al. (2022), or a combination thereof. These compression types are not specific to LLMs and are based on much older methods outside the scope of our work4. However, recent works found that there are unique challenges to quantizing very large transformer-based language models due to emergent outliersDettmers et al. (2022); Lin et al. (2023); Dettmers et al. (2023).",
            "â¢ Sparse Transformer (Child et al. 2019) showed a proof-of-concept of using a strided sparse attention Transformer to model audio waveforms of length 220 = 1048576, although did not discuss performance tradeoï¬s when controlling for computation and model size.\nIn contrast, we believe this work presents one of the ï¬rst approaches to meaningfully demonstrate increasing performance with longer context.\n# C Mechanics of Selective SSMs\nProof of Theorem 1. Consider a selective SSM (Algorithm 2) with ð = 1, A = â1, B = 1, ð â = ð«ððð¾ðºð(ð¥), ðâ = ððð¿ððððð. The corresponding continuous-time SSM (1) is\nâ(ð¡) = ââ(ð¡) + ð¥(ð¡)\nwhich is also called a leaky integrator.\n27\nThe discretization step size is\nThe discretization step size is",
            "Generally speaking, the optimal compression rate for most LLMs is 4 bits per parameter Dettmers & Zettlemoyer (2022). While there are more extreme algorithms for 3- and even 2-bit compression Chee et al. (2023); Lin et al. (2023); Dettmers et al. (2023), they are typically inferior to choosing a smaller model and quantizing it to around 4 bits. Most recently, there has been several concurrent works for quantizing Mixture-of-Experts models (Kim et al., 2023; Frantar & Alistarh, 2023b).\n# Inference with Parameter Offloading\nA recent line of work explores inferencing and training large models with limited accelerator mem- ory by âoffloadingâ their parameters to another, cheaper memory, such as system RAM or even SSD (Pudipeddi et al., 2020; Ren et al., 2021). This technique works by loading model parameters just-in-time when they are needed for computation. Since most deep learning models use layers in a fixed order, offloading can pre-dispatch the next layer parameters in the background, ahead of time.",
            "MoE quantization. As we described earlier in Section 2.2, there are multiple weight quantization algorithms optimized for LLMs. Model compression has a natural synergy with offloading because compressed models take less time to load onto GPU. In our experitments, we also observed that MoE models get better quality-size trade-offs when quantizing experts to a lower bitwidth, while keeping all non-expert layers at 4-bit.\nWe use Half Quadratic Quantization (HQQ) (Badri & Shaji, 2023) â a data-free quantization algorithm that supports a variety of bit rates. However, we chose this algorithm only for convenience, because it was already well tested for Mixtral models. Since our analysis does not rely on any specific choice of quantization, we believe that if we chose another quantization algorithm (e.g. GPTQ or AWQ) our conclusions would be similar. In our early experiments, we also tried the sub-1-bit quantization from QMoE Frantar & Alistarh (2023b) that worked well on the Switch-c-2048 model. However, we found that sub-1-bit compression caused too significant a loss in perplexity for Mixtral-8x7B models.",
            "Algorithms 1 and 2 illustrates the main selection mechanism that we use. The main diï¬erence is simply making several parameters â, B, C functions of the input, along with the associated changes to tensor shapes throughout. In particular, we highlight that these parameters now have a length dimension ð¿, meaning that the model has changed from time-invariant to time-varying. (Note that shape annotations were described in Section 2). This loses the equivalence to convolutions (3) with implications for its eï¬ciency, discussed next.",
            "The main idea is to leverage properties of modern accelerators (GPUs) to materialize the state â only in more eï¬cient levels of the memory hierarchy. In particular, most operations (except matrix multiplication) are bounded by memory bandwidth (Dao, Fu, Ermon, et al. 2022; Ivanov et al. 2021; Williams, Waterman, and Patterson 2009). This includes our scan operation, and we use kernel fusion to reduce the amount of memory IOs, leading to a signiï¬cant speedup compared to a standard implementation.\nConcretely, instead of preparing the scan input (A, B) of size (ð±, ð», ð³, ð½) in GPU HBM (high-bandwidth memory), we load the SSM parameters (â, A, B, C) directly from slow HBM to fast SRAM, perform the discretization and recurrence in SRAM, and then write the ï¬nal outputs of size (ð±, ð», ð³) back to HBM.\nTo avoid the sequential recurrence, we observe that despite not being linear it can still be parallelized with a work-eï¬cient parallel scan algorithm (Blelloch 1990; Martin and Cundy 2018; Smith, Warrington, and Linderman 2023).",
            "Memory. We describe how we use the classical technique of recomputation to reduce the total amount of memory required to train selective SSM layers.\nFrom the way we fuse the forward pass, we do not save the intermediate states of size (ðµ, ð¿, ð·, ð) to avoid memory blowup. However, these intermediate states are necessary for the backward pass to compute gradients. We instead recompute those intermediate states in the backward pass. Since the inputs â, A, B, C and output gradient read from HBM to SRAM are of size ð(ðµð¿ð + ð·ð), and the input gradients are also of size ð(ðµð¿ð + ð·ð), recomputation avoids the cost of reading ð(ðµð¿ðð·) elements from HBM. This means that recomputation of the SSM states in the backward pass speeds up the computation compared to storing them and reading them from HBM.",
            "# E.5 Efficiency Benchmark\nScan Operation. We compare the core operation of selective SSMs, which is the parallel scan (Section 3.3), against convolution and attention, measured on an A100 80GB PCIe GPU. Note that these do not include the cost of other operations outside of this core operation, such as computing the convolutional kernel in global-convolution models, or computing the QKV projections in attention.\nAs a baseline, we implement a standard parallel scan in PyTorch with no kernel fusion. This requires materializing the parameters A, B, C in HBM.\nOur scan implementation fuses the discretization step and the parallel scan, avoiding the cost of materializing all the large parameters in HBM.\nFor convolution, we use the standard implementation in PyTorch, which separately performs FFTs on the inputs and the ï¬lters, multiply them in frequency domain, then performs an inverse FFT to obtain the result. The theoretical complexity is ð(ð¿ log(ð¿)) for sequence length ð¿.",
            "15\nScan vs Convolution vs Attention time (A100 80GB PCle) Inference throughput on A100 80GB (prompt length 2048) â Flashattention-2 ame ee ES 1000-1 â convolution @ 1500] mm Mamba 6.98 wwe ââ Scan (PyTorch) Py mmm Transformer 6.78 100 4 ââ Scan (ours) Ei % 00M 2 a tod S 1000 B us Ff = 2 500 â = pad oid r S12 1k 2k Â«= 4k BKK 32K GK 128k 256K 512k 1 2 Hi A 16 32 oa 128 Sequence length Batch size\n@ =\n~ Â£\nFigure 8: (Efficiency Benchmarks.) (Left) Training: our efficient scan is 40Ã faster than a standard implementation. (Right) Inference: as a recurrent model, Mamba can achieve 5Ã higher throughput than Transformers.\n# 4.6 Model Ablations\nWe perform a series of detailed ablations on components of our model, focusing on the setting of language modeling with size â 350M models at Chinchilla token counts (same setting as Figure 4).\n# 4.6.1 Architecture\nTable 6 investigates the eï¬ects of the architecture (block) and its inner SSM layer (Figure 3). We ï¬nd that"
        ],
        "response": "Sparsification reduces model size by pruning weights to zero while aiming to retain accuracy. Recent work couples pruning with quantization and off-loading so that the remaining non-zero parameters can still be encoded in ≈4 bits, giving better quality–size trade-offs than extreme 2–3-bit compression of a dense model. In Mixture-of-Experts LLMs this is done by keeping shared (non-expert) layers at 4-bit and aggressively sparsifying/quantizing the expert sub-networks, shrinking total storage without a large perplexity increase. Performance is preserved because the pruned sparse structure plus light-weight 4-bit representation keeps inference-time parameter traffic low, letting the model run with off-loading while the compute overhead of the scan-based selective SSM layers stays minimal.[source: unknown]",
        "reference": "The model size can be reduced through sparsification while maintaining performance. This can be achieved through techniques such as quantization, sparsification, factorization, or a combination of these methods. Recent works have shown that quantizing very large transformer-based language models can be challenging due to emergent outliers. However, the optimal compression rate for most language models is around 4 bits per parameter. Additionally, there have been concurrent works exploring the quantization of Mixture-of-Experts models. Another approach to reducing model size is \"offloading\" parameters to cheaper memory, such as system RAM or SSD, which allows for training and inference with limited accelerator memory."
    },
    {
        "user_input": "How does the sequential generation of tokens in interactive inference impact the speed of offloading in Mixture-of-Experts language models?",
        "retrieved_contexts": [
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "The generative inference workload consists of two phases: 1) encoding the input prompt and 2) generating tokens conditioned on that prompt. The key difference between these two phases is that prompt tokens are encoded in parallel (layer-by-layer), whereas the generation runs sequentially (token-by-token and layer-by-layer). In general, phase 1 works relatively well with existing Mixture- of-Experts algorithms, since each layer can only be loaded once for the entire prompt. In turn, when generating tokens, one must load layer once per each token generated. In practice, this means that inference speed is limited by how fast one can fetch parameters from system memory.\nBelow, we look for patterns in how the MoE model loads its experts and propose ways to exploit these patterns to speed up inference time.\n4To learn more about these methods, please refer to surveys such as Gholami et al. (2021); Liang et al. (2021) 5As opposed to running a processing a large batch of texts over many seconds, as in Sheng et al. (2023)\n3\nSelected experts for Mixtral-8x7B-Instruct woe 0 (top) and 15 ae =n a oa ao a âme: a n: ee Layer 15 expert # Layer 0 expert # MAUR STARR O However about |= and 4 training data owerful language model based trained Trans former f architecture",
            "# 4.3 Practical offloading performance\nFinally we evaluate the performance of the Mixtral8x7B-Instruct model using the offloading tech- niquesproposed throughout this report. Based on the perplexity evaluations from the previous section, we chose 4-bit HQQ quantization for the shared attention layers and 2- or 3-bit quantization for experts. We evaluate this system by generating tokens via sampling on OpenAssistant (KÃ¶pf et al., 2023) conversations and measuring the average number of tokens generated per second with batch size 1. For this evaluation, we always sample proportionally to the predicted probabilities, i.e. without temperature or nucleus sampling.",
            "This technique works particularly well when processing large batches of data, during train- ing Pudipeddi et al. (2020); Ren et al. (2021) or large-batch non-interactive inference Aminabadi et al. (2022); Sheng et al. (2023), where each layer processes a lot of tokens each time the layer is loaded from RAM. In turn, when doing interactive inference (e.g. as a chat assistants), offloading works significantly slower than on-device inference. This is because interactive inference generates tokens autoregressively, from left to right. This way, the inference system processes one or few tokens at a time, and therefore spends most of the time waiting for next layerâs parameters to be loaded.\n# 2.4 Hardware Setup",
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "For regular (dense) models, this architecture allows for efficient offloading schedule that pre-loads the next transformer layer ahead of time, while the previous layer is still running. Unfortunately, this schedule is no longer possible for Mixture-of-Experts models, where MoE MLP layers choose which experts to load just-in-time for computation. This is because the system cannot pre-fetch the next layer until it learns which experts should be loaded. Modern open-access MoE language models choose active experts using the final outputs of the previous layer, which means they cannot be pre-fetched them in parallel with previous layer. While it is not possible6 to pre-reliably prefetch the next set of experts ahead of time, the system could still try to guess the likely next experts and load them speculatively, while processing the previous layer. It the guess is correct, it will speed up the next layer inference; if not, it can load the actual next layerâs experts later. In other words, this type of speculative loading does not change the final model predictions, but may reduce latency if the guess is accurate enough.\n6More specifically, not possible without changing the model architecture, which would require re-training\n4",
            "# 2.4 Hardware Setup\nWhile our analysis is not specific to any hardware setup, we target the hardware specifications of cheap / free-tier cloud instances Google (2023) and the upper half of gaming computers Steam (2023): i) enough system memory to hold model parameters, ii) a GPU with 11-16GB VRAM and iii) host-to-device communication at 8-16GB/s (PCIe Gen.3). If we examine popular open-access MoE models (Mixtral-8x7B and switch-c-2048), we find that all non-experts can fit a fraction of available GPU memory. In turn, the experts that constitute vast majority of model parameters do not fit even with quantization. Finally, even if we could fit the model parameters in memory, running generative inference requires additional memory for layer activations and past attention keys & values.\n# 3 Method\nIn this work, we aim to systematically find the optimal way to inference modern Mixture-of-Experts LLMs on desktop or low-end cloud instances. More specifically, we focus on the task of generating tokens interactively, i.e. generate multiple tokens per second at batch size 15.",
            "[10] Jwala Dhamala, Tony Sun, Varun Kumar, Satyapriya Krishna, Yada Pruksachatkun, Kai-Wei Chang, and Rahul Gupta. Bold: Dataset and metrics for measuring biases in open-ended language generation. In Proceedings of the 2021 ACM conference on fairness, accountability, and transparency, pages 862â872, 2021.\n[11] Artyom Eliseev and Denis Mazur. Fast inference of mixture-of-experts language models with offloading. arXiv preprint arXiv:2312.17238, 2023.\n[12] William Fedus, Jeff Dean, and Barret Zoph. A review of sparse expert models in deep learning. arXiv preprint arXiv:2209.01667, 2022.\n[13] Trevor Gale, Deepak Narayanan, Cliff Young, and Matei Zaharia. Megablocks: Efficient sparse training with mixture-of-experts. arXiv preprint arXiv:2211.15841, 2022."
        ],
        "response": "Sequential, token-by-token generation forces the offloader to fetch a fresh set of experts from system memory for every new token, because the gating decision for the next MoE layer cannot be known until the previous layer has finished. This repeated per-token load makes interactive inference much slower than large-batch scenarios where each layer is loaded once for many tokens, so the generation rate becomes bounded by host-to-device transfer latency rather than compute throughput.",
        "reference": "The sequential generation of tokens in interactive inference impacts the speed of offloading in Mixture-of-Experts language models by slowing down the process. In interactive inference, tokens are generated autoregressively from left to right, processing one or a few tokens at a time. This means that the inference system spends most of the time waiting for the next layer's parameters to be loaded. Unlike regular (dense) models, where the next layer can be pre-loaded while the previous layer is still running, Mixture-of-Experts models cannot pre-fetch the next layer until it learns which experts should be loaded. Therefore, the speed of offloading is limited by how fast the parameters can be fetched from system memory."
    },
    {
        "user_input": "In comparison, how does on-device inference affect the speed of offloading in Mixture-of-Experts language models?",
        "retrieved_contexts": [
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "# 4.3 Practical offloading performance\nFinally we evaluate the performance of the Mixtral8x7B-Instruct model using the offloading tech- niquesproposed throughout this report. Based on the perplexity evaluations from the previous section, we chose 4-bit HQQ quantization for the shared attention layers and 2- or 3-bit quantization for experts. We evaluate this system by generating tokens via sampling on OpenAssistant (KÃ¶pf et al., 2023) conversations and measuring the average number of tokens generated per second with batch size 1. For this evaluation, we always sample proportionally to the predicted probabilities, i.e. without temperature or nucleus sampling.",
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction",
            "For regular (dense) models, this architecture allows for efficient offloading schedule that pre-loads the next transformer layer ahead of time, while the previous layer is still running. Unfortunately, this schedule is no longer possible for Mixture-of-Experts models, where MoE MLP layers choose which experts to load just-in-time for computation. This is because the system cannot pre-fetch the next layer until it learns which experts should be loaded. Modern open-access MoE language models choose active experts using the final outputs of the previous layer, which means they cannot be pre-fetched them in parallel with previous layer. While it is not possible6 to pre-reliably prefetch the next set of experts ahead of time, the system could still try to guess the likely next experts and load them speculatively, while processing the previous layer. It the guess is correct, it will speed up the next layer inference; if not, it can load the actual next layerâs experts later. In other words, this type of speculative loading does not change the final model predictions, but may reduce latency if the guess is accurate enough.\n6More specifically, not possible without changing the model architecture, which would require re-training\n4",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "This technique works particularly well when processing large batches of data, during train- ing Pudipeddi et al. (2020); Ren et al. (2021) or large-batch non-interactive inference Aminabadi et al. (2022); Sheng et al. (2023), where each layer processes a lot of tokens each time the layer is loaded from RAM. In turn, when doing interactive inference (e.g. as a chat assistants), offloading works significantly slower than on-device inference. This is because interactive inference generates tokens autoregressively, from left to right. This way, the inference system processes one or few tokens at a time, and therefore spends most of the time waiting for next layerâs parameters to be loaded.\n# 2.4 Hardware Setup",
            "Expert Offloading. As described earlier, we use LRU cache with an equal number k of cached experts per layer. For Mixtral-8x7B, we use k=2 for 12GB GPUs and k=4 for 16GB ones. We trigger speculative expert loading immediately after the system finished loading all experts for the current layer. The speculative expert loading fetches 1 â 2 most likely experts. The newly loaded experts do not replace the currently cached experts. If a speculatively loaded expert was later used during next layer inference, it will replace the least recently used expert from the next layerâs cache.\nMany consumer devices and free-tier cloud instances have limited host RAM that cannot fit the entire model7. In these cases, the experts must be split between host and device memory. To support this, our implementation of expert LRU cache splits experts between host and GPU devices. When loading and expert to the GPU cache, the system also offloads the least recently used on-device expert back to RAM so as to preserve memory parity.",
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization",
            "The generative inference workload consists of two phases: 1) encoding the input prompt and 2) generating tokens conditioned on that prompt. The key difference between these two phases is that prompt tokens are encoded in parallel (layer-by-layer), whereas the generation runs sequentially (token-by-token and layer-by-layer). In general, phase 1 works relatively well with existing Mixture- of-Experts algorithms, since each layer can only be loaded once for the entire prompt. In turn, when generating tokens, one must load layer once per each token generated. In practice, this means that inference speed is limited by how fast one can fetch parameters from system memory.\nBelow, we look for patterns in how the MoE model loads its experts and propose ways to exploit these patterns to speed up inference time.\n4To learn more about these methods, please refer to surveys such as Gholami et al. (2021); Liang et al. (2021) 5As opposed to running a processing a large batch of texts over many seconds, as in Sheng et al. (2023)\n3\nSelected experts for Mixtral-8x7B-Instruct woe 0 (top) and 15 ae =n a oa ao a âme: a n: ee Layer 15 expert # Layer 0 expert # MAUR STARR O However about |= and 4 training data owerful language model based trained Trans former f architecture"
        ],
        "response": "On-device inference runs significantly faster than offloading for interactive MoE generation because offloading must autoregressively load one layer’s experts per token from RAM, creating a memory-bound bottleneck, whereas on-device weights are already resident in GPU memory and avoid this repeated copy overhead [source: unknown].",
        "reference": "On-device inference is faster than offloading in Mixture-of-Experts language models. This is because during interactive inference, where tokens are generated autoregressively from left to right, the inference system processes one or few tokens at a time. As a result, most of the time is spent waiting for the next layer's parameters to be loaded. While LRU caching can reduce the average expert loading time, the majority of the inference time is still spent waiting for the next expert to be loaded. Unlike dense models, MoE offloading cannot effectively overlap expert loading with computation, making on-device inference faster in comparison."
    },
    {
        "user_input": "What are the architectural differences in terms of feedforward blocks and active parameters used during inference between Mixtral 8x7B and Mistral 7B?",
        "retrieved_contexts": [
            "We also present Mixtral 8x7B â Instruct, a chat model fine-tuned to follow instructions using supervised fine-tuning and Direct Preference Optimization [25]. Its performance notably surpasses that of GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human evaluation benchmarks. Mixtral â Instruct also demonstrates reduced biases, and a more balanced sentiment profile in benchmarks such as BBQ, and BOLD. We release both Mixtral 8x7B and Mixtral 8x7B â Instruct under the Apache 2.0 license1, free for academic and commercial usage, ensuring broad accessibility and potential for diverse applications. To enable the community to run Mixtral with a fully open-source stack, we submitted changes to the vLLM project, which integrates Megablocks CUDA kernels for efficient inference. Skypilot also allows the deployment of vLLM endpoints on any instance in the cloud.\n# 2 Architectural details\nMixtral is based on a transformer architecture [31] and uses the same modifications as described in [18], with the notable exceptions that Mix- tral supports a fully dense context length of 32k tokens, and the feed- forward blocks are replaced by Mixture-of-Expert layers (Section 2.1). The model architecture parameters are summarized in Table 1. Parameter Value",
            "Table 2: Comparison of Mixtral with Llama. Mixtral outperforms or matches Llama 2 70B performance on almost all popular benchmarks while using 5x fewer active parameters during inference.\n70 Mixtral 8x7B. âMixtral 8x7B Mixtral 8x7B 355 =o = Es & E60! Mistral 78 % 2681 Mistral 78 3 3 s0 5 = A % 66 50 g 4 45 64 78 138 348708 78 138 348708 78 138 348 70B S66 Mixtral 8x7B 50 Mixtral 8x7B 5 = 564 340 g al Mistral 78 ee Mistral 78 3 5 Â§ 30 5 eo â= Mistral Â° 20 âe LlaMA2 78 (138 348 70B 7B (138 348 708 7B Â«13B 34B 708 Active Params Active Params Active Params\nFigure 3: Results on MMLU, commonsense reasoning, world knowledge and reading comprehension, math and code for Mistral (7B/8x7B) vs Llama 2 (7B/13B/70B). Mixtral largely outperforms Llama 2 70B on all benchmarks, except on reading comprehension benchmarks while using 5x lower active parameters. It is also vastly superior to Llama 2 70B on code and math.",
            "Abstract\nWe introduce Mixtral 8x7B, a Sparse Mixture of Experts (SMoE) language model. Mixtral has the same architecture as Mistral 7B, with the difference that each layer is composed of 8 feedforward blocks (i.e. experts). For every token, at each layer, a router network selects two experts to process the current state and combine their outputs. Even though each token only sees two experts, the selected experts can be different at each timestep. As a result, each token has access to 47B parameters, but only uses 13B active parameters during inference. Mixtral was trained with a context size of 32k tokens and it outperforms or matches Llama 2 70B and GPT-3.5 across all evaluated benchmarks. In particular, Mixtral vastly outperforms Llama 2 70B on mathematics, code generation, and multilingual benchmarks. We also provide a model fine- tuned to follow instructions, Mixtral 8x7B â Instruct, that surpasses GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human bench- marks. Both the base and instruct models are released under the Apache 2.0 license.\nCode: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/",
            "# 6 Conclusion\nIn this paper, we introduced Mixtral 8x7B, the first mixture-of-experts network to reach a state-of-the- art performance among open-source models. Mixtral 8x7B Instruct outperforms Claude-2.1, Gem- ini Pro, and GPT-3.5 Turbo on human evaluation benchmarks. Because it only uses two experts at each time step, Mixtral only uses 13B active parameters per token while outperforming the previous best model using 70B parameters per token (Llama 2 70B). We are making our trained and fine-tuned mod- els publicly available under the Apache 2.0 license. By sharing our models, we aim to facilitate the de- velopment of new techniques and applications that can benefit a wide range of industries and domains.",
            "Detailed results for Mixtral, Mistral 7B and Llama 2 7B/13B/70B and Llama 1 34B2 are reported in Table 2. Figure 2 compares the performance of Mixtral with the Llama models in different categories. Mixtral surpasses Llama 2 70B across most metrics. In particular, Mixtral displays a superior performance in code and mathematics benchmarks.\nSize and Efficiency. We compare our performance to the Llama 2 family, aiming to understand Mixtral modelsâ efficiency in the cost-performance spectrum (see Figure 3). As a sparse Mixture- of-Experts model, Mixtral only uses 13B active parameters for each token. With 5x lower active parameters, Mixtral is able to outperform Llama 2 70B across most categories.\nNote that this analysis focuses on the active parameter count (see Section 2.1), which is directly proportional to the inference compute cost, but does not consider the memory costs and hardware utilization. The memory costs for serving Mixtral are proportional to its sparse parameter count, 47B, which is still smaller than Llama 2 70B. As for device utilization, we note that the SMoEs layer introduces additional overhead due to the routing mechanism and due to the increased memory loads when running more than one expert per device. They are more suitable for batched workloads where one can reach a good degree of arithmetic intensity.",
            "# 3.1 Multilingual benchmarks\nCompared to Mistral 7B, we significantly upsample the proportion of multilingual data during pretraining. The extra capacity allows Mixtral to perform well on multilingual benchmarks while maintaining a high accuracy in English. In particular, Mixtral significantly outperforms Llama 2 70B in French, German, Spanish, and Italian, as shown in Table 4.\nActive Params French Arc-c HellaS MMLU German Arc-c HellaS MMLU Spanish Arc-c HellaS MMLU Italian Arc-c HellaS MMLU 33B 70B 13B 42.9% 65.4% 49.0% 39.3% 68.1% 49.9% 49.9% 72.5% 64.3% 49.4% 70.9% 65.1% 58.2% 77.4% 70.9% 54.3% 73.0% 71.5% 55.4% 77.6% 72.5% 52.8% 75.1% 70.9% 41.1% 63.3% 48.7% 47.3% 68.7% 64.2% 45.7% 69.8% 52.3% 50.5% 74.5% 66.0%",
            "Comparison with Llama 2 70B and GPT-3.5. In Table 3, we report the performance of Mixtral 8x7B compared to Llama 2 70B and GPT-3.5. We observe that Mixtral performs similarly or above the two other models. On MMLU, Mixtral obtains a better performance, despite its significantly smaller capacity (47B tokens compared to 70B). For MT Bench, we report the performance of the latest GPT-3.5-Turbo model available, gpt-3.5-turbo-1106.\n2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4",
            "Table 1: Perplexity and model size evaluation of Mixtral-8x7B with different quantization for shared attention (Attn quant) and experts (Experts quant) layers. For comprarison, a Mistral-7B 4-bit quantized model has Wiki2 perplexity 5.03, C4 perplexity 7.56 and MMLU score 61.3%. See Section 4.2 for details. Green values correspond to the configurations we chose for full system evaluation.\n6\nAlgorithm 2-bit Experts 3-bit Experts A100 3080 Mobile 3060 T4 (Colab) A100 3080 Mobile 3060 T4 (Cloud) 3.061 Full algorithm 2.918 W/o expert pre-loading 2.265 W/o LRU cache & pre-loading Naive offloading (accelerate) 1.392 2.655 2.227 1.758 1.059 2.278 2.051 1.547 0.919 2.092 1.567 1.168 0.661 2.845 2.683 2.055 1.246 2.475 2.024 1.595 0.914 2.038 1.857 1.346 1.791 1.603 1.365 1.061 0.580",
            "n-1 y= Ss Softmax(Top2(a - W,)); - SwiGLU;(a). i=0\nThis formulation is similar to the GShard architecture [21], with the exceptions that we replace all FFN sub-blocks by MoE layers while GShard replaces every other block, and that GShard uses a more elaborate gating strategy for the second expert assigned to each token.\n# 3 Results\nWe compare Mixtral to Llama, and re-run all benchmarks with our own evaluation pipeline for fair comparison. We measure performance on a wide variety of tasks categorized as follow:\nâ¢ Commonsense Reasoning (0-shot): Hellaswag [32], Winogrande [26], PIQA [3], SIQA [27], OpenbookQA [22], ARC-Easy, ARC-Challenge [8], CommonsenseQA [30]",
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization"
        ],
        "response": "Mixtral 8x7B replaces every feed-forward block with a Mixture-of-Experts (MoE) layer that contains 8 expert feed-forward networks, while Mistral 7B uses a single dense feed-forward block per layer. At each MoE layer a router selects only the top-2 experts for each token, so Mixtral activates just 13B parameters during inference even though the full sparse model holds 47B total parameters; in contrast Mistral 7B always activates its entire 7B parameter count. Consequently Mixtral achieves performance comparable to or better than Llama 2 70B while using roughly 5× fewer active parameters than that dense baseline, giving it a lower per-token computational cost than a dense model of equivalent capacity.",
        "reference": "The architectural difference between Mixtral 8x7B and Mistral 7B lies in the number of feedforward blocks (experts) used in each layer. Mixtral 8x7B has 8 feedforward blocks in each layer, while Mistral 7B does not specify the number of feedforward blocks. Additionally, during inference, each token in both models has access to 47B parameters, but only uses 13B active parameters."
    },
    {
        "user_input": "When is offloading used on the A100 server in hardware configurations?",
        "retrieved_contexts": [
            "We consider four hardware configurations: a free-tier Colab instance with a T4 GPU (16GB VRAM, PCIe Gen.3), a past generation gaming laptop with RTX 3080 Mobile (16GB, PCIe Gen.4), a mid- range gaming desktop with RTX 3060 (12GB, PCIe Gen.3) and a high-end data-center server with A100-80GB-SXM. Note that the A100 server could run the model without offloading. We use offloading on A100 mostly to provide a reference for other setups. Finally, when evaluating 3-bit models, we use a cloud T4 from Microsoft Azure because the free-tier colab instances did not have enough RAM for this specific configuration. We use k = 2 for RTX 3060 and k = 4 for all other GPUs.\nAs shown in Table 2, all evaluated setups can generate 2-4 tokens per second with the full algorithm. Using pre-loading appears to be most beneficial on RTX 3060, possibly due to lower LRU cache size. Cursiously, RTX 3060 (desktop) performs nearly equally with a much higher end 3080 Mobile. We attribute this to the fact that both GPUs are still bottlenecked by host-to-device bandwidth, limited by the PCIe architecture. Finally, all schemes significantly outperform naive offloading that loads the entire MoE layer.\n# 5 Conclusion and Future Work",
            "# 4.3 Practical offloading performance\nFinally we evaluate the performance of the Mixtral8x7B-Instruct model using the offloading tech- niquesproposed throughout this report. Based on the perplexity evaluations from the previous section, we chose 4-bit HQQ quantization for the shared attention layers and 2- or 3-bit quantization for experts. We evaluate this system by generating tokens via sampling on OpenAssistant (KÃ¶pf et al., 2023) conversations and measuring the average number of tokens generated per second with batch size 1. For this evaluation, we always sample proportionally to the predicted probabilities, i.e. without temperature or nucleus sampling.",
            "Expert Offloading. As described earlier, we use LRU cache with an equal number k of cached experts per layer. For Mixtral-8x7B, we use k=2 for 12GB GPUs and k=4 for 16GB ones. We trigger speculative expert loading immediately after the system finished loading all experts for the current layer. The speculative expert loading fetches 1 â 2 most likely experts. The newly loaded experts do not replace the currently cached experts. If a speculatively loaded expert was later used during next layer inference, it will replace the least recently used expert from the next layerâs cache.\nMany consumer devices and free-tier cloud instances have limited host RAM that cannot fit the entire model7. In these cases, the experts must be split between host and device memory. To support this, our implementation of expert LRU cache splits experts between host and GPU devices. When loading and expert to the GPU cache, the system also offloads the least recently used on-device expert back to RAM so as to preserve memory parity.",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "This technique works particularly well when processing large batches of data, during train- ing Pudipeddi et al. (2020); Ren et al. (2021) or large-batch non-interactive inference Aminabadi et al. (2022); Sheng et al. (2023), where each layer processes a lot of tokens each time the layer is loaded from RAM. In turn, when doing interactive inference (e.g. as a chat assistants), offloading works significantly slower than on-device inference. This is because interactive inference generates tokens autoregressively, from left to right. This way, the inference system processes one or few tokens at a time, and therefore spends most of the time waiting for next layerâs parameters to be loaded.\n# 2.4 Hardware Setup",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "For regular (dense) models, this architecture allows for efficient offloading schedule that pre-loads the next transformer layer ahead of time, while the previous layer is still running. Unfortunately, this schedule is no longer possible for Mixture-of-Experts models, where MoE MLP layers choose which experts to load just-in-time for computation. This is because the system cannot pre-fetch the next layer until it learns which experts should be loaded. Modern open-access MoE language models choose active experts using the final outputs of the previous layer, which means they cannot be pre-fetched them in parallel with previous layer. While it is not possible6 to pre-reliably prefetch the next set of experts ahead of time, the system could still try to guess the likely next experts and load them speculatively, while processing the previous layer. It the guess is correct, it will speed up the next layer inference; if not, it can load the actual next layerâs experts later. In other words, this type of speculative loading does not change the final model predictions, but may reduce latency if the guess is accurate enough.\n6More specifically, not possible without changing the model architecture, which would require re-training\n4",
            "7Notably, Google Colab RAM cannot fit Mixtral-8x7B with a reasonable compression rate 8This corresponds to tensor.pin_memory() command in PyTorch.\n5\niy & cache_size =3 cache_size = 2 cache_size =4 0.84 | PIO â prefetch 1 experts ~ escent ae | PRS aa 0.2} ââ prefetch 2 experts ââ prefetch 3 experts 0.0 00 0 5 10 15 20 25 30 0 5 10 15 20 25 30 Layer # Layer # S Fd Ed Cache hit rate Bd ES Prediction recall = ES Ss &\nFigure 2: (left) LRU cache hit ratio for different cache size k; (right) speculative loading recall when pre-loading a different number of experts. Regular lines represent loading 1 layer ahead; dashed line stands for 2 layers ahead; dotted line is 10 layers ahead.\n# 4.1 Expert LRU Cache and Speculative Loading\nIn this section, we benchmark the effectiveness of the two expert offloading strategies: LRU caching and and speculative loading, as defined in Sections 3.1 and 3.2 respectively. For this evaluation, we measure âexpert recallâ â the fraction of times when an expert needed for inference was already available on GPU.",
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction"
        ],
        "response": "On the A100-80GB-SXM server, offloading is used not out of necessity—because the card has enough memory to run the model without it—but primarily as a reference benchmark to compare the behavior of other, more memory-constrained setups.",
        "reference": "Offloading is used on the A100 server in hardware configurations to provide a reference for other setups."
    },
    {
        "user_input": "How does Mixtral compare to Llama 2 70B in code benchmarks?",
        "retrieved_contexts": [
            "Detailed results for Mixtral, Mistral 7B and Llama 2 7B/13B/70B and Llama 1 34B2 are reported in Table 2. Figure 2 compares the performance of Mixtral with the Llama models in different categories. Mixtral surpasses Llama 2 70B across most metrics. In particular, Mixtral displays a superior performance in code and mathematics benchmarks.\nSize and Efficiency. We compare our performance to the Llama 2 family, aiming to understand Mixtral modelsâ efficiency in the cost-performance spectrum (see Figure 3). As a sparse Mixture- of-Experts model, Mixtral only uses 13B active parameters for each token. With 5x lower active parameters, Mixtral is able to outperform Llama 2 70B across most categories.\nNote that this analysis focuses on the active parameter count (see Section 2.1), which is directly proportional to the inference compute cost, but does not consider the memory costs and hardware utilization. The memory costs for serving Mixtral are proportional to its sparse parameter count, 47B, which is still smaller than Llama 2 70B. As for device utilization, we note that the SMoEs layer introduces additional overhead due to the routing mechanism and due to the increased memory loads when running more than one expert per device. They are more suitable for batched workloads where one can reach a good degree of arithmetic intensity.",
            "Table 2: Comparison of Mixtral with Llama. Mixtral outperforms or matches Llama 2 70B performance on almost all popular benchmarks while using 5x fewer active parameters during inference.\n70 Mixtral 8x7B. âMixtral 8x7B Mixtral 8x7B 355 =o = Es & E60! Mistral 78 % 2681 Mistral 78 3 3 s0 5 = A % 66 50 g 4 45 64 78 138 348708 78 138 348708 78 138 348 70B S66 Mixtral 8x7B 50 Mixtral 8x7B 5 = 564 340 g al Mistral 78 ee Mistral 78 3 5 Â§ 30 5 eo â= Mistral Â° 20 âe LlaMA2 78 (138 348 70B 7B (138 348 708 7B Â«13B 34B 708 Active Params Active Params Active Params\nFigure 3: Results on MMLU, commonsense reasoning, world knowledge and reading comprehension, math and code for Mistral (7B/8x7B) vs Llama 2 (7B/13B/70B). Mixtral largely outperforms Llama 2 70B on all benchmarks, except on reading comprehension benchmarks while using 5x lower active parameters. It is also vastly superior to Llama 2 70B on code and math.",
            "Comparison with Llama 2 70B and GPT-3.5. In Table 3, we report the performance of Mixtral 8x7B compared to Llama 2 70B and GPT-3.5. We observe that Mixtral performs similarly or above the two other models. On MMLU, Mixtral obtains a better performance, despite its significantly smaller capacity (47B tokens compared to 70B). For MT Bench, we report the performance of the latest GPT-3.5-Turbo model available, gpt-3.5-turbo-1106.\n2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4",
            "Llama 2 70B Mixtral 8x7B BBQ accuracy 51.5% 56.0% BOLD sentiment score (avg Â± std) gender profession religious_ideology political_ideology race 0.293 Â± 0.073 0.218 Â± 0.073 0.188 Â± 0.133 0.149 Â± 0.140 0.232 Â± 0.049 0.323 Â±0.045 0.243 Â± 0.087 0.144 Â± 0.089 0.186 Â± 0.146 0.232 Â± 0.052\nFigure 5: Bias Benchmarks. Compared Llama 2 70B, Mixtral presents less bias (higher accuracy on BBQ, lower std on BOLD) and displays more positive sentiment (higher avg on BOLD).\nWe benchmark Llama 2 and Mixtral on BBQ and BOLD with our evaluation framework and report the results in Table 5. Compared to Llama 2, Mixtral presents less bias on the BBQ benchmark (56.0% vs 51.5%). For each group in BOLD, a higher average sentiment score means more positive sentiments and a lower standard deviation indicates less bias within the group. Overall, Mixtral displays more positive sentiments than Llama 2, with similar variances within each group.\n# Instruction Fine-tuning",
            "2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4\nLLaMA 2 70B GPT-3.5 MMLU (MCQ in 57 subjects) 69.9% 70.0% 70.6% HellaSwag (10-shot) 87.1% 85.5% 86.7% ARC Challenge (25-shot) 85.1% 85.2% 85.8% WinoGrande (5-shot) 83.2% 81.6% 81.2% MBPP (pass@1) 49.8% 52.2% 60.7% GSM-8K (5-shot) 53.6% 57.1% 58.4% MT Bench (for Instruct Models) 6.86 8.32 8.30\n# Mixtral 8x7B\nTable 3: Comparison of Mixtral with Llama 2 70B and GPT-3.5. Mixtral outperforms or matches Llama 2 70B and GPT-3.5 performance on most metrics.\nEvaluation Differences. On some benchmarks, there are some differences between our evaluation protocol and the one reported in the Llama 2 paper: 1) on MBPP, we use the hand-verified subset 2) on TriviaQA, we do not provide Wikipedia contexts.\n# 3.1 Multilingual benchmarks",
            "# 3.1 Multilingual benchmarks\nCompared to Mistral 7B, we significantly upsample the proportion of multilingual data during pretraining. The extra capacity allows Mixtral to perform well on multilingual benchmarks while maintaining a high accuracy in English. In particular, Mixtral significantly outperforms Llama 2 70B in French, German, Spanish, and Italian, as shown in Table 4.\nActive Params French Arc-c HellaS MMLU German Arc-c HellaS MMLU Spanish Arc-c HellaS MMLU Italian Arc-c HellaS MMLU 33B 70B 13B 42.9% 65.4% 49.0% 39.3% 68.1% 49.9% 49.9% 72.5% 64.3% 49.4% 70.9% 65.1% 58.2% 77.4% 70.9% 54.3% 73.0% 71.5% 55.4% 77.6% 72.5% 52.8% 75.1% 70.9% 41.1% 63.3% 48.7% 47.3% 68.7% 64.2% 45.7% 69.8% 52.3% 50.5% 74.5% 66.0%",
            "Table 4: Comparison of Mixtral with Llama on Multilingual Benchmarks. On ARC Challenge, Hellaswag, and MMLU, Mixtral outperforms Llama 2 70B on 4 languages: French, German, Spanish, and Italian.\n# 3.2 Long range performance\nTo assess the capabilities of Mixtral to tackle long context, we evaluate it on the passkey retrieval task introduced in [23], a synthetic task designed to measure the ability of the model to retrieve a passkey inserted randomly in a long prompt. Results in Figure 4 (Left) show that Mixtral achieves a 100% retrieval accuracy regardless of the context length or the position of passkey in the sequence. Figure 4 (Right) shows that the perplexity of Mixtral on a subset of the proof-pile dataset [2] decreases monotonically as the size of the context increases.\nPasskey Performance ry 0.8 0.6 04 0.2 0.0 OK 4K 8K 12K 16K 20K 24K 28K Seq Len Passkey Loc\n3.8 â Mixtral_8x7B 3.5 32 > $3.0 i] 228 fos a 2.0 0 5k 10k 15k 20k 25k 30k Context length",
            "Abstract\nWe introduce Mixtral 8x7B, a Sparse Mixture of Experts (SMoE) language model. Mixtral has the same architecture as Mistral 7B, with the difference that each layer is composed of 8 feedforward blocks (i.e. experts). For every token, at each layer, a router network selects two experts to process the current state and combine their outputs. Even though each token only sees two experts, the selected experts can be different at each timestep. As a result, each token has access to 47B parameters, but only uses 13B active parameters during inference. Mixtral was trained with a context size of 32k tokens and it outperforms or matches Llama 2 70B and GPT-3.5 across all evaluated benchmarks. In particular, Mixtral vastly outperforms Llama 2 70B on mathematics, code generation, and multilingual benchmarks. We also provide a model fine- tuned to follow instructions, Mixtral 8x7B â Instruct, that surpasses GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human bench- marks. Both the base and instruct models are released under the Apache 2.0 license.\nCode: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/",
            "We also present Mixtral 8x7B â Instruct, a chat model fine-tuned to follow instructions using supervised fine-tuning and Direct Preference Optimization [25]. Its performance notably surpasses that of GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human evaluation benchmarks. Mixtral â Instruct also demonstrates reduced biases, and a more balanced sentiment profile in benchmarks such as BBQ, and BOLD. We release both Mixtral 8x7B and Mixtral 8x7B â Instruct under the Apache 2.0 license1, free for academic and commercial usage, ensuring broad accessibility and potential for diverse applications. To enable the community to run Mixtral with a fully open-source stack, we submitted changes to the vLLM project, which integrates Megablocks CUDA kernels for efficient inference. Skypilot also allows the deployment of vLLM endpoints on any instance in the cloud.\n# 2 Architectural details\nMixtral is based on a transformer architecture [31] and uses the same modifications as described in [18], with the notable exceptions that Mix- tral supports a fully dense context length of 32k tokens, and the feed- forward blocks are replaced by Mixture-of-Expert layers (Section 2.1). The model architecture parameters are summarized in Table 1. Parameter Value",
            "n-1 y= Ss Softmax(Top2(a - W,)); - SwiGLU;(a). i=0\nThis formulation is similar to the GShard architecture [21], with the exceptions that we replace all FFN sub-blocks by MoE layers while GShard replaces every other block, and that GShard uses a more elaborate gating strategy for the second expert assigned to each token.\n# 3 Results\nWe compare Mixtral to Llama, and re-run all benchmarks with our own evaluation pipeline for fair comparison. We measure performance on a wide variety of tasks categorized as follow:\nâ¢ Commonsense Reasoning (0-shot): Hellaswag [32], Winogrande [26], PIQA [3], SIQA [27], OpenbookQA [22], ARC-Easy, ARC-Challenge [8], CommonsenseQA [30]"
        ],
        "response": "Mixtral 8x7B vastly outperforms Llama 2 70B on code generation benchmarks while using only 13B active parameters per token—5× fewer than Llama’s 70B dense architecture—so it achieves higher coding scores at significantly lower inference cost [source: unknown].",
        "reference": "Mixtral outperforms Llama 2 70B in code benchmarks."
    },
    {
        "user_input": "In terms of mathematics benchmarks, how does Mixtral perform compared to Llama 2 70B?",
        "retrieved_contexts": [
            "Table 2: Comparison of Mixtral with Llama. Mixtral outperforms or matches Llama 2 70B performance on almost all popular benchmarks while using 5x fewer active parameters during inference.\n70 Mixtral 8x7B. âMixtral 8x7B Mixtral 8x7B 355 =o = Es & E60! Mistral 78 % 2681 Mistral 78 3 3 s0 5 = A % 66 50 g 4 45 64 78 138 348708 78 138 348708 78 138 348 70B S66 Mixtral 8x7B 50 Mixtral 8x7B 5 = 564 340 g al Mistral 78 ee Mistral 78 3 5 Â§ 30 5 eo â= Mistral Â° 20 âe LlaMA2 78 (138 348 70B 7B (138 348 708 7B Â«13B 34B 708 Active Params Active Params Active Params\nFigure 3: Results on MMLU, commonsense reasoning, world knowledge and reading comprehension, math and code for Mistral (7B/8x7B) vs Llama 2 (7B/13B/70B). Mixtral largely outperforms Llama 2 70B on all benchmarks, except on reading comprehension benchmarks while using 5x lower active parameters. It is also vastly superior to Llama 2 70B on code and math.",
            "Detailed results for Mixtral, Mistral 7B and Llama 2 7B/13B/70B and Llama 1 34B2 are reported in Table 2. Figure 2 compares the performance of Mixtral with the Llama models in different categories. Mixtral surpasses Llama 2 70B across most metrics. In particular, Mixtral displays a superior performance in code and mathematics benchmarks.\nSize and Efficiency. We compare our performance to the Llama 2 family, aiming to understand Mixtral modelsâ efficiency in the cost-performance spectrum (see Figure 3). As a sparse Mixture- of-Experts model, Mixtral only uses 13B active parameters for each token. With 5x lower active parameters, Mixtral is able to outperform Llama 2 70B across most categories.\nNote that this analysis focuses on the active parameter count (see Section 2.1), which is directly proportional to the inference compute cost, but does not consider the memory costs and hardware utilization. The memory costs for serving Mixtral are proportional to its sparse parameter count, 47B, which is still smaller than Llama 2 70B. As for device utilization, we note that the SMoEs layer introduces additional overhead due to the routing mechanism and due to the increased memory loads when running more than one expert per device. They are more suitable for batched workloads where one can reach a good degree of arithmetic intensity.",
            "Comparison with Llama 2 70B and GPT-3.5. In Table 3, we report the performance of Mixtral 8x7B compared to Llama 2 70B and GPT-3.5. We observe that Mixtral performs similarly or above the two other models. On MMLU, Mixtral obtains a better performance, despite its significantly smaller capacity (47B tokens compared to 70B). For MT Bench, we report the performance of the latest GPT-3.5-Turbo model available, gpt-3.5-turbo-1106.\n2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4",
            "2Since Llama 2 34B was not open-sourced, we report results for Llama 1 34B.\n4\nLLaMA 2 70B GPT-3.5 MMLU (MCQ in 57 subjects) 69.9% 70.0% 70.6% HellaSwag (10-shot) 87.1% 85.5% 86.7% ARC Challenge (25-shot) 85.1% 85.2% 85.8% WinoGrande (5-shot) 83.2% 81.6% 81.2% MBPP (pass@1) 49.8% 52.2% 60.7% GSM-8K (5-shot) 53.6% 57.1% 58.4% MT Bench (for Instruct Models) 6.86 8.32 8.30\n# Mixtral 8x7B\nTable 3: Comparison of Mixtral with Llama 2 70B and GPT-3.5. Mixtral outperforms or matches Llama 2 70B and GPT-3.5 performance on most metrics.\nEvaluation Differences. On some benchmarks, there are some differences between our evaluation protocol and the one reported in the Llama 2 paper: 1) on MBPP, we use the hand-verified subset 2) on TriviaQA, we do not provide Wikipedia contexts.\n# 3.1 Multilingual benchmarks",
            "Llama 2 70B Mixtral 8x7B BBQ accuracy 51.5% 56.0% BOLD sentiment score (avg Â± std) gender profession religious_ideology political_ideology race 0.293 Â± 0.073 0.218 Â± 0.073 0.188 Â± 0.133 0.149 Â± 0.140 0.232 Â± 0.049 0.323 Â±0.045 0.243 Â± 0.087 0.144 Â± 0.089 0.186 Â± 0.146 0.232 Â± 0.052\nFigure 5: Bias Benchmarks. Compared Llama 2 70B, Mixtral presents less bias (higher accuracy on BBQ, lower std on BOLD) and displays more positive sentiment (higher avg on BOLD).\nWe benchmark Llama 2 and Mixtral on BBQ and BOLD with our evaluation framework and report the results in Table 5. Compared to Llama 2, Mixtral presents less bias on the BBQ benchmark (56.0% vs 51.5%). For each group in BOLD, a higher average sentiment score means more positive sentiments and a lower standard deviation indicates less bias within the group. Overall, Mixtral displays more positive sentiments than Llama 2, with similar variances within each group.\n# Instruction Fine-tuning",
            "# 3.1 Multilingual benchmarks\nCompared to Mistral 7B, we significantly upsample the proportion of multilingual data during pretraining. The extra capacity allows Mixtral to perform well on multilingual benchmarks while maintaining a high accuracy in English. In particular, Mixtral significantly outperforms Llama 2 70B in French, German, Spanish, and Italian, as shown in Table 4.\nActive Params French Arc-c HellaS MMLU German Arc-c HellaS MMLU Spanish Arc-c HellaS MMLU Italian Arc-c HellaS MMLU 33B 70B 13B 42.9% 65.4% 49.0% 39.3% 68.1% 49.9% 49.9% 72.5% 64.3% 49.4% 70.9% 65.1% 58.2% 77.4% 70.9% 54.3% 73.0% 71.5% 55.4% 77.6% 72.5% 52.8% 75.1% 70.9% 41.1% 63.3% 48.7% 47.3% 68.7% 64.2% 45.7% 69.8% 52.3% 50.5% 74.5% 66.0%",
            "Table 4: Comparison of Mixtral with Llama on Multilingual Benchmarks. On ARC Challenge, Hellaswag, and MMLU, Mixtral outperforms Llama 2 70B on 4 languages: French, German, Spanish, and Italian.\n# 3.2 Long range performance\nTo assess the capabilities of Mixtral to tackle long context, we evaluate it on the passkey retrieval task introduced in [23], a synthetic task designed to measure the ability of the model to retrieve a passkey inserted randomly in a long prompt. Results in Figure 4 (Left) show that Mixtral achieves a 100% retrieval accuracy regardless of the context length or the position of passkey in the sequence. Figure 4 (Right) shows that the perplexity of Mixtral on a subset of the proof-pile dataset [2] decreases monotonically as the size of the context increases.\nPasskey Performance ry 0.8 0.6 04 0.2 0.0 OK 4K 8K 12K 16K 20K 24K 28K Seq Len Passkey Loc\n3.8 â Mixtral_8x7B 3.5 32 > $3.0 i] 228 fos a 2.0 0 5k 10k 15k 20k 25k 30k Context length",
            "n-1 y= Ss Softmax(Top2(a - W,)); - SwiGLU;(a). i=0\nThis formulation is similar to the GShard architecture [21], with the exceptions that we replace all FFN sub-blocks by MoE layers while GShard replaces every other block, and that GShard uses a more elaborate gating strategy for the second expert assigned to each token.\n# 3 Results\nWe compare Mixtral to Llama, and re-run all benchmarks with our own evaluation pipeline for fair comparison. We measure performance on a wide variety of tasks categorized as follow:\nâ¢ Commonsense Reasoning (0-shot): Hellaswag [32], Winogrande [26], PIQA [3], SIQA [27], OpenbookQA [22], ARC-Easy, ARC-Challenge [8], CommonsenseQA [30]",
            "# 6 Conclusion\nIn this paper, we introduced Mixtral 8x7B, the first mixture-of-experts network to reach a state-of-the- art performance among open-source models. Mixtral 8x7B Instruct outperforms Claude-2.1, Gem- ini Pro, and GPT-3.5 Turbo on human evaluation benchmarks. Because it only uses two experts at each time step, Mixtral only uses 13B active parameters per token while outperforming the previous best model using 70B parameters per token (Llama 2 70B). We are making our trained and fine-tuned mod- els publicly available under the Apache 2.0 license. By sharing our models, we aim to facilitate the de- velopment of new techniques and applications that can benefit a wide range of industries and domains.",
            "Abstract\nWe introduce Mixtral 8x7B, a Sparse Mixture of Experts (SMoE) language model. Mixtral has the same architecture as Mistral 7B, with the difference that each layer is composed of 8 feedforward blocks (i.e. experts). For every token, at each layer, a router network selects two experts to process the current state and combine their outputs. Even though each token only sees two experts, the selected experts can be different at each timestep. As a result, each token has access to 47B parameters, but only uses 13B active parameters during inference. Mixtral was trained with a context size of 32k tokens and it outperforms or matches Llama 2 70B and GPT-3.5 across all evaluated benchmarks. In particular, Mixtral vastly outperforms Llama 2 70B on mathematics, code generation, and multilingual benchmarks. We also provide a model fine- tuned to follow instructions, Mixtral 8x7B â Instruct, that surpasses GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human bench- marks. Both the base and instruct models are released under the Apache 2.0 license.\nCode: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/"
        ],
        "response": "On mathematics benchmarks Mixtral 8×7B significantly surpasses Llama 2 70B while using only 13B active parameters per token instead of 70B, translating to 5× lower inference compute. Specifically, on GSM-8K (5-shot) Mixtral scores 58.4% versus Llama 2 70B’s 53.6%.[source: unknown]",
        "reference": "Mixtral performs better than Llama 2 70B in terms of mathematics benchmarks."
    },
    {
        "user_input": "What is the relationship between benchmarking the expert LRU cache and speculative loading, and the expert recall rate in the Mixtral-8x7B-Instruct model on the OpenAssistant dataset?",
        "retrieved_contexts": [
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization",
            "7Notably, Google Colab RAM cannot fit Mixtral-8x7B with a reasonable compression rate 8This corresponds to tensor.pin_memory() command in PyTorch.\n5\niy & cache_size =3 cache_size = 2 cache_size =4 0.84 | PIO â prefetch 1 experts ~ escent ae | PRS aa 0.2} ââ prefetch 2 experts ââ prefetch 3 experts 0.0 00 0 5 10 15 20 25 30 0 5 10 15 20 25 30 Layer # Layer # S Fd Ed Cache hit rate Bd ES Prediction recall = ES Ss &\nFigure 2: (left) LRU cache hit ratio for different cache size k; (right) speculative loading recall when pre-loading a different number of experts. Regular lines represent loading 1 layer ahead; dashed line stands for 2 layers ahead; dotted line is 10 layers ahead.\n# 4.1 Expert LRU Cache and Speculative Loading\nIn this section, we benchmark the effectiveness of the two expert offloading strategies: LRU caching and and speculative loading, as defined in Sections 3.1 and 3.2 respectively. For this evaluation, we measure âexpert recallâ â the fraction of times when an expert needed for inference was already available on GPU.",
            "Expert Offloading. As described earlier, we use LRU cache with an equal number k of cached experts per layer. For Mixtral-8x7B, we use k=2 for 12GB GPUs and k=4 for 16GB ones. We trigger speculative expert loading immediately after the system finished loading all experts for the current layer. The speculative expert loading fetches 1 â 2 most likely experts. The newly loaded experts do not replace the currently cached experts. If a speculatively loaded expert was later used during next layer inference, it will replace the least recently used expert from the next layerâs cache.\nMany consumer devices and free-tier cloud instances have limited host RAM that cannot fit the entire model7. In these cases, the experts must be split between host and device memory. To support this, our implementation of expert LRU cache splits experts between host and GPU devices. When loading and expert to the GPU cache, the system also offloads the least recently used on-device expert back to RAM so as to preserve memory parity.",
            "We illustrate an example of how LRU cache saves experts in Figure 1 (see caption). LRU is a very simple strategy that does not consider factors like expert activation frequencies, varying cache size between MoE layers, or any sequential patterns in expert activation. However, we found that even this simple strategy can significantly speed up inference for modern Mixture-of-Experts models such as Mixtral-8x7B (see Section 4 for detailed evaluation).\n# 3.2 Speculative Expert Loading\nWhile LRU caching can reduce the average expert loading time, most of the inference time is still spent waiting for the next expert to be loaded. The reason behind this is that, unlike with dense models, MoE offloading cannot effectively overlap expert loading with computation. To understand this problem, let us zoom into the process of generating a single token, layer-by-layer. The full compute workload starts by embedding the previous token via look-up, then alternates between running self-attention and MLP for each transformer block in the model. Finally, the outputs from the last transformer block are used to predict next token logits with a linear projection.",
            "Figure 1: An example of expert loading pattern in Mixtral-8x7B-Instruct for select layers. Blue cells indicate that a certain expert was active when encoding a certain token; deeper blue indicates higher gating weight. Small gray squares show which experts are cached with an LRU cache for k=2.\n# 3.1 Expert Locality and LRU caching\nAs we discussed earlier in Section 2.1, Mixture-of-Experts language models were often observed to assign individual experts to distinct sub-tasks. However, this does not mean that the model uses the same expert over long stretches of tokens. Instead, some experts are active in short sequences of 2-4 tokens, while others are often used with âgapsâ, as shown in Figure 1.\nTo take advantage of this pattern, we can keep active experts in GPU memory as a âcacheâ for future tokens. If the same experts are activated again in future, they will be available instantaneously. Naturally, the number of experts that can be stored this way if very limited by the available GPU memory. For simplicity, we choose to always keep k least recently used experts as a type of LRU cache. If k is greater than the number of active experts, the cache will save experts from multiple previous tokens. For simplicity, we keep the same number of cached experts for each MoE layer.",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "n-1 y= Ss Softmax(Top2(a - W,)); - SwiGLU;(a). i=0\nThis formulation is similar to the GShard architecture [21], with the exceptions that we replace all FFN sub-blocks by MoE layers while GShard replaces every other block, and that GShard uses a more elaborate gating strategy for the second expert assigned to each token.\n# 3 Results\nWe compare Mixtral to Llama, and re-run all benchmarks with our own evaluation pipeline for fair comparison. We measure performance on a wide variety of tasks categorized as follow:\nâ¢ Commonsense Reasoning (0-shot): Hellaswag [32], Winogrande [26], PIQA [3], SIQA [27], OpenbookQA [22], ARC-Easy, ARC-Challenge [8], CommonsenseQA [30]",
            "# 6 Conclusion\nIn this paper, we introduced Mixtral 8x7B, the first mixture-of-experts network to reach a state-of-the- art performance among open-source models. Mixtral 8x7B Instruct outperforms Claude-2.1, Gem- ini Pro, and GPT-3.5 Turbo on human evaluation benchmarks. Because it only uses two experts at each time step, Mixtral only uses 13B active parameters per token while outperforming the previous best model using 70B parameters per token (Llama 2 70B). We are making our trained and fine-tuned mod- els publicly available under the Apache 2.0 license. By sharing our models, we aim to facilitate the de- velopment of new techniques and applications that can benefit a wide range of industries and domains.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "# 4.3 Practical offloading performance\nFinally we evaluate the performance of the Mixtral8x7B-Instruct model using the offloading tech- niquesproposed throughout this report. Based on the perplexity evaluations from the previous section, we chose 4-bit HQQ quantization for the shared attention layers and 2- or 3-bit quantization for experts. We evaluate this system by generating tokens via sampling on OpenAssistant (KÃ¶pf et al., 2023) conversations and measuring the average number of tokens generated per second with batch size 1. For this evaluation, we always sample proportionally to the predicted probabilities, i.e. without temperature or nucleus sampling."
        ],
        "response": "Benchmarking the expert LRU cache and speculative loading directly measures the “expert recall” rate on Mixtral-8x7B-Instruct running the OpenAssistant dataset. LRU caching records which experts are reused across adjacent tokens; for cache sizes k=2 and k=4 the cache hit ratio is reported, showing how often an expert needed for inference was already resident on GPU. Speculative loading tests how accurately the next layer’s gating function—applied to the current layer’s activations—predicts the experts that will be required 1, 2 or 10 layers ahead; a recall of 1.0 means both active experts for the next layer were pre-fetched. Thus the experiments quantify the extent to which locality and early-layer hidden-state information can be exploited to keep the correct experts on-device, raising the overall expert recall rate and reducing loading stalls. I don't have sufficient information to answer this.",
        "reference": "The relationship between benchmarking the expert LRU cache and speculative loading and the expert recall rate in the Mixtral-8x7B-Instruct model on the OpenAssistant dataset is not mentioned in the given context."
    },
    {
        "user_input": "How does the use of sparse Mixture-of-Experts (MoE) in language models contribute to faster token generation?",
        "retrieved_contexts": [
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "Shazeer et al. (2017) builds on this idea to train a sparsely gated Mixture-of-Experts to serve as a language model. The full model consists of a recurrent neural network backbone and a MoE module with up to 131072 experts. When processing a given token, a linear gating function select 4 most suitable experts based on the latest hidden state. The resulting model (including the gating function and experts) is trained end-to-end to minimize cross-entropy, with an additional regularizer to promote equal expert utilization. Shazeer et al. (2017) observed that the MoE model not only improves perplexity, but also learns interpretable expert specializations: some experts would âspecializeâ on prepositions, while others learn to express a particular concept (e.g. speed).",
            "[10] Jwala Dhamala, Tony Sun, Varun Kumar, Satyapriya Krishna, Yada Pruksachatkun, Kai-Wei Chang, and Rahul Gupta. Bold: Dataset and metrics for measuring biases in open-ended language generation. In Proceedings of the 2021 ACM conference on fairness, accountability, and transparency, pages 862â872, 2021.\n[11] Artyom Eliseev and Denis Mazur. Fast inference of mixture-of-experts language models with offloading. arXiv preprint arXiv:2312.17238, 2023.\n[12] William Fedus, Jeff Dean, and Barret Zoph. A review of sparse expert models in deep learning. arXiv preprint arXiv:2209.01667, 2022.\n[13] Trevor Gale, Deepak Narayanan, Cliff Young, and Matei Zaharia. Megablocks: Efficient sparse training with mixture-of-experts. arXiv preprint arXiv:2211.15841, 2022.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "Since then, several lines of work explore Mixture-of-Experts with Transformer-based language models for machine translation Lepikhin et al. (2020), masked language modeling Fedus et al. (2021), general-purpose LLMs Du et al. (2022) and others. Most of these models follow traditional (dense) Transformer architecture for embeddings and attention layers, and only use Mixture for the feedforward (MLP) blocks and use a linear token-level gating function. A common observation across most of these works is that MoE models are cheaper to train and inference Fedus et al. (2021); Lepikhin et al. (2020), but require more parameters than a dense model with equivalent perplexity. Pre-trained Mixture-of-Experts LLMs have been openly available for over a year3. However, these models seem to have gained less traction than equivalent dense models, arguable because their sheer model size (over a trillion parameters) makes them difficult to use. Most recently, Mistral AI released a family of sparse Mixture of Experts models called Mixtral-8x7B with near state-of-the-art performance Mixtral AI team (2023). This model has already inspired several follow-up works and practical applications, but it still requires a high-end GPU accelerator.\n# 2.2 Post-training Quantization of LLMs",
            "Several recent works modify transformer architecture by introducing sparse Mixture-of-Experts blocks (Jacobs et al., 1991; Shazeer et al., 2017). MoE blocks contain multiple âexpertsâ (layers), as well as a âgating functionâ that selects which experts are used on a given input. As a result, the MoE block uses a small portion of all âexpertsâ for any single forward pass, allowing for more compute-efficient training Fedus et al. (2021); Du et al. (2022). Notably, MoEs are among the largest Fedus et al. (2021) and among the best Mixtral AI team (2023) of available LLMs. While Mixture-of-Experts models can be more efficient than their dense counterparts, many techniques for efficient LLM inference were not designed with MoE in mind and perform suboptimally on modern large language models that use mixture-of-experts layers.\n1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.",
            "The generative inference workload consists of two phases: 1) encoding the input prompt and 2) generating tokens conditioned on that prompt. The key difference between these two phases is that prompt tokens are encoded in parallel (layer-by-layer), whereas the generation runs sequentially (token-by-token and layer-by-layer). In general, phase 1 works relatively well with existing Mixture- of-Experts algorithms, since each layer can only be loaded once for the entire prompt. In turn, when generating tokens, one must load layer once per each token generated. In practice, this means that inference speed is limited by how fast one can fetch parameters from system memory.\nBelow, we look for patterns in how the MoE model loads its experts and propose ways to exploit these patterns to speed up inference time.\n4To learn more about these methods, please refer to surveys such as Gholami et al. (2021); Liang et al. (2021) 5As opposed to running a processing a large batch of texts over many seconds, as in Sheng et al. (2023)\n3\nSelected experts for Mixtral-8x7B-Instruct woe 0 (top) and 15 ae =n a oa ao a âme: a n: ee Layer 15 expert # Layer 0 expert # MAUR STARR O However about |= and 4 training data owerful language model based trained Trans former f architecture",
            "# 2.4 Hardware Setup\nWhile our analysis is not specific to any hardware setup, we target the hardware specifications of cheap / free-tier cloud instances Google (2023) and the upper half of gaming computers Steam (2023): i) enough system memory to hold model parameters, ii) a GPU with 11-16GB VRAM and iii) host-to-device communication at 8-16GB/s (PCIe Gen.3). If we examine popular open-access MoE models (Mixtral-8x7B and switch-c-2048), we find that all non-experts can fit a fraction of available GPU memory. In turn, the experts that constitute vast majority of model parameters do not fit even with quantization. Finally, even if we could fit the model parameters in memory, running generative inference requires additional memory for layer activations and past attention keys & values.\n# 3 Method\nIn this work, we aim to systematically find the optimal way to inference modern Mixture-of-Experts LLMs on desktop or low-end cloud instances. More specifically, we focus on the task of generating tokens interactively, i.e. generate multiple tokens per second at batch size 15.",
            "Google. Google colaboratory, 2023. URL https://colab.research.google.com/.\nHendrycks, D., Burns, C., Basart, S., Zou, A., Mazeika, M., Song, D., and Steinhardt, J. Measuring massive multitask language understanding. Proceedings of the International Conference on Learning Representations (ICLR), 2021.\nHsu, Y.-C., Hua, T., Chang, S., Lou, Q., Shen, Y., and Jin, H. Language model compression with weighted low-rank factorization. arXiv preprint arXiv:2207.00112, 2022.\nJacobs, R. A., Jordan, M. I., Nowlan, S. J., and Hinton, G. E. Adaptive mixtures of local experts. Neural Computation, 3(1):79â87, March 1991. ISSN 0899-7667. doi: 10.1162/neco.1991.3.1.79. URL https://doi.org/10.1162/neco.1991.3.1.79.\nJordan, M. I. and Jacobs, R. A. Hierarchical mixtures of experts and the em algorithm. Neural computation, 6(2):181â214, 1994."
        ],
        "response": "Sparse MoE accelerates token generation because only a small, dynamically chosen subset of experts is activated per token, slashing the amount of computation and parameter I/O compared with a dense model that always uses every layer [https://arxiv.org/abs/2312.17238]. A further speed-up is obtained by observing that experts tend to be reused across adjacent tokens and that earlier hidden states predict which experts later layers will need; an LRU cache keeps frequently used experts in GPU memory and a prefetch mechanism overlaps expert loading with computation, cutting host-to-device transfers and enabling 2-3 tokens/s on consumer GPUs [https://arxiv.org/abs/2312.17238].",
        "reference": "The use of sparse Mixture-of-Experts (MoE) in language models contributes to faster token generation because only a fraction of model layers are active for any given input. This means that MoE-based language models can generate tokens faster than their \"dense\" counterparts. The MoE blocks in the model contain multiple \"experts\" (layers) and a \"gating function\" that selects which experts are used for a given input. By using a small portion of all \"experts\" for each forward pass, the MoE block allows for more compute-efficient training, leading to faster token generation."
    },
    {
        "user_input": "What impact does the use of sparse Mixture-of-Experts (MoE) have on the size of language models?",
        "retrieved_contexts": [
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction",
            "Several recent works modify transformer architecture by introducing sparse Mixture-of-Experts blocks (Jacobs et al., 1991; Shazeer et al., 2017). MoE blocks contain multiple âexpertsâ (layers), as well as a âgating functionâ that selects which experts are used on a given input. As a result, the MoE block uses a small portion of all âexpertsâ for any single forward pass, allowing for more compute-efficient training Fedus et al. (2021); Du et al. (2022). Notably, MoEs are among the largest Fedus et al. (2021) and among the best Mixtral AI team (2023) of available LLMs. While Mixture-of-Experts models can be more efficient than their dense counterparts, many techniques for efficient LLM inference were not designed with MoE in mind and perform suboptimally on modern large language models that use mixture-of-experts layers.\n1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.",
            "Shazeer et al. (2017) builds on this idea to train a sparsely gated Mixture-of-Experts to serve as a language model. The full model consists of a recurrent neural network backbone and a MoE module with up to 131072 experts. When processing a given token, a linear gating function select 4 most suitable experts based on the latest hidden state. The resulting model (including the gating function and experts) is trained end-to-end to minimize cross-entropy, with an additional regularizer to promote equal expert utilization. Shazeer et al. (2017) observed that the MoE model not only improves perplexity, but also learns interpretable expert specializations: some experts would âspecializeâ on prepositions, while others learn to express a particular concept (e.g. speed).",
            "[10] Jwala Dhamala, Tony Sun, Varun Kumar, Satyapriya Krishna, Yada Pruksachatkun, Kai-Wei Chang, and Rahul Gupta. Bold: Dataset and metrics for measuring biases in open-ended language generation. In Proceedings of the 2021 ACM conference on fairness, accountability, and transparency, pages 862â872, 2021.\n[11] Artyom Eliseev and Denis Mazur. Fast inference of mixture-of-experts language models with offloading. arXiv preprint arXiv:2312.17238, 2023.\n[12] William Fedus, Jeff Dean, and Barret Zoph. A review of sparse expert models in deep learning. arXiv preprint arXiv:2209.01667, 2022.\n[13] Trevor Gale, Deepak Narayanan, Cliff Young, and Matei Zaharia. Megablocks: Efficient sparse training with mixture-of-experts. arXiv preprint arXiv:2211.15841, 2022.",
            "Since then, several lines of work explore Mixture-of-Experts with Transformer-based language models for machine translation Lepikhin et al. (2020), masked language modeling Fedus et al. (2021), general-purpose LLMs Du et al. (2022) and others. Most of these models follow traditional (dense) Transformer architecture for embeddings and attention layers, and only use Mixture for the feedforward (MLP) blocks and use a linear token-level gating function. A common observation across most of these works is that MoE models are cheaper to train and inference Fedus et al. (2021); Lepikhin et al. (2020), but require more parameters than a dense model with equivalent perplexity. Pre-trained Mixture-of-Experts LLMs have been openly available for over a year3. However, these models seem to have gained less traction than equivalent dense models, arguable because their sheer model size (over a trillion parameters) makes them difficult to use. Most recently, Mistral AI released a family of sparse Mixture of Experts models called Mixtral-8x7B with near state-of-the-art performance Mixtral AI team (2023). This model has already inspired several follow-up works and practical applications, but it still requires a high-end GPU accelerator.\n# 2.2 Post-training Quantization of LLMs",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2",
            "Abstract\nWe introduce Mixtral 8x7B, a Sparse Mixture of Experts (SMoE) language model. Mixtral has the same architecture as Mistral 7B, with the difference that each layer is composed of 8 feedforward blocks (i.e. experts). For every token, at each layer, a router network selects two experts to process the current state and combine their outputs. Even though each token only sees two experts, the selected experts can be different at each timestep. As a result, each token has access to 47B parameters, but only uses 13B active parameters during inference. Mixtral was trained with a context size of 32k tokens and it outperforms or matches Llama 2 70B and GPT-3.5 across all evaluated benchmarks. In particular, Mixtral vastly outperforms Llama 2 70B on mathematics, code generation, and multilingual benchmarks. We also provide a model fine- tuned to follow instructions, Mixtral 8x7B â Instruct, that surpasses GPT-3.5 Turbo, Claude-2.1, Gemini Pro, and Llama 2 70B â chat model on human bench- marks. Both the base and instruct models are released under the Apache 2.0 license.\nCode: https://github.com/mistralai/mistral-src Webpage: https://mistral.ai/news/mixtral-of-experts/",
            "Google. Google colaboratory, 2023. URL https://colab.research.google.com/.\nHendrycks, D., Burns, C., Basart, S., Zou, A., Mazeika, M., Song, D., and Steinhardt, J. Measuring massive multitask language understanding. Proceedings of the International Conference on Learning Representations (ICLR), 2021.\nHsu, Y.-C., Hua, T., Chang, S., Lou, Q., Shen, Y., and Jin, H. Language model compression with weighted low-rank factorization. arXiv preprint arXiv:2207.00112, 2022.\nJacobs, R. A., Jordan, M. I., Nowlan, S. J., and Hinton, G. E. Adaptive mixtures of local experts. Neural Computation, 3(1):79â87, March 1991. ISSN 0899-7667. doi: 10.1162/neco.1991.3.1.79. URL https://doi.org/10.1162/neco.1991.3.1.79.\nJordan, M. I. and Jacobs, R. A. Hierarchical mixtures of experts and the em algorithm. Neural computation, 6(2):181â214, 1994.",
            "# 2 Background & Related Work\n# 2.1 Mixture-of-Experts\nThe recent surge in MoE language models builds on a relatively old idea (Jacobs et al., 1991; Jordan & Jacobs, 1994) of training ensembles of specialized models (âexpertsâ) and a gating function to select the right expert for the task. To achieve specialization, Mixture-of-Experts learn by simultaneously i) training the gating function to choose the best experts and ii) training the experts themselves on samples assigned to them by the gating function. Since then, many different MoE variants emerged, including mixture of SVM models (Collobert et al., 2002), Dirichlet processes (Shahbaba & Neal, 2009) and various neural networks."
        ],
        "response": "Sparse MoE increases model size because it replicates the feed-forward layers into many parallel \"experts,\" so the total parameter count grows even though only a subset of experts is active per token. For instance, Mixtral-8x7B offers 47 B parameters in aggregate but activates just 13 B at each step, yielding a model that is several times larger than an equivalent dense 13 B-parameter network [https://mistral.ai/news/mixtral-of-experts/]. This parameter inflation makes state-of-the-art MoE LLMs exceed a trillion total parameters and hard to deploy without high-end GPUs [https://arxiv.org/abs/2312.17238].",
        "reference": "The use of sparse Mixture-of-Experts (MoE) increases the size of language models due to having multiple \"experts.\""
    },
    {
        "user_input": "How does LRU caching improve the inference speed of Mixture-of-Experts language models?",
        "retrieved_contexts": [
            "We illustrate an example of how LRU cache saves experts in Figure 1 (see caption). LRU is a very simple strategy that does not consider factors like expert activation frequencies, varying cache size between MoE layers, or any sequential patterns in expert activation. However, we found that even this simple strategy can significantly speed up inference for modern Mixture-of-Experts models such as Mixtral-8x7B (see Section 4 for detailed evaluation).\n# 3.2 Speculative Expert Loading\nWhile LRU caching can reduce the average expert loading time, most of the inference time is still spent waiting for the next expert to be loaded. The reason behind this is that, unlike with dense models, MoE offloading cannot effectively overlap expert loading with computation. To understand this problem, let us zoom into the process of generating a single token, layer-by-layer. The full compute workload starts by embedding the previous token via look-up, then alternates between running self-attention and MLP for each transformer block in the model. Finally, the outputs from the last transformer block are used to predict next token logits with a linear projection.",
            "For this evaluation, we run Mixtral-8x7B-Instruct model on the OpenAssistant dataset (KÃ¶pf et al., 2023). We test LRU caching by running the model on recorded conversations and measuring the recall (aka âhit ratioâ from caching perspective) for different cache sizes k. Next, we test speculative loading in isolation by âguessingâ which experts should be loaded (by applying the next layerâs gating function on current layer activations), then measuring how often the actual next experts get loaded this way. A recall of 1.0 corresponds to a situation where both (2) Mixtral active experts were pre-fetched. We test speculative loading in three settings: 1, 2 and 10 layers ahead.\n# 4.2 Mixed MoE Quantization",
            "7Notably, Google Colab RAM cannot fit Mixtral-8x7B with a reasonable compression rate 8This corresponds to tensor.pin_memory() command in PyTorch.\n5\niy & cache_size =3 cache_size = 2 cache_size =4 0.84 | PIO â prefetch 1 experts ~ escent ae | PRS aa 0.2} ââ prefetch 2 experts ââ prefetch 3 experts 0.0 00 0 5 10 15 20 25 30 0 5 10 15 20 25 30 Layer # Layer # S Fd Ed Cache hit rate Bd ES Prediction recall = ES Ss &\nFigure 2: (left) LRU cache hit ratio for different cache size k; (right) speculative loading recall when pre-loading a different number of experts. Regular lines represent loading 1 layer ahead; dashed line stands for 2 layers ahead; dotted line is 10 layers ahead.\n# 4.1 Expert LRU Cache and Speculative Loading\nIn this section, we benchmark the effectiveness of the two expert offloading strategies: LRU caching and and speculative loading, as defined in Sections 3.1 and 3.2 respectively. For this evaluation, we measure âexpert recallâ â the fraction of times when an expert needed for inference was already available on GPU.",
            "# 5 Conclusion and Future Work\nIn this work, we explore strategies for accelerating Mixture-of-Experts based language models on consumer hardware with limited GPU memory. We propose a MoE-centric approach to offloading\n7\nand explore how mixed quantization affects perplexity and performance on language understanding tasks. We evaluate the proposed strategies and show that they produce a significant increase in generation speed compared to naÂ¨ve approaches on consumer-grade hardware, including free-tier Google Colab.\nOur method provides a practical solution for inferencing large MoE language models on resource- constricted hardware, enabling broader access to these powerful models for research and development. As future work, we plan to explore further offloading strategies, based on speculative expert predic- tion.\n# Acknowledgements\nAuthors would like to acknowledge mobicham@ for helpful discussions on Mixtral quantization.\n# References\nAminabadi, R. Y., Rajbhandari, S., Awan, A. A., Li, C., Li, D., Zheng, E., Ruwase, O., Smith, S., Zhang, M., Rasley, J., and He, Y. Deepspeed-inference: Enabling efficient inference of transformer models at unprecedented scale. In Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis, SC â22. IEEE Press, 2022. ISBN 9784665454445.",
            "Figure 1: An example of expert loading pattern in Mixtral-8x7B-Instruct for select layers. Blue cells indicate that a certain expert was active when encoding a certain token; deeper blue indicates higher gating weight. Small gray squares show which experts are cached with an LRU cache for k=2.\n# 3.1 Expert Locality and LRU caching\nAs we discussed earlier in Section 2.1, Mixture-of-Experts language models were often observed to assign individual experts to distinct sub-tasks. However, this does not mean that the model uses the same expert over long stretches of tokens. Instead, some experts are active in short sequences of 2-4 tokens, while others are often used with âgapsâ, as shown in Figure 1.\nTo take advantage of this pattern, we can keep active experts in GPU memory as a âcacheâ for future tokens. If the same experts are activated again in future, they will be available instantaneously. Naturally, the number of experts that can be stored this way if very limited by the available GPU memory. For simplicity, we choose to always keep k least recently used experts as a type of LRU cache. If k is greater than the number of active experts, the cache will save experts from multiple previous tokens. For simplicity, we keep the same number of cached experts for each MoE layer.",
            "Expert Offloading. As described earlier, we use LRU cache with an equal number k of cached experts per layer. For Mixtral-8x7B, we use k=2 for 12GB GPUs and k=4 for 16GB ones. We trigger speculative expert loading immediately after the system finished loading all experts for the current layer. The speculative expert loading fetches 1 â 2 most likely experts. The newly loaded experts do not replace the currently cached experts. If a speculatively loaded expert was later used during next layer inference, it will replace the least recently used expert from the next layerâs cache.\nMany consumer devices and free-tier cloud instances have limited host RAM that cannot fit the entire model7. In these cases, the experts must be split between host and device memory. To support this, our implementation of expert LRU cache splits experts between host and GPU devices. When loading and expert to the GPU cache, the system also offloads the least recently used on-device expert back to RAM so as to preserve memory parity.",
            "To speed up offloading in practice, we allocate all expert parameters in a contiguous memory buffer that can be moved as a single host-to-device copy. For host-side (RAM) experts, we pin8 this memory buffer for faster communication. Our implementation additionally allocates b=4 on-device buffers used to copy and prefetch experts asynchronously, without modifying existing experts. These buffers are shared between all MoE layers to reduce memory footprint. Overall, the system requires num_layers Ã num_experts expert memory buffers split between host and device memory and b=4 temporary buffers, the size of each buffer being equal to a single expert.\n# 4 Experiments\nIn this section, we verify our earlier hypotheses about MoE behavior and benchmark the inference latency in different conditions. We focus our evaluations on Mixtral-8x7B and Mixtral-8x7B-Instruct models since they represent the current state of the art among open-access MoE models. We organize this section as follows: Section 4.1 measures the effectiveness of expert caching and pre-loading in isolation, Section 4.2 compares different model compression algorithms and verifies our hypotheses from Section 3.3. Finally, Section 4.3 measures the inference latency in several hardware setups.",
            "# Denis Mazur Moscow Institute of Physics and Technology Yandex Researchcore denismazur8@gmail.com\n# Abstract\nWith the widespread adoption of Large Language Models (LLMs), many deep learning practitioners are looking for strategies of running these models more efficiently. One such strategy is to use sparse Mixture-of-Experts (MoE) â a type of model architectures where only a fraction of model layers are active for any given input. This property allows MoE-based language models to generate tokens faster than their âdenseâ counterparts, but it also increases model size due to having multiple âexpertsâ. Unfortunately, this makes state-of-the-art MoE language models difficult to run without high-end GPUs. In this work, we study the problem of running large MoE language models on consumer hardware with limited accelerator memory. We build upon parameter offloading algorithms and propose a novel strategy that accelerates offloading by taking advantage of innate properties of MoE LLMs. Using this strategy, we build can run Mixtral-8x7B with mixed quantization on desktop hardware and free-tier Google Colab instances.\n# Introduction",
            "Google. Google colaboratory, 2023. URL https://colab.research.google.com/.\nHendrycks, D., Burns, C., Basart, S., Zou, A., Mazeika, M., Song, D., and Steinhardt, J. Measuring massive multitask language understanding. Proceedings of the International Conference on Learning Representations (ICLR), 2021.\nHsu, Y.-C., Hua, T., Chang, S., Lou, Q., Shen, Y., and Jin, H. Language model compression with weighted low-rank factorization. arXiv preprint arXiv:2207.00112, 2022.\nJacobs, R. A., Jordan, M. I., Nowlan, S. J., and Hinton, G. E. Adaptive mixtures of local experts. Neural Computation, 3(1):79â87, March 1991. ISSN 0899-7667. doi: 10.1162/neco.1991.3.1.79. URL https://doi.org/10.1162/neco.1991.3.1.79.\nJordan, M. I. and Jacobs, R. A. Hierarchical mixtures of experts and the em algorithm. Neural computation, 6(2):181â214, 1994.",
            "1When deployed in 16-bit precision, Falcon-180B needs approximately 360GB, while LLaMA-2 70B requires 140GB of combined accelerator memory.\nIn this work, we systematically develop techniques for running large MoE language models with limited GPU memory. Our main objective is inferencing (generating tokens) with Mixtral-8x7B- Instruct â a MoE-based chat assistant â on a desktop-grade hardware where only a fraction of experts fit into the accelerator memory. To that end:\nwe observe how MoE language model accesses its experts between tokens, and find several regularities: i) some experts are reused between adjacent tokens and ii) the model hidden states of early layers already âknowâ which experts are to be used at subsequent layers. â¢ we design a MoE-specific offloading strategy that takes advantage of these regularities: i) it uses LRU cache to significantly reduces GPU-RAM communication, leading to faster generation and ii) it guesses which experts are needed ahead of time to better overlap expert loading with computation.\nâ¢ we consider the specific scenario of running Mixtral-8x7B-Instruct on a T4, RTX 3060 and RTX 3080 Mobile and develop a practical combination of mixed quantization and the proposed offloading algorithm to run this model interactively at 2-3 tokens per second depending on the hardware. The source code with our implementation is available online2"
        ],
        "response": "LRU caching keeps the k least-recently-used experts in GPU memory across MoE layers. When the same experts are requested again within a few tokens they are already resident, eliminating the PCIe transfer that dominates per-token latency. Experiments on Mixtral-8x7B show this simple strategy raises expert recall to 0.7–0.9 with k=2–4 experts cached per layer, directly cutting average expert loading time and yielding several-fold speed-ups over naïve CPU-offload baselines on consumer GPUs. [source: unknown]",
        "reference": "LRU caching improves the inference speed of Mixture-of-Experts language models by keeping active experts in GPU memory as a cache for future tokens. This allows for faster retrieval of experts when needed during inference."
    }
]